// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"XHUo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.write = exports.viewport = exports.variationPlacements = exports.top = exports.start = exports.right = exports.reference = exports.read = exports.popper = exports.placements = exports.modifierPhases = exports.main = exports.left = exports.end = exports.clippingParents = exports.bottom = exports.beforeWrite = exports.beforeRead = exports.beforeMain = exports.basePlacements = exports.auto = exports.afterWrite = exports.afterRead = exports.afterMain = void 0;
var top = 'top';
exports.top = top;
var bottom = 'bottom';
exports.bottom = bottom;
var right = 'right';
exports.right = right;
var left = 'left';
exports.left = left;
var auto = 'auto';
exports.auto = auto;
var basePlacements = [top, bottom, right, left];
exports.basePlacements = basePlacements;
var start = 'start';
exports.start = start;
var end = 'end';
exports.end = end;
var clippingParents = 'clippingParents';
exports.clippingParents = clippingParents;
var viewport = 'viewport';
exports.viewport = viewport;
var popper = 'popper';
exports.popper = popper;
var reference = 'reference';
exports.reference = reference;
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
exports.variationPlacements = variationPlacements;
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

exports.placements = placements;
var beforeRead = 'beforeRead';
exports.beforeRead = beforeRead;
var read = 'read';
exports.read = read;
var afterRead = 'afterRead'; // pure-logic modifiers

exports.afterRead = afterRead;
var beforeMain = 'beforeMain';
exports.beforeMain = beforeMain;
var main = 'main';
exports.main = main;
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

exports.afterMain = afterMain;
var beforeWrite = 'beforeWrite';
exports.beforeWrite = beforeWrite;
var write = 'write';
exports.write = write;
var afterWrite = 'afterWrite';
exports.afterWrite = afterWrite;
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
exports.modifierPhases = modifierPhases;
},{}],"B1zX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getNodeName;

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}
},{}],"QiNa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getWindow;

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}
},{}],"wsKO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isElement = isElement;
exports.isHTMLElement = isHTMLElement;
exports.isShadowRoot = isShadowRoot;

var _getWindow = _interopRequireDefault(require("./getWindow.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isElement(node) {
  var OwnElement = (0, _getWindow.default)(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = (0, _getWindow.default)(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = (0, _getWindow.default)(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
},{"./getWindow.js":"QiNa"}],"D2nT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getNodeName = _interopRequireDefault(require("../dom-utils/getNodeName.js"));

var _instanceOf = require("../dom-utils/instanceOf.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0, _instanceOf.isHTMLElement)(element) || !(0, _getNodeName.default)(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0, _instanceOf.isHTMLElement)(element) || !(0, _getNodeName.default)(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
};
exports.default = _default;
},{"../dom-utils/getNodeName.js":"B1zX","../dom-utils/instanceOf.js":"wsKO"}],"QS9h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBasePlacement;

var _enums = require("../enums.js");

function getBasePlacement(placement) {
  return placement.split('-')[0];
}
},{"../enums.js":"XHUo"}],"FuL6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.round = exports.min = exports.max = void 0;
var max = Math.max;
exports.max = max;
var min = Math.min;
exports.min = min;
var round = Math.round;
exports.round = round;
},{}],"W8bA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBoundingClientRect;

var _instanceOf = require("./instanceOf.js");

var _math = require("../utils/math.js");

function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if ((0, _instanceOf.isHTMLElement)(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
    // Fallback to 1 in case both values are `0`

    if (offsetWidth > 0) {
      scaleX = (0, _math.round)(rect.width) / offsetWidth || 1;
    }

    if (offsetHeight > 0) {
      scaleY = (0, _math.round)(rect.height) / offsetHeight || 1;
    }
  }

  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
},{"./instanceOf.js":"wsKO","../utils/math.js":"FuL6"}],"wDsK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getLayoutRect;

var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.
function getLayoutRect(element) {
  var clientRect = (0, _getBoundingClientRect.default)(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}
},{"./getBoundingClientRect.js":"W8bA"}],"x3Ja":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = contains;

var _instanceOf = require("./instanceOf.js");

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0, _instanceOf.isShadowRoot)(rootNode)) {
    var next = child;

    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...


      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false


  return false;
}
},{"./instanceOf.js":"wsKO"}],"S6rb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getComputedStyle;

var _getWindow = _interopRequireDefault(require("./getWindow.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getComputedStyle(element) {
  return (0, _getWindow.default)(element).getComputedStyle(element);
}
},{"./getWindow.js":"QiNa"}],"rK11":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isTableElement;

var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0, _getNodeName.default)(element)) >= 0;
}
},{"./getNodeName.js":"B1zX"}],"sJcE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDocumentElement;

var _instanceOf = require("./instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0, _instanceOf.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}
},{"./instanceOf.js":"wsKO"}],"IVKl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getParentNode;

var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));

var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));

var _instanceOf = require("./instanceOf.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getParentNode(element) {
  if ((0, _getNodeName.default)(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    (0, _instanceOf.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0, _getDocumentElement.default)(element) // fallback

  );
}
},{"./getNodeName.js":"B1zX","./getDocumentElement.js":"sJcE","./instanceOf.js":"wsKO"}],"CUhI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOffsetParent;

var _getWindow = _interopRequireDefault(require("./getWindow.js"));

var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));

var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));

var _instanceOf = require("./instanceOf.js");

var _isTableElement = _interopRequireDefault(require("./isTableElement.js"));

var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getTrueOffsetParent(element) {
  if (!(0, _instanceOf.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0, _getComputedStyle.default)(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && (0, _instanceOf.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0, _getComputedStyle.default)(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = (0, _getParentNode.default)(element);

  if ((0, _instanceOf.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }

  while ((0, _instanceOf.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0, _getNodeName.default)(currentNode)) < 0) {
    var css = (0, _getComputedStyle.default)(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = (0, _getWindow.default)(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && (0, _isTableElement.default)(offsetParent) && (0, _getComputedStyle.default)(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && ((0, _getNodeName.default)(offsetParent) === 'html' || (0, _getNodeName.default)(offsetParent) === 'body' && (0, _getComputedStyle.default)(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}
},{"./getWindow.js":"QiNa","./getNodeName.js":"B1zX","./getComputedStyle.js":"S6rb","./instanceOf.js":"wsKO","./isTableElement.js":"rK11","./getParentNode.js":"IVKl"}],"PMyK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getMainAxisFromPlacement;

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}
},{}],"FbIu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.within = within;
exports.withinMaxClamp = withinMaxClamp;

var _math = require("./math.js");

function within(min, value, max) {
  return (0, _math.max)(min, (0, _math.min)(value, max));
}

function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}
},{"./math.js":"FuL6"}],"a0QL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFreshSideObject;

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
},{}],"SCz0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergePaddingObject;

var _getFreshSideObject = _interopRequireDefault(require("./getFreshSideObject.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0, _getFreshSideObject.default)(), paddingObject);
}
},{"./getFreshSideObject.js":"a0QL"}],"sYkG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = expandToHashMap;

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
},{}],"zJlD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));

var _getLayoutRect = _interopRequireDefault(require("../dom-utils/getLayoutRect.js"));

var _contains = _interopRequireDefault(require("../dom-utils/contains.js"));

var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));

var _getMainAxisFromPlacement = _interopRequireDefault(require("../utils/getMainAxisFromPlacement.js"));

var _within = require("../utils/within.js");

var _mergePaddingObject = _interopRequireDefault(require("../utils/mergePaddingObject.js"));

var _expandToHashMap = _interopRequireDefault(require("../utils/expandToHashMap.js"));

var _enums = require("../enums.js");

var _instanceOf = require("../dom-utils/instanceOf.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unused-modules
var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0, _mergePaddingObject.default)(typeof padding !== 'number' ? padding : (0, _expandToHashMap.default)(padding, _enums.basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0, _getBasePlacement.default)(state.placement);
  var axis = (0, _getMainAxisFromPlacement.default)(basePlacement);
  var isVertical = [_enums.left, _enums.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0, _getLayoutRect.default)(arrowElement);
  var minProp = axis === 'y' ? _enums.top : _enums.left;
  var maxProp = axis === 'y' ? _enums.bottom : _enums.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0, _getOffsetParent.default)(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0, _within.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if ("production" !== "production") {
    if (!(0, _instanceOf.isHTMLElement)(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!(0, _contains.default)(state.elements.popper, arrowElement)) {
    if ("production" !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};
exports.default = _default;
},{"../utils/getBasePlacement.js":"QS9h","../dom-utils/getLayoutRect.js":"wDsK","../dom-utils/contains.js":"x3Ja","../dom-utils/getOffsetParent.js":"CUhI","../utils/getMainAxisFromPlacement.js":"PMyK","../utils/within.js":"FbIu","../utils/mergePaddingObject.js":"SCz0","../utils/expandToHashMap.js":"sYkG","../enums.js":"XHUo","../dom-utils/instanceOf.js":"wsKO"}],"auH8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getVariation;

function getVariation(placement) {
  return placement.split('-')[1];
}
},{}],"ebtt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.mapToStyles = mapToStyles;

var _enums = require("../enums.js");

var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));

var _getWindow = _interopRequireDefault(require("../dom-utils/getWindow.js"));

var _getDocumentElement = _interopRequireDefault(require("../dom-utils/getDocumentElement.js"));

var _getComputedStyle = _interopRequireDefault(require("../dom-utils/getComputedStyle.js"));

var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));

var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));

var _math = require("../utils/math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unused-modules
var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0, _math.round)(x * dpr) / dpr || 0,
    y: (0, _math.round)(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums.left;
  var sideY = _enums.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0, _getOffsetParent.default)(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === (0, _getWindow.default)(popper)) {
      offsetParent = (0, _getDocumentElement.default)(popper);

      if ((0, _getComputedStyle.default)(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === _enums.top || (placement === _enums.left || placement === _enums.right) && variation === _enums.end) {
      sideY = _enums.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums.left || (placement === _enums.top || placement === _enums.bottom) && variation === _enums.end) {
      sideX = _enums.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if ("production" !== "production") {
    var transitionProperty = (0, _getComputedStyle.default)(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: (0, _getBasePlacement.default)(state.placement),
    variation: (0, _getVariation.default)(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};
exports.default = _default;
},{"../enums.js":"XHUo","../dom-utils/getOffsetParent.js":"CUhI","../dom-utils/getWindow.js":"QiNa","../dom-utils/getDocumentElement.js":"sJcE","../dom-utils/getComputedStyle.js":"S6rb","../utils/getBasePlacement.js":"QS9h","../utils/getVariation.js":"auH8","../utils/math.js":"FuL6"}],"psGJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getWindow = _interopRequireDefault(require("../dom-utils/getWindow.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unused-modules
var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0, _getWindow.default)(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};
exports.default = _default;
},{"../dom-utils/getWindow.js":"QiNa"}],"M6e4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOppositePlacement;
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};

function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
},{}],"lLmA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOppositeVariationPlacement;
var hash = {
  start: 'end',
  end: 'start'
};

function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}
},{}],"oJ75":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getWindowScroll;

var _getWindow = _interopRequireDefault(require("./getWindow.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getWindowScroll(node) {
  var win = (0, _getWindow.default)(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
},{"./getWindow.js":"QiNa"}],"zwcJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getWindowScrollBarX;

var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));

var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));

var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0, _getBoundingClientRect.default)((0, _getDocumentElement.default)(element)).left + (0, _getWindowScroll.default)(element).scrollLeft;
}
},{"./getBoundingClientRect.js":"W8bA","./getDocumentElement.js":"sJcE","./getWindowScroll.js":"oJ75"}],"E2lw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getViewportRect;

var _getWindow = _interopRequireDefault(require("./getWindow.js"));

var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));

var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getViewportRect(element) {
  var win = (0, _getWindow.default)(element);
  var html = (0, _getDocumentElement.default)(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + (0, _getWindowScrollBarX.default)(element),
    y: y
  };
}
},{"./getWindow.js":"QiNa","./getDocumentElement.js":"sJcE","./getWindowScrollBarX.js":"zwcJ"}],"yEje":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getDocumentRect;

var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));

var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));

var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));

var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));

var _math = require("../utils/math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable
function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = (0, _getDocumentElement.default)(element);
  var winScroll = (0, _getWindowScroll.default)(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0, _math.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0, _math.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0, _getWindowScrollBarX.default)(element);
  var y = -winScroll.scrollTop;

  if ((0, _getComputedStyle.default)(body || html).direction === 'rtl') {
    x += (0, _math.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
},{"./getDocumentElement.js":"sJcE","./getComputedStyle.js":"S6rb","./getWindowScrollBarX.js":"zwcJ","./getWindowScroll.js":"oJ75","../utils/math.js":"FuL6"}],"j3Hf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isScrollParent;

var _getComputedStyle2 = _interopRequireDefault(require("./getComputedStyle.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0, _getComputedStyle2.default)(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
},{"./getComputedStyle.js":"S6rb"}],"Qnrt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getScrollParent;

var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));

var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));

var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));

var _instanceOf = require("./instanceOf.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0, _getNodeName.default)(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0, _instanceOf.isHTMLElement)(node) && (0, _isScrollParent.default)(node)) {
    return node;
  }

  return getScrollParent((0, _getParentNode.default)(node));
}
},{"./getParentNode.js":"IVKl","./isScrollParent.js":"j3Hf","./getNodeName.js":"B1zX","./instanceOf.js":"wsKO"}],"m3DJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = listScrollParents;

var _getScrollParent = _interopRequireDefault(require("./getScrollParent.js"));

var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));

var _getWindow = _interopRequireDefault(require("./getWindow.js"));

var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/
function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0, _getScrollParent.default)(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0, _getWindow.default)(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0, _isScrollParent.default)(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0, _getParentNode.default)(target)));
}
},{"./getScrollParent.js":"Qnrt","./getParentNode.js":"IVKl","./getWindow.js":"QiNa","./isScrollParent.js":"j3Hf"}],"rB0G":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rectToClientRect;

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
},{}],"M7BJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getClippingRect;

var _enums = require("../enums.js");

var _getViewportRect = _interopRequireDefault(require("./getViewportRect.js"));

var _getDocumentRect = _interopRequireDefault(require("./getDocumentRect.js"));

var _listScrollParents = _interopRequireDefault(require("./listScrollParents.js"));

var _getOffsetParent = _interopRequireDefault(require("./getOffsetParent.js"));

var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));

var _getComputedStyle = _interopRequireDefault(require("./getComputedStyle.js"));

var _instanceOf = require("./instanceOf.js");

var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));

var _getParentNode = _interopRequireDefault(require("./getParentNode.js"));

var _contains = _interopRequireDefault(require("./contains.js"));

var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));

var _rectToClientRect = _interopRequireDefault(require("../utils/rectToClientRect.js"));

var _math = require("../utils/math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getInnerBoundingClientRect(element) {
  var rect = (0, _getBoundingClientRect.default)(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === _enums.viewport ? (0, _rectToClientRect.default)((0, _getViewportRect.default)(element)) : (0, _instanceOf.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent) : (0, _rectToClientRect.default)((0, _getDocumentRect.default)((0, _getDocumentElement.default)(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0, _listScrollParents.default)((0, _getParentNode.default)(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0, _getComputedStyle.default)(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0, _instanceOf.isHTMLElement)(element) ? (0, _getOffsetParent.default)(element) : element;

  if (!(0, _instanceOf.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0, _instanceOf.isElement)(clippingParent) && (0, _contains.default)(clippingParent, clipperElement) && (0, _getNodeName.default)(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = (0, _math.max)(rect.top, accRect.top);
    accRect.right = (0, _math.min)(rect.right, accRect.right);
    accRect.bottom = (0, _math.min)(rect.bottom, accRect.bottom);
    accRect.left = (0, _math.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
},{"../enums.js":"XHUo","./getViewportRect.js":"E2lw","./getDocumentRect.js":"yEje","./listScrollParents.js":"m3DJ","./getOffsetParent.js":"CUhI","./getDocumentElement.js":"sJcE","./getComputedStyle.js":"S6rb","./instanceOf.js":"wsKO","./getBoundingClientRect.js":"W8bA","./getParentNode.js":"IVKl","./contains.js":"x3Ja","./getNodeName.js":"B1zX","../utils/rectToClientRect.js":"rB0G","../utils/math.js":"FuL6"}],"dvfD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = computeOffsets;

var _getBasePlacement = _interopRequireDefault(require("./getBasePlacement.js"));

var _getVariation = _interopRequireDefault(require("./getVariation.js"));

var _getMainAxisFromPlacement = _interopRequireDefault(require("./getMainAxisFromPlacement.js"));

var _enums = require("../enums.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0, _getBasePlacement.default)(placement) : null;
  var variation = placement ? (0, _getVariation.default)(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0, _getMainAxisFromPlacement.default)(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case _enums.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}
},{"./getBasePlacement.js":"QS9h","./getVariation.js":"auH8","./getMainAxisFromPlacement.js":"PMyK","../enums.js":"XHUo"}],"Moke":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = detectOverflow;

var _getClippingRect = _interopRequireDefault(require("../dom-utils/getClippingRect.js"));

var _getDocumentElement = _interopRequireDefault(require("../dom-utils/getDocumentElement.js"));

var _getBoundingClientRect = _interopRequireDefault(require("../dom-utils/getBoundingClientRect.js"));

var _computeOffsets = _interopRequireDefault(require("./computeOffsets.js"));

var _rectToClientRect = _interopRequireDefault(require("./rectToClientRect.js"));

var _enums = require("../enums.js");

var _instanceOf = require("../dom-utils/instanceOf.js");

var _mergePaddingObject = _interopRequireDefault(require("./mergePaddingObject.js"));

var _expandToHashMap = _interopRequireDefault(require("./expandToHashMap.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unused-modules
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0, _mergePaddingObject.default)(typeof padding !== 'number' ? padding : (0, _expandToHashMap.default)(padding, _enums.basePlacements));
  var altContext = elementContext === _enums.popper ? _enums.reference : _enums.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0, _getClippingRect.default)((0, _instanceOf.isElement)(element) ? element : element.contextElement || (0, _getDocumentElement.default)(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = (0, _getBoundingClientRect.default)(state.elements.reference);
  var popperOffsets = (0, _computeOffsets.default)({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0, _rectToClientRect.default)(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums.right, _enums.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums.top, _enums.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}
},{"../dom-utils/getClippingRect.js":"M7BJ","../dom-utils/getDocumentElement.js":"sJcE","../dom-utils/getBoundingClientRect.js":"W8bA","./computeOffsets.js":"dvfD","./rectToClientRect.js":"rB0G","../enums.js":"XHUo","../dom-utils/instanceOf.js":"wsKO","./mergePaddingObject.js":"SCz0","./expandToHashMap.js":"sYkG"}],"HhJi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = computeAutoPlacement;

var _getVariation = _interopRequireDefault(require("./getVariation.js"));

var _enums = require("../enums.js");

var _detectOverflow = _interopRequireDefault(require("./detectOverflow.js"));

var _getBasePlacement = _interopRequireDefault(require("./getBasePlacement.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums.placements : _options$allowedAutoP;
  var variation = (0, _getVariation.default)(placement);
  var placements = variation ? flipVariations ? _enums.variationPlacements : _enums.variationPlacements.filter(function (placement) {
    return (0, _getVariation.default)(placement) === variation;
  }) : _enums.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;

    if ("production" !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0, _detectOverflow.default)(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0, _getBasePlacement.default)(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
},{"./getVariation.js":"auH8","../enums.js":"XHUo","./detectOverflow.js":"Moke","./getBasePlacement.js":"QS9h"}],"rNoN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getOppositePlacement = _interopRequireDefault(require("../utils/getOppositePlacement.js"));

var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));

var _getOppositeVariationPlacement = _interopRequireDefault(require("../utils/getOppositeVariationPlacement.js"));

var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));

var _computeAutoPlacement = _interopRequireDefault(require("../utils/computeAutoPlacement.js"));

var _enums = require("../enums.js");

var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unused-modules
function getExpandedFallbackPlacements(placement) {
  if ((0, _getBasePlacement.default)(placement) === _enums.auto) {
    return [];
  }

  var oppositePlacement = (0, _getOppositePlacement.default)(placement);
  return [(0, _getOppositeVariationPlacement.default)(placement), oppositePlacement, (0, _getOppositeVariationPlacement.default)(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0, _getBasePlacement.default)(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0, _getOppositePlacement.default)(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0, _getBasePlacement.default)(placement) === _enums.auto ? (0, _computeAutoPlacement.default)(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0, _getBasePlacement.default)(placement);

    var isStartVariation = (0, _getVariation.default)(placement) === _enums.start;

    var isVertical = [_enums.top, _enums.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0, _detectOverflow.default)(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums.right : _enums.left : isStartVariation ? _enums.bottom : _enums.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0, _getOppositePlacement.default)(mainVariationSide);
    }

    var altVariationSide = (0, _getOppositePlacement.default)(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};
exports.default = _default;
},{"../utils/getOppositePlacement.js":"M6e4","../utils/getBasePlacement.js":"QS9h","../utils/getOppositeVariationPlacement.js":"lLmA","../utils/detectOverflow.js":"Moke","../utils/computeAutoPlacement.js":"HhJi","../enums.js":"XHUo","../utils/getVariation.js":"auH8"}],"jhaw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _enums = require("../enums.js");

var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums.top, _enums.right, _enums.bottom, _enums.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0, _detectOverflow.default)(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0, _detectOverflow.default)(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};
exports.default = _default;
},{"../enums.js":"XHUo","../utils/detectOverflow.js":"Moke"}],"aUNc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.distanceAndSkiddingToXY = distanceAndSkiddingToXY;

var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));

var _enums = require("../enums.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line import/no-unused-modules
function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0, _getBasePlacement.default)(placement);
  var invertDistance = [_enums.left, _enums.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums.left, _enums.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;

  var data = _enums.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});

  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};
exports.default = _default;
},{"../utils/getBasePlacement.js":"QS9h","../enums.js":"XHUo"}],"Pf8x":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _computeOffsets = _interopRequireDefault(require("../utils/computeOffsets.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name; // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step

  state.modifiersData[name] = (0, _computeOffsets.default)({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};
exports.default = _default;
},{"../utils/computeOffsets.js":"dvfD"}],"YGKJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getAltAxis;

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
},{}],"RwXk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _enums = require("../enums.js");

var _getBasePlacement = _interopRequireDefault(require("../utils/getBasePlacement.js"));

var _getMainAxisFromPlacement = _interopRequireDefault(require("../utils/getMainAxisFromPlacement.js"));

var _getAltAxis = _interopRequireDefault(require("../utils/getAltAxis.js"));

var _within = require("../utils/within.js");

var _getLayoutRect = _interopRequireDefault(require("../dom-utils/getLayoutRect.js"));

var _getOffsetParent = _interopRequireDefault(require("../dom-utils/getOffsetParent.js"));

var _detectOverflow = _interopRequireDefault(require("../utils/detectOverflow.js"));

var _getVariation = _interopRequireDefault(require("../utils/getVariation.js"));

var _getFreshSideObject = _interopRequireDefault(require("../utils/getFreshSideObject.js"));

var _math = require("../utils/math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0, _detectOverflow.default)(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0, _getBasePlacement.default)(state.placement);
  var variation = (0, _getVariation.default)(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0, _getMainAxisFromPlacement.default)(basePlacement);
  var altAxis = (0, _getAltAxis.default)(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? _enums.top : _enums.left;
    var altSide = mainAxis === 'y' ? _enums.bottom : _enums.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0, _getLayoutRect.default)(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0, _getFreshSideObject.default)();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0, _within.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0, _getOffsetParent.default)(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0, _within.within)(tether ? (0, _math.min)(min, tetherMin) : min, offset, tether ? (0, _math.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? _enums.top : _enums.left;

    var _altSide = mainAxis === 'x' ? _enums.bottom : _enums.right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [_enums.top, _enums.left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? (0, _within.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0, _within.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var _default = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};
exports.default = _default;
},{"../enums.js":"XHUo","../utils/getBasePlacement.js":"QS9h","../utils/getMainAxisFromPlacement.js":"PMyK","../utils/getAltAxis.js":"YGKJ","../utils/within.js":"FbIu","../dom-utils/getLayoutRect.js":"wDsK","../dom-utils/getOffsetParent.js":"CUhI","../utils/detectOverflow.js":"Moke","../utils/getVariation.js":"auH8","../utils/getFreshSideObject.js":"a0QL","../utils/math.js":"FuL6"}],"TOq4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "applyStyles", {
  enumerable: true,
  get: function () {
    return _applyStyles.default;
  }
});
Object.defineProperty(exports, "arrow", {
  enumerable: true,
  get: function () {
    return _arrow.default;
  }
});
Object.defineProperty(exports, "computeStyles", {
  enumerable: true,
  get: function () {
    return _computeStyles.default;
  }
});
Object.defineProperty(exports, "eventListeners", {
  enumerable: true,
  get: function () {
    return _eventListeners.default;
  }
});
Object.defineProperty(exports, "flip", {
  enumerable: true,
  get: function () {
    return _flip.default;
  }
});
Object.defineProperty(exports, "hide", {
  enumerable: true,
  get: function () {
    return _hide.default;
  }
});
Object.defineProperty(exports, "offset", {
  enumerable: true,
  get: function () {
    return _offset.default;
  }
});
Object.defineProperty(exports, "popperOffsets", {
  enumerable: true,
  get: function () {
    return _popperOffsets.default;
  }
});
Object.defineProperty(exports, "preventOverflow", {
  enumerable: true,
  get: function () {
    return _preventOverflow.default;
  }
});

var _applyStyles = _interopRequireDefault(require("./applyStyles.js"));

var _arrow = _interopRequireDefault(require("./arrow.js"));

var _computeStyles = _interopRequireDefault(require("./computeStyles.js"));

var _eventListeners = _interopRequireDefault(require("./eventListeners.js"));

var _flip = _interopRequireDefault(require("./flip.js"));

var _hide = _interopRequireDefault(require("./hide.js"));

var _offset = _interopRequireDefault(require("./offset.js"));

var _popperOffsets = _interopRequireDefault(require("./popperOffsets.js"));

var _preventOverflow = _interopRequireDefault(require("./preventOverflow.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./applyStyles.js":"D2nT","./arrow.js":"zJlD","./computeStyles.js":"ebtt","./eventListeners.js":"psGJ","./flip.js":"rNoN","./hide.js":"jhaw","./offset.js":"aUNc","./popperOffsets.js":"Pf8x","./preventOverflow.js":"RwXk"}],"uy7N":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHTMLElementScroll;

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
},{}],"Cbix":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getNodeScroll;

var _getWindowScroll = _interopRequireDefault(require("./getWindowScroll.js"));

var _getWindow = _interopRequireDefault(require("./getWindow.js"));

var _instanceOf = require("./instanceOf.js");

var _getHTMLElementScroll = _interopRequireDefault(require("./getHTMLElementScroll.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getNodeScroll(node) {
  if (node === (0, _getWindow.default)(node) || !(0, _instanceOf.isHTMLElement)(node)) {
    return (0, _getWindowScroll.default)(node);
  } else {
    return (0, _getHTMLElementScroll.default)(node);
  }
}
},{"./getWindowScroll.js":"oJ75","./getWindow.js":"QiNa","./instanceOf.js":"wsKO","./getHTMLElementScroll.js":"uy7N"}],"FCaM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getCompositeRect;

var _getBoundingClientRect = _interopRequireDefault(require("./getBoundingClientRect.js"));

var _getNodeScroll = _interopRequireDefault(require("./getNodeScroll.js"));

var _getNodeName = _interopRequireDefault(require("./getNodeName.js"));

var _instanceOf = require("./instanceOf.js");

var _getWindowScrollBarX = _interopRequireDefault(require("./getWindowScrollBarX.js"));

var _getDocumentElement = _interopRequireDefault(require("./getDocumentElement.js"));

var _isScrollParent = _interopRequireDefault(require("./isScrollParent.js"));

var _math = require("../utils/math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0, _math.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0, _math.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = (0, _instanceOf.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0, _instanceOf.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0, _getDocumentElement.default)(offsetParent);
  var rect = (0, _getBoundingClientRect.default)(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0, _getNodeName.default)(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0, _isScrollParent.default)(documentElement)) {
      scroll = (0, _getNodeScroll.default)(offsetParent);
    }

    if ((0, _instanceOf.isHTMLElement)(offsetParent)) {
      offsets = (0, _getBoundingClientRect.default)(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0, _getWindowScrollBarX.default)(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
},{"./getBoundingClientRect.js":"W8bA","./getNodeScroll.js":"Cbix","./getNodeName.js":"B1zX","./instanceOf.js":"wsKO","./getWindowScrollBarX.js":"zwcJ","./getDocumentElement.js":"sJcE","./isScrollParent.js":"j3Hf","../utils/math.js":"FuL6"}],"mxvt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = orderModifiers;

var _enums = require("../enums.js");

// source: https://stackoverflow.com/questions/49875255
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
},{"../enums.js":"XHUo"}],"mGsv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = debounce;

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}
},{}],"JD7L":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = format;

function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}
},{}],"nr2q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateModifiers;

var _format = _interopRequireDefault(require("./format.js"));

var _enums = require("../enums.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];

function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

          break;

        case 'phase':
          if (_enums.modifierPhases.indexOf(modifier.phase) < 0) {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enums.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error((0, _format.default)(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error((0, _format.default)(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
},{"./format.js":"JD7L","../enums.js":"XHUo"}],"AjzX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = uniqueBy;

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
},{}],"pDli":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mergeByName;

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
},{}],"rg1d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPopper = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function () {
    return _detectOverflow.default;
  }
});
exports.popperGenerator = popperGenerator;

var _getCompositeRect = _interopRequireDefault(require("./dom-utils/getCompositeRect.js"));

var _getLayoutRect = _interopRequireDefault(require("./dom-utils/getLayoutRect.js"));

var _listScrollParents = _interopRequireDefault(require("./dom-utils/listScrollParents.js"));

var _getOffsetParent = _interopRequireDefault(require("./dom-utils/getOffsetParent.js"));

var _getComputedStyle2 = _interopRequireDefault(require("./dom-utils/getComputedStyle.js"));

var _orderModifiers = _interopRequireDefault(require("./utils/orderModifiers.js"));

var _debounce = _interopRequireDefault(require("./utils/debounce.js"));

var _validateModifiers = _interopRequireDefault(require("./utils/validateModifiers.js"));

var _uniqueBy = _interopRequireDefault(require("./utils/uniqueBy.js"));

var _getBasePlacement = _interopRequireDefault(require("./utils/getBasePlacement.js"));

var _mergeByName = _interopRequireDefault(require("./utils/mergeByName.js"));

var _detectOverflow = _interopRequireDefault(require("./utils/detectOverflow.js"));

var _instanceOf = require("./dom-utils/instanceOf.js");

var _enums = require("./enums.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0, _instanceOf.isElement)(reference) ? (0, _listScrollParents.default)(reference) : reference.contextElement ? (0, _listScrollParents.default)(reference.contextElement) : [],
          popper: (0, _listScrollParents.default)(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0, _orderModifiers.default)((0, _mergeByName.default)([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if ("production" !== "production") {
          var modifiers = (0, _uniqueBy.default)([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          (0, _validateModifiers.default)(modifiers);

          if ((0, _getBasePlacement.default)(state.options.placement) === _enums.auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = (0, _getComputedStyle2.default)(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if ("production" !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0, _getCompositeRect.default)(reference, (0, _getOffsetParent.default)(popper), state.options.strategy === 'fixed'),
          popper: (0, _getLayoutRect.default)(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if ("production" !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0, _debounce.default)(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if ("production" !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules

exports.createPopper = createPopper;
},{"./dom-utils/getCompositeRect.js":"FCaM","./dom-utils/getLayoutRect.js":"wDsK","./dom-utils/listScrollParents.js":"m3DJ","./dom-utils/getOffsetParent.js":"CUhI","./dom-utils/getComputedStyle.js":"S6rb","./utils/orderModifiers.js":"mxvt","./utils/debounce.js":"mGsv","./utils/validateModifiers.js":"nr2q","./utils/uniqueBy.js":"AjzX","./utils/getBasePlacement.js":"QS9h","./utils/mergeByName.js":"pDli","./utils/detectOverflow.js":"Moke","./dom-utils/instanceOf.js":"wsKO","./enums.js":"XHUo"}],"hwU4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultModifiers = exports.createPopper = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function () {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function () {
    return _createPopper.popperGenerator;
  }
});

var _createPopper = require("./createPopper.js");

var _eventListeners = _interopRequireDefault(require("./modifiers/eventListeners.js"));

var _popperOffsets = _interopRequireDefault(require("./modifiers/popperOffsets.js"));

var _computeStyles = _interopRequireDefault(require("./modifiers/computeStyles.js"));

var _applyStyles = _interopRequireDefault(require("./modifiers/applyStyles.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultModifiers = [_eventListeners.default, _popperOffsets.default, _computeStyles.default, _applyStyles.default];
exports.defaultModifiers = defaultModifiers;
var createPopper = /*#__PURE__*/(0, _createPopper.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

exports.createPopper = createPopper;
},{"./createPopper.js":"rg1d","./modifiers/eventListeners.js":"psGJ","./modifiers/popperOffsets.js":"Pf8x","./modifiers/computeStyles.js":"ebtt","./modifiers/applyStyles.js":"D2nT"}],"cujj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createPopper: true,
  defaultModifiers: true,
  popperGenerator: true,
  detectOverflow: true,
  createPopperLite: true
};
exports.createPopper = void 0;
Object.defineProperty(exports, "createPopperLite", {
  enumerable: true,
  get: function () {
    return _popperLite.createPopper;
  }
});
exports.defaultModifiers = void 0;
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function () {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function () {
    return _createPopper.popperGenerator;
  }
});

var _createPopper = require("./createPopper.js");

var _eventListeners = _interopRequireDefault(require("./modifiers/eventListeners.js"));

var _popperOffsets = _interopRequireDefault(require("./modifiers/popperOffsets.js"));

var _computeStyles = _interopRequireDefault(require("./modifiers/computeStyles.js"));

var _applyStyles = _interopRequireDefault(require("./modifiers/applyStyles.js"));

var _offset = _interopRequireDefault(require("./modifiers/offset.js"));

var _flip = _interopRequireDefault(require("./modifiers/flip.js"));

var _preventOverflow = _interopRequireDefault(require("./modifiers/preventOverflow.js"));

var _arrow = _interopRequireDefault(require("./modifiers/arrow.js"));

var _hide = _interopRequireDefault(require("./modifiers/hide.js"));

var _popperLite = require("./popper-lite.js");

var _index = require("./modifiers/index.js");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultModifiers = [_eventListeners.default, _popperOffsets.default, _computeStyles.default, _applyStyles.default, _offset.default, _flip.default, _preventOverflow.default, _arrow.default, _hide.default];
exports.defaultModifiers = defaultModifiers;
var createPopper = /*#__PURE__*/(0, _createPopper.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

exports.createPopper = createPopper;
},{"./createPopper.js":"rg1d","./modifiers/eventListeners.js":"psGJ","./modifiers/popperOffsets.js":"Pf8x","./modifiers/computeStyles.js":"ebtt","./modifiers/applyStyles.js":"D2nT","./modifiers/offset.js":"aUNc","./modifiers/flip.js":"rNoN","./modifiers/preventOverflow.js":"RwXk","./modifiers/arrow.js":"zJlD","./modifiers/hide.js":"jhaw","./popper-lite.js":"hwU4","./modifiers/index.js":"TOq4"}],"vePw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  popperGenerator: true,
  detectOverflow: true,
  createPopperBase: true,
  createPopper: true,
  createPopperLite: true
};
Object.defineProperty(exports, "createPopper", {
  enumerable: true,
  get: function () {
    return _popper.createPopper;
  }
});
Object.defineProperty(exports, "createPopperBase", {
  enumerable: true,
  get: function () {
    return _createPopper.createPopper;
  }
});
Object.defineProperty(exports, "createPopperLite", {
  enumerable: true,
  get: function () {
    return _popperLite.createPopper;
  }
});
Object.defineProperty(exports, "detectOverflow", {
  enumerable: true,
  get: function () {
    return _createPopper.detectOverflow;
  }
});
Object.defineProperty(exports, "popperGenerator", {
  enumerable: true,
  get: function () {
    return _createPopper.popperGenerator;
  }
});

var _enums = require("./enums.js");

Object.keys(_enums).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _enums[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _enums[key];
    }
  });
});

var _index = require("./modifiers/index.js");

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _index[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _index[key];
    }
  });
});

var _createPopper = require("./createPopper.js");

var _popper = require("./popper.js");

var _popperLite = require("./popper-lite.js");
},{"./enums.js":"XHUo","./modifiers/index.js":"TOq4","./createPopper.js":"rg1d","./popper.js":"cujj","./popper-lite.js":"hwU4"}],"xqrD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tooltip = exports.Toast = exports.Tab = exports.ScrollSpy = exports.Popover = exports.Offcanvas = exports.Modal = exports.Dropdown = exports.Collapse = exports.Carousel = exports.Button = exports.Alert = void 0;

var Popper = _interopRequireWildcard(require("@popperjs/core"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*!
  * Bootstrap v5.2.0 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const MAX_UID = 1000000;
const MILLISECONDS_MULTIPLIER = 1000;
const TRANSITION_END = 'transitionend'; // Shout-out Angus Croll (https://goo.gl/pxwQGp)

const toType = object => {
  if (object === null || object === undefined) {
    return `${object}`;
  }

  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
/**
 * Public Util API
 */


const getUID = prefix => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));

  return prefix;
};

const getSelector = element => {
  let selector = element.getAttribute('data-bs-target');

  if (!selector || selector === '#') {
    let hrefAttribute = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
    // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
    // `document.querySelector` will rightfully complain it is invalid.
    // See https://github.com/twbs/bootstrap/issues/32273

    if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
      return null;
    } // Just in case some CMS puts out a full URL with the anchor appended


    if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
      hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
    }

    selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
  }

  return selector;
};

const getSelectorFromElement = element => {
  const selector = getSelector(element);

  if (selector) {
    return document.querySelector(selector) ? selector : null;
  }

  return null;
};

const getElementFromSelector = element => {
  const selector = getSelector(element);
  return selector ? document.querySelector(selector) : null;
};

const getTransitionDurationFromElement = element => {
  if (!element) {
    return 0;
  } // Get transition-duration of the element


  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  } // If multiple durations are defined, take the first


  transitionDuration = transitionDuration.split(',')[0];
  transitionDelay = transitionDelay.split(',')[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};

const triggerTransitionEnd = element => {
  element.dispatchEvent(new Event(TRANSITION_END));
};

const isElement = object => {
  if (!object || typeof object !== 'object') {
    return false;
  }

  if (typeof object.jquery !== 'undefined') {
    object = object[0];
  }

  return typeof object.nodeType !== 'undefined';
};

const getElement = object => {
  // it's a jQuery object or a node element
  if (isElement(object)) {
    return object.jquery ? object[0] : object;
  }

  if (typeof object === 'string' && object.length > 0) {
    return document.querySelector(object);
  }

  return null;
};

const isVisible = element => {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }

  const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible'; // Handle `details` element as its content may falsie appear visible when it is closed

  const closedDetails = element.closest('details:not([open])');

  if (!closedDetails) {
    return elementIsVisible;
  }

  if (closedDetails !== element) {
    const summary = element.closest('summary');

    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }

    if (summary === null) {
      return false;
    }
  }

  return elementIsVisible;
};

const isDisabled = element => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }

  if (element.classList.contains('disabled')) {
    return true;
  }

  if (typeof element.disabled !== 'undefined') {
    return element.disabled;
  }

  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
};

const findShadowRoot = element => {
  if (!document.documentElement.attachShadow) {
    return null;
  } // Can find the shadow root otherwise it'll return the document


  if (typeof element.getRootNode === 'function') {
    const root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }

  if (element instanceof ShadowRoot) {
    return element;
  } // when we don't find a shadow root


  if (!element.parentNode) {
    return null;
  }

  return findShadowRoot(element.parentNode);
};

const noop = () => {};
/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */


const reflow = element => {
  element.offsetHeight; // eslint-disable-line no-unused-expressions
};

const getjQuery = () => {
  if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
    return window.jQuery;
  }

  return null;
};

const DOMContentLoadedCallbacks = [];

const onDOMContentLoaded = callback => {
  if (document.readyState === 'loading') {
    // add listener on the first call when the document is in loading state
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener('DOMContentLoaded', () => {
        for (const callback of DOMContentLoadedCallbacks) {
          callback();
        }
      });
    }

    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};

const isRTL = () => document.documentElement.dir === 'rtl';

const defineJQueryPlugin = plugin => {
  onDOMContentLoaded(() => {
    const $ = getjQuery();
    /* istanbul ignore if */

    if ($) {
      const name = plugin.NAME;
      const JQUERY_NO_CONFLICT = $.fn[name];
      $.fn[name] = plugin.jQueryInterface;
      $.fn[name].Constructor = plugin;

      $.fn[name].noConflict = () => {
        $.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};

const execute = callback => {
  if (typeof callback === 'function') {
    callback();
  }
};

const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }

  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;

  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }

    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };

  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */


const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
  const listLength = list.length;
  let index = list.indexOf(activeElement); // if the element does not exist in the list return an element
  // depending on the direction and if cycle is allowed

  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
  }

  index += shouldGetNext ? 1 : -1;

  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }

  return list[Math.max(0, Math.min(index, listLength - 1))];
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): dom/event-handler.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {}; // Events storage

let uidEvent = 1;
const customEvents = {
  mouseenter: 'mouseover',
  mouseleave: 'mouseout'
};
const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);
/**
 * Private methods
 */

function makeEventUid(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}

function getElementEvents(element) {
  const uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}

function bootstrapHandler(element, fn) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });

    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn);
    }

    return fn.apply(element, [event]);
  };
}

function bootstrapDelegationHandler(element, selector, fn) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);

    for (let {
      target
    } = event; target && target !== this; target = target.parentNode) {
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue;
        }

        hydrateObj(event, {
          delegateTarget: target
        });

        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn);
        }

        return fn.apply(target, [event]);
      }
    }
  };
}

function findHandler(events, callable, delegationSelector = null) {
  return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);
}

function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  const isDelegated = typeof handler === 'string'; // todo: tooltip passes `false` instead of selector, so we need to check

  const callable = isDelegated ? delegationFunction : handler || delegationFunction;
  let typeEvent = getTypeEvent(originalTypeEvent);

  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }

  return [isDelegated, callable, typeEvent];
}

function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== 'string' || !element) {
    return;
  }

  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction); // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
  // this prevents the handler from being dispatched the same way as mouseover or mouseout does

  if (originalTypeEvent in customEvents) {
    const wrapFunction = fn => {
      return function (event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn.call(this, event);
        }
      };
    };

    callable = wrapFunction(callable);
  }

  const events = getElementEvents(element);
  const handlers = events[typeEvent] || (events[typeEvent] = {});
  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);

  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }

  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
  const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn.delegationSelector = isDelegated ? handler : null;
  fn.callable = callable;
  fn.oneOff = oneOff;
  fn.uidEvent = uid;
  handlers[uid] = fn;
  element.addEventListener(typeEvent, fn, isDelegated);
}

function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  const fn = findHandler(events[typeEvent], handler, delegationSelector);

  if (!fn) {
    return;
  }

  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
  delete events[typeEvent][fn.uidEvent];
}

function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};

  for (const handlerKey of Object.keys(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      const event = storeElementEvent[handlerKey];
      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
    }
  }
}

function getTypeEvent(event) {
  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
  event = event.replace(stripNameRegex, '');
  return customEvents[event] || event;
}

const EventHandler = {
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },

  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },

  off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }

    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getElementEvents(element);
    const storeElementEvent = events[typeEvent] || {};
    const isNamespace = originalTypeEvent.startsWith('.');

    if (typeof callable !== 'undefined') {
      // Simplest case: handler is passed, remove that listener ONLY.
      if (!Object.keys(storeElementEvent).length) {
        return;
      }

      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
      return;
    }

    if (isNamespace) {
      for (const elementEvent of Object.keys(events)) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      }
    }

    for (const keyHandlers of Object.keys(storeElementEvent)) {
      const handlerKey = keyHandlers.replace(stripUidRegex, '');

      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        const event = storeElementEvent[keyHandlers];
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },

  trigger(element, event, args) {
    if (typeof event !== 'string' || !element) {
      return null;
    }

    const $ = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    let jQueryEvent = null;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;

    if (inNamespace && $) {
      jQueryEvent = $.Event(event, args);
      $(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }

    let evt = new Event(event, {
      bubbles,
      cancelable: true
    });
    evt = hydrateObj(evt, args);

    if (defaultPrevented) {
      evt.preventDefault();
    }

    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }

    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }

    return evt;
  }

};

function hydrateObj(obj, meta) {
  for (const [key, value] of Object.entries(meta || {})) {
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,

        get() {
          return value;
        }

      });
    }
  }

  return obj;
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const elementMap = new Map();
const Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, new Map());
    }

    const instanceMap = elementMap.get(element); // make it clear we only want one instance per element
    // can be removed later when multiple key/instances are fine to be used

    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      // eslint-disable-next-line no-console
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }

    instanceMap.set(key, instance);
  },

  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }

    return null;
  },

  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }

    const instanceMap = elementMap.get(element);
    instanceMap.delete(key); // free up element references if there are no instances left for an element

    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }

};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

function normalizeData(value) {
  if (value === 'true') {
    return true;
  }

  if (value === 'false') {
    return false;
  }

  if (value === Number(value).toString()) {
    return Number(value);
  }

  if (value === '' || value === 'null') {
    return null;
  }

  if (typeof value !== 'string') {
    return value;
  }

  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
}

function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
}

const Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },

  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },

  getDataAttributes(element) {
    if (!element) {
      return {};
    }

    const attributes = {};
    const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));

    for (const key of bsKeys) {
      let pureKey = key.replace(/^bs/, '');
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    }

    return attributes;
  },

  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  }

};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/config.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Class definition
 */

class Config {
  // Getters
  static get Default() {
    return {};
  }

  static get DefaultType() {
    return {};
  }

  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }

  _getConfig(config) {
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);

    this._typeCheckConfig(config);

    return config;
  }

  _configAfterMerge(config) {
    return config;
  }

  _mergeConfigObj(config, element) {
    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse

    return { ...this.constructor.Default,
      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),
      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),
      ...(typeof config === 'object' ? config : {})
    };
  }

  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
    for (const property of Object.keys(configTypes)) {
      const expectedTypes = configTypes[property];
      const value = config[property];
      const valueType = isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    }
  }

}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): base-component.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const VERSION = '5.2.0';
/**
 * Class definition
 */

class BaseComponent extends Config {
  constructor(element, config) {
    super();
    element = getElement(element);

    if (!element) {
      return;
    }

    this._element = element;
    this._config = this._getConfig(config);
    Data.set(this._element, this.constructor.DATA_KEY, this);
  } // Public


  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);

    for (const propertyName of Object.getOwnPropertyNames(this)) {
      this[propertyName] = null;
    }
  }

  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }

  _getConfig(config) {
    config = this._mergeConfigObj(config, this._element);
    config = this._configAfterMerge(config);

    this._typeCheckConfig(config);

    return config;
  } // Static


  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }

  static getOrCreateInstance(element, config = {}) {
    return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
  }

  static get VERSION() {
    return VERSION;
  }

  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }

  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }

  static eventName(name) {
    return `${name}${this.EVENT_KEY}`;
  }

}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


const enableDismissTrigger = (component, method = 'hide') => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if (isDisabled(this)) {
      return;
    }

    const target = getElementFromSelector(this) || this.closest(`.${name}`);
    const instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

    instance[method]();
  });
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const NAME$f = 'alert';
const DATA_KEY$a = 'bs.alert';
const EVENT_KEY$b = `.${DATA_KEY$a}`;
const EVENT_CLOSE = `close${EVENT_KEY$b}`;
const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
const CLASS_NAME_FADE$5 = 'fade';
const CLASS_NAME_SHOW$8 = 'show';
/**
 * Class definition
 */

class Alert extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$f;
  } // Public


  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);

    if (closeEvent.defaultPrevented) {
      return;
    }

    this._element.classList.remove(CLASS_NAME_SHOW$8);

    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);

    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  } // Private


  _destroyElement() {
    this._element.remove();

    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Alert.getOrCreateInstance(this);

      if (typeof config !== 'string') {
        return;
      }

      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config](this);
    });
  }

}
/**
 * Data API implementation
 */


exports.Alert = Alert;
enableDismissTrigger(Alert, 'close');
/**
 * jQuery
 */

defineJQueryPlugin(Alert);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$e = 'button';
const DATA_KEY$9 = 'bs.button';
const EVENT_KEY$a = `.${DATA_KEY$9}`;
const DATA_API_KEY$6 = '.data-api';
const CLASS_NAME_ACTIVE$3 = 'active';
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
/**
 * Class definition
 */

class Button extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$e;
  } // Public


  toggle() {
    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Button.getOrCreateInstance(this);

      if (config === 'toggle') {
        data[config]();
      }
    });
  }

}
/**
 * Data API implementation
 */


exports.Button = Button;
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data = Button.getOrCreateInstance(button);
  data.toggle();
});
/**
 * jQuery
 */

defineJQueryPlugin(Button);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): dom/selector-engine.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },

  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },

  children(element, selector) {
    return [].concat(...element.children).filter(child => child.matches(selector));
  },

  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode.closest(selector);

    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }

    return parents;
  },

  prev(element, selector) {
    let previous = element.previousElementSibling;

    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }

      previous = previous.previousElementSibling;
    }

    return [];
  },

  // TODO: this is now unused; remove later along with prev()
  next(element, selector) {
    let next = element.nextElementSibling;

    while (next) {
      if (next.matches(selector)) {
        return [next];
      }

      next = next.nextElementSibling;
    }

    return [];
  },

  focusableChildren(element) {
    const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(',');
    return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
  }

};
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/swipe.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$d = 'swipe';
const EVENT_KEY$9 = '.bs.swipe';
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
const POINTER_TYPE_TOUCH = 'touch';
const POINTER_TYPE_PEN = 'pen';
const CLASS_NAME_POINTER_EVENT = 'pointer-event';
const SWIPE_THRESHOLD = 40;
const Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
const DefaultType$c = {
  endCallback: '(function|null)',
  leftCallback: '(function|null)',
  rightCallback: '(function|null)'
};
/**
 * Class definition
 */

class Swipe extends Config {
  constructor(element, config) {
    super();
    this._element = element;

    if (!element || !Swipe.isSupported()) {
      return;
    }

    this._config = this._getConfig(config);
    this._deltaX = 0;
    this._supportPointerEvents = Boolean(window.PointerEvent);

    this._initEvents();
  } // Getters


  static get Default() {
    return Default$c;
  }

  static get DefaultType() {
    return DefaultType$c;
  }

  static get NAME() {
    return NAME$d;
  } // Public


  dispose() {
    EventHandler.off(this._element, EVENT_KEY$9);
  } // Private


  _start(event) {
    if (!this._supportPointerEvents) {
      this._deltaX = event.touches[0].clientX;
      return;
    }

    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX;
    }
  }

  _end(event) {
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX - this._deltaX;
    }

    this._handleSwipe();

    execute(this._config.endCallback);
  }

  _move(event) {
    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
  }

  _handleSwipe() {
    const absDeltaX = Math.abs(this._deltaX);

    if (absDeltaX <= SWIPE_THRESHOLD) {
      return;
    }

    const direction = absDeltaX / this._deltaX;
    this._deltaX = 0;

    if (!direction) {
      return;
    }

    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
  }

  _initEvents() {
    if (this._supportPointerEvents) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));

      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));
    }
  }

  _eventIsPointerPenTouch(event) {
    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
  } // Static


  static isSupported() {
    return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
  }

}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const NAME$c = 'carousel';
const DATA_KEY$8 = 'bs.carousel';
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$5 = '.data-api';
const ARROW_LEFT_KEY$1 = 'ArrowLeft';
const ARROW_RIGHT_KEY$1 = 'ArrowRight';
const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

const ORDER_NEXT = 'next';
const ORDER_PREV = 'prev';
const DIRECTION_LEFT = 'left';
const DIRECTION_RIGHT = 'right';
const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
const EVENT_SLID = `slid${EVENT_KEY$8}`;
const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
const CLASS_NAME_CAROUSEL = 'carousel';
const CLASS_NAME_ACTIVE$2 = 'active';
const CLASS_NAME_SLIDE = 'slide';
const CLASS_NAME_END = 'carousel-item-end';
const CLASS_NAME_START = 'carousel-item-start';
const CLASS_NAME_NEXT = 'carousel-item-next';
const CLASS_NAME_PREV = 'carousel-item-prev';
const SELECTOR_ACTIVE = '.active';
const SELECTOR_ITEM = '.carousel-item';
const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
const SELECTOR_ITEM_IMG = '.carousel-item img';
const SELECTOR_INDICATORS = '.carousel-indicators';
const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
const Default$b = {
  interval: 5000,
  keyboard: true,
  pause: 'hover',
  ride: false,
  touch: true,
  wrap: true
};
const DefaultType$b = {
  interval: '(number|boolean)',
  // TODO:v6 remove boolean support
  keyboard: 'boolean',
  pause: '(string|boolean)',
  ride: '(boolean|string)',
  touch: 'boolean',
  wrap: 'boolean'
};
/**
 * Class definition
 */

class Carousel extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._interval = null;
    this._activeElement = null;
    this._isSliding = false;
    this.touchTimeout = null;
    this._swipeHelper = null;
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);

    this._addEventListeners();

    if (this._config.ride === CLASS_NAME_CAROUSEL) {
      this.cycle();
    }
  } // Getters


  static get Default() {
    return Default$b;
  }

  static get DefaultType() {
    return DefaultType$b;
  }

  static get NAME() {
    return NAME$c;
  } // Public


  next() {
    this._slide(ORDER_NEXT);
  }

  nextWhenVisible() {
    // FIXME TODO use `document.visibilityState`
    // Don't call next when the page isn't visible
    // or the carousel or its parent isn't visible
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }

  prev() {
    this._slide(ORDER_PREV);
  }

  pause() {
    if (this._isSliding) {
      triggerTransitionEnd(this._element);
    }

    this._clearInterval();
  }

  cycle() {
    this._clearInterval();

    this._updateInterval();

    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }

  _maybeEnableCycle() {
    if (!this._config.ride) {
      return;
    }

    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
      return;
    }

    this.cycle();
  }

  to(index) {
    const items = this._getItems();

    if (index > items.length - 1 || index < 0) {
      return;
    }

    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }

    const activeIndex = this._getItemIndex(this._getActive());

    if (activeIndex === index) {
      return;
    }

    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;

    this._slide(order, items[index]);
  }

  dispose() {
    if (this._swipeHelper) {
      this._swipeHelper.dispose();
    }

    super.dispose();
  } // Private


  _configAfterMerge(config) {
    config.defaultInterval = config.interval;
    return config;
  }

  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));
    }

    if (this._config.pause === 'hover') {
      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
    }

    if (this._config.touch && Swipe.isSupported()) {
      this._addTouchEventListeners();
    }
  }

  _addTouchEventListeners() {
    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
      EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());
    }

    const endCallBack = () => {
      if (this._config.pause !== 'hover') {
        return;
      } // If it's a touch-enabled device, mouseenter/leave are fired as
      // part of the mouse compatibility events on first tap - the carousel
      // would stop cycling until user tapped out of it;
      // here, we listen for touchend, explicitly pause the carousel
      // (as if it's the second time we tap on it, mouseenter compat event
      // is NOT fired) and after a timeout (to allow for mouse compatibility
      // events to fire) we explicitly restart cycling


      this.pause();

      if (this.touchTimeout) {
        clearTimeout(this.touchTimeout);
      }

      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
    };

    const swipeConfig = {
      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
      endCallback: endCallBack
    };
    this._swipeHelper = new Swipe(this._element, swipeConfig);
  }

  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }

    const direction = KEY_TO_DIRECTION[event.key];

    if (direction) {
      event.preventDefault();

      this._slide(this._directionToOrder(direction));
    }
  }

  _getItemIndex(element) {
    return this._getItems().indexOf(element);
  }

  _setActiveIndicatorElement(index) {
    if (!this._indicatorsElement) {
      return;
    }

    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
    activeIndicator.removeAttribute('aria-current');
    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);

    if (newActiveIndicator) {
      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
      newActiveIndicator.setAttribute('aria-current', 'true');
    }
  }

  _updateInterval() {
    const element = this._activeElement || this._getActive();

    if (!element) {
      return;
    }

    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
    this._config.interval = elementInterval || this._config.defaultInterval;
  }

  _slide(order, element = null) {
    if (this._isSliding) {
      return;
    }

    const activeElement = this._getActive();

    const isNext = order === ORDER_NEXT;
    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);

    if (nextElement === activeElement) {
      return;
    }

    const nextElementIndex = this._getItemIndex(nextElement);

    const triggerEvent = eventName => {
      return EventHandler.trigger(this._element, eventName, {
        relatedTarget: nextElement,
        direction: this._orderToDirection(order),
        from: this._getItemIndex(activeElement),
        to: nextElementIndex
      });
    };

    const slideEvent = triggerEvent(EVENT_SLIDE);

    if (slideEvent.defaultPrevented) {
      return;
    }

    if (!activeElement || !nextElement) {
      // Some weirdness is happening, so we bail
      // todo: change tests that use empty divs to avoid this check
      return;
    }

    const isCycling = Boolean(this._interval);
    this.pause();
    this._isSliding = true;

    this._setActiveIndicatorElement(nextElementIndex);

    this._activeElement = nextElement;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
    nextElement.classList.add(orderClassName);
    reflow(nextElement);
    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);

    const completeCallBack = () => {
      nextElement.classList.remove(directionalClassName, orderClassName);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
      this._isSliding = false;
      triggerEvent(EVENT_SLID);
    };

    this._queueCallback(completeCallBack, activeElement, this._isAnimated());

    if (isCycling) {
      this.cycle();
    }
  }

  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_SLIDE);
  }

  _getActive() {
    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
  }

  _getItems() {
    return SelectorEngine.find(SELECTOR_ITEM, this._element);
  }

  _clearInterval() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }

  _directionToOrder(direction) {
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }

    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }

  _orderToDirection(order) {
    if (isRTL()) {
      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }

    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Carousel.getOrCreateInstance(this, config);

      if (typeof config === 'number') {
        data.to(config);
        return;
      }

      if (typeof config === 'string') {
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config]();
      }
    });
  }

}
/**
 * Data API implementation
 */


exports.Carousel = Carousel;
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {
  const target = getElementFromSelector(this);

  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }

  event.preventDefault();
  const carousel = Carousel.getOrCreateInstance(target);
  const slideIndex = this.getAttribute('data-bs-slide-to');

  if (slideIndex) {
    carousel.to(slideIndex);

    carousel._maybeEnableCycle();

    return;
  }

  if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
    carousel.next();

    carousel._maybeEnableCycle();

    return;
  }

  carousel.prev();

  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);

  for (const carousel of carousels) {
    Carousel.getOrCreateInstance(carousel);
  }
});
/**
 * jQuery
 */

defineJQueryPlugin(Carousel);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$b = 'collapse';
const DATA_KEY$7 = 'bs.collapse';
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const DATA_API_KEY$4 = '.data-api';
const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$7 = 'show';
const CLASS_NAME_COLLAPSE = 'collapse';
const CLASS_NAME_COLLAPSING = 'collapsing';
const CLASS_NAME_COLLAPSED = 'collapsed';
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
const WIDTH = 'width';
const HEIGHT = 'height';
const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
const Default$a = {
  parent: null,
  toggle: true
};
const DefaultType$a = {
  parent: '(null|element)',
  toggle: 'boolean'
};
/**
 * Class definition
 */

class Collapse extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isTransitioning = false;
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);

    for (const elem of toggleList) {
      const selector = getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);

      if (selector !== null && filterElement.length) {
        this._triggerArray.push(elem);
      }
    }

    this._initializeChildren();

    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }

    if (this._config.toggle) {
      this.toggle();
    }
  } // Getters


  static get Default() {
    return Default$a;
  }

  static get DefaultType() {
    return DefaultType$a;
  }

  static get NAME() {
    return NAME$b;
  } // Public


  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }

  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }

    let activeChildren = []; // find active children

    if (this._config.parent) {
      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {
        toggle: false
      }));
    }

    if (activeChildren.length && activeChildren[0]._isTransitioning) {
      return;
    }

    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);

    if (startEvent.defaultPrevented) {
      return;
    }

    for (const activeInstance of activeChildren) {
      activeInstance.hide();
    }

    const dimension = this._getDimension();

    this._element.classList.remove(CLASS_NAME_COLLAPSE);

    this._element.classList.add(CLASS_NAME_COLLAPSING);

    this._element.style[dimension] = 0;

    this._addAriaAndCollapsedClass(this._triggerArray, true);

    this._isTransitioning = true;

    const complete = () => {
      this._isTransitioning = false;

      this._element.classList.remove(CLASS_NAME_COLLAPSING);

      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);

      this._element.style[dimension] = '';
      EventHandler.trigger(this._element, EVENT_SHOWN$6);
    };

    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;

    this._queueCallback(complete, this._element, true);

    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }

  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }

    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);

    if (startEvent.defaultPrevented) {
      return;
    }

    const dimension = this._getDimension();

    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);

    this._element.classList.add(CLASS_NAME_COLLAPSING);

    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);

    for (const trigger of this._triggerArray) {
      const element = getElementFromSelector(trigger);

      if (element && !this._isShown(element)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }

    this._isTransitioning = true;

    const complete = () => {
      this._isTransitioning = false;

      this._element.classList.remove(CLASS_NAME_COLLAPSING);

      this._element.classList.add(CLASS_NAME_COLLAPSE);

      EventHandler.trigger(this._element, EVENT_HIDDEN$6);
    };

    this._element.style[dimension] = '';

    this._queueCallback(complete, this._element, true);
  }

  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  } // Private


  _configAfterMerge(config) {
    config.toggle = Boolean(config.toggle); // Coerce string values

    config.parent = getElement(config.parent);
    return config;
  }

  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }

  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }

    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);

    for (const element of children) {
      const selected = getElementFromSelector(element);

      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    }
  }

  _getFirstLevelChildren(selector) {
    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent); // remove children if greater depth

    return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));
  }

  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }

    for (const element of triggerArray) {
      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
      element.setAttribute('aria-expanded', isOpen);
    }
  } // Static


  static jQueryInterface(config) {
    const _config = {};

    if (typeof config === 'string' && /show|hide/.test(config)) {
      _config.toggle = false;
    }

    return this.each(function () {
      const data = Collapse.getOrCreateInstance(this, _config);

      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config]();
      }
    });
  }

}
/**
 * Data API implementation
 */


exports.Collapse = Collapse;
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
    event.preventDefault();
  }

  const selector = getSelectorFromElement(this);
  const selectorElements = SelectorEngine.find(selector);

  for (const element of selectorElements) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  }
});
/**
 * jQuery
 */

defineJQueryPlugin(Collapse);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$a = 'dropdown';
const DATA_KEY$6 = 'bs.dropdown';
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = '.data-api';
const ESCAPE_KEY$2 = 'Escape';
const TAB_KEY$1 = 'Tab';
const ARROW_UP_KEY$1 = 'ArrowUp';
const ARROW_DOWN_KEY$1 = 'ArrowDown';
const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_SHOW$6 = 'show';
const CLASS_NAME_DROPUP = 'dropup';
const CLASS_NAME_DROPEND = 'dropend';
const CLASS_NAME_DROPSTART = 'dropstart';
const CLASS_NAME_DROPUP_CENTER = 'dropup-center';
const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
const SELECTOR_MENU = '.dropdown-menu';
const SELECTOR_NAVBAR = '.navbar';
const SELECTOR_NAVBAR_NAV = '.navbar-nav';
const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
const PLACEMENT_TOPCENTER = 'top';
const PLACEMENT_BOTTOMCENTER = 'bottom';
const Default$9 = {
  autoClose: true,
  boundary: 'clippingParents',
  display: 'dynamic',
  offset: [0, 2],
  popperConfig: null,
  reference: 'toggle'
};
const DefaultType$9 = {
  autoClose: '(boolean|string)',
  boundary: '(string|element)',
  display: 'string',
  offset: '(array|string|function)',
  popperConfig: '(null|object|function)',
  reference: '(string|element|object)'
};
/**
 * Class definition
 */

class Dropdown extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._popper = null;
    this._parent = this._element.parentNode; // dropdown wrapper

    this._menu = SelectorEngine.findOne(SELECTOR_MENU, this._parent);
    this._inNavbar = this._detectNavbar();
  } // Getters


  static get Default() {
    return Default$9;
  }

  static get DefaultType() {
    return DefaultType$9;
  }

  static get NAME() {
    return NAME$a;
  } // Public


  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }

  show() {
    if (isDisabled(this._element) || this._isShown()) {
      return;
    }

    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);

    if (showEvent.defaultPrevented) {
      return;
    }

    this._createPopper(); // If this is a touch-enabled device we add extra
    // empty mouseover listeners to the body's immediate children;
    // only needed because of broken event delegation on iOS
    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


    if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, 'mouseover', noop);
      }
    }

    this._element.focus();

    this._element.setAttribute('aria-expanded', true);

    this._menu.classList.add(CLASS_NAME_SHOW$6);

    this._element.classList.add(CLASS_NAME_SHOW$6);

    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
  }

  hide() {
    if (isDisabled(this._element) || !this._isShown()) {
      return;
    }

    const relatedTarget = {
      relatedTarget: this._element
    };

    this._completeHide(relatedTarget);
  }

  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }

    super.dispose();
  }

  update() {
    this._inNavbar = this._detectNavbar();

    if (this._popper) {
      this._popper.update();
    }
  } // Private


  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);

    if (hideEvent.defaultPrevented) {
      return;
    } // If this is a touch-enabled device we remove the extra
    // empty mouseover listeners we added for iOS support


    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, 'mouseover', noop);
      }
    }

    if (this._popper) {
      this._popper.destroy();
    }

    this._menu.classList.remove(CLASS_NAME_SHOW$6);

    this._element.classList.remove(CLASS_NAME_SHOW$6);

    this._element.setAttribute('aria-expanded', 'false');

    Manipulator.removeDataAttribute(this._menu, 'popper');
    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
  }

  _getConfig(config) {
    config = super._getConfig(config);

    if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
      // Popper virtual elements require a getBoundingClientRect method
      throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }

    return config;
  }

  _createPopper() {
    if (typeof Popper === 'undefined') {
      throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
    }

    let referenceElement = this._element;

    if (this._config.reference === 'parent') {
      referenceElement = this._parent;
    } else if (isElement(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === 'object') {
      referenceElement = this._config.reference;
    }

    const popperConfig = this._getPopperConfig();

    this._popper = Popper.createPopper(referenceElement, this._menu, popperConfig);
  }

  _isShown() {
    return this._menu.classList.contains(CLASS_NAME_SHOW$6);
  }

  _getPlacement() {
    const parentDropdown = this._parent;

    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }

    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    }

    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
      return PLACEMENT_TOPCENTER;
    }

    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
      return PLACEMENT_BOTTOMCENTER;
    } // We need to trim the value because custom properties can also include spaces


    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';

    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }

    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }

  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }

  _getOffset() {
    const {
      offset
    } = this._config;

    if (typeof offset === 'string') {
      return offset.split(',').map(value => Number.parseInt(value, 10));
    }

    if (typeof offset === 'function') {
      return popperData => offset(popperData, this._element);
    }

    return offset;
  }

  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: 'preventOverflow',
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: 'offset',
        options: {
          offset: this._getOffset()
        }
      }]
    }; // Disable Popper if we have a static display or Dropdown is in Navbar

    if (this._inNavbar || this._config.display === 'static') {
      Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // todo:v6 remove

      defaultBsPopperConfig.modifiers = [{
        name: 'applyStyles',
        enabled: false
      }];
    }

    return { ...defaultBsPopperConfig,
      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
    };
  }

  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));

    if (!items.length) {
      return;
    } // if target isn't included in items (e.g. when expanding the dropdown)
    // allow cycling to get the last item in case key equals ARROW_UP_KEY


    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Dropdown.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config]();
    });
  }

  static clearMenus(event) {
    if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {
      return;
    }

    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);

    for (const toggle of openToggles) {
      const context = Dropdown.getInstance(toggle);

      if (!context || context._config.autoClose === false) {
        continue;
      }

      const composedPath = event.composedPath();
      const isMenuTarget = composedPath.includes(context._menu);

      if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
        continue;
      } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu


      if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
        continue;
      }

      const relatedTarget = {
        relatedTarget: context._element
      };

      if (event.type === 'click') {
        relatedTarget.clickEvent = event;
      }

      context._completeHide(relatedTarget);
    }
  }

  static dataApiKeydownHandler(event) {
    // If not an UP | DOWN | ESCAPE key => not a dropdown command
    // If input/textarea && if key is other than ESCAPE => not a dropdown command
    const isInput = /input|textarea/i.test(event.target.tagName);
    const isEscapeEvent = event.key === ESCAPE_KEY$2;
    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);

    if (!isUpOrDownEvent && !isEscapeEvent) {
      return;
    }

    if (isInput && !isEscapeEvent) {
      return;
    }

    event.preventDefault();
    const getToggleButton = SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
    const instance = Dropdown.getOrCreateInstance(getToggleButton);

    if (isUpOrDownEvent) {
      event.stopPropagation();
      instance.show();

      instance._selectMenuItem(event);

      return;
    }

    if (instance._isShown()) {
      // else is escape and we check if it is shown
      event.stopPropagation();
      instance.hide();
      getToggleButton.focus();
    }
  }

}
/**
 * Data API implementation
 */


exports.Dropdown = Dropdown;
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});
/**
 * jQuery
 */

defineJQueryPlugin(Dropdown);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/scrollBar.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
const SELECTOR_STICKY_CONTENT = '.sticky-top';
const PROPERTY_PADDING = 'padding-right';
const PROPERTY_MARGIN = 'margin-right';
/**
 * Class definition
 */

class ScrollBarHelper {
  constructor() {
    this._element = document.body;
  } // Public


  getWidth() {
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }

  hide() {
    const width = this.getWidth();

    this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width


    this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth


    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);

    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);
  }

  reset() {
    this._resetElementAttributes(this._element, 'overflow');

    this._resetElementAttributes(this._element, PROPERTY_PADDING);

    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);

    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
  }

  isOverflowing() {
    return this.getWidth() > 0;
  } // Private


  _disableOverFlow() {
    this._saveInitialAttribute(this._element, 'overflow');

    this._element.style.overflow = 'hidden';
  }

  _setElementAttributes(selector, styleProperty, callback) {
    const scrollbarWidth = this.getWidth();

    const manipulationCallBack = element => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }

      this._saveInitialAttribute(element, styleProperty);

      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
    };

    this._applyManipulationCallback(selector, manipulationCallBack);
  }

  _saveInitialAttribute(element, styleProperty) {
    const actualValue = element.style.getPropertyValue(styleProperty);

    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
  }

  _resetElementAttributes(selector, styleProperty) {
    const manipulationCallBack = element => {
      const value = Manipulator.getDataAttribute(element, styleProperty); // We only want to remove the property if the value is `null`; the value can also be zero

      if (value === null) {
        element.style.removeProperty(styleProperty);
        return;
      }

      Manipulator.removeDataAttribute(element, styleProperty);
      element.style.setProperty(styleProperty, value);
    };

    this._applyManipulationCallback(selector, manipulationCallBack);
  }

  _applyManipulationCallback(selector, callBack) {
    if (isElement(selector)) {
      callBack(selector);
      return;
    }

    for (const sel of SelectorEngine.find(selector, this._element)) {
      callBack(sel);
    }
  }

}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/backdrop.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const NAME$9 = 'backdrop';
const CLASS_NAME_FADE$4 = 'fade';
const CLASS_NAME_SHOW$5 = 'show';
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
const Default$8 = {
  className: 'modal-backdrop',
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: 'body' // give the choice to place backdrop under different elements

};
const DefaultType$8 = {
  className: 'string',
  clickCallback: '(function|null)',
  isAnimated: 'boolean',
  isVisible: 'boolean',
  rootElement: '(element|string)'
};
/**
 * Class definition
 */

class Backdrop extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isAppended = false;
    this._element = null;
  } // Getters


  static get Default() {
    return Default$8;
  }

  static get DefaultType() {
    return DefaultType$8;
  }

  static get NAME() {
    return NAME$9;
  } // Public


  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }

    this._append();

    const element = this._getElement();

    if (this._config.isAnimated) {
      reflow(element);
    }

    element.classList.add(CLASS_NAME_SHOW$5);

    this._emulateAnimation(() => {
      execute(callback);
    });
  }

  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }

    this._getElement().classList.remove(CLASS_NAME_SHOW$5);

    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }

  dispose() {
    if (!this._isAppended) {
      return;
    }

    EventHandler.off(this._element, EVENT_MOUSEDOWN);

    this._element.remove();

    this._isAppended = false;
  } // Private


  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement('div');
      backdrop.className = this._config.className;

      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }

      this._element = backdrop;
    }

    return this._element;
  }

  _configAfterMerge(config) {
    // use getElement() with the default "body" to get a fresh Element on each instantiation
    config.rootElement = getElement(config.rootElement);
    return config;
  }

  _append() {
    if (this._isAppended) {
      return;
    }

    const element = this._getElement();

    this._config.rootElement.append(element);

    EventHandler.on(element, EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }

  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }

}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/focustrap.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const NAME$8 = 'focustrap';
const DATA_KEY$5 = 'bs.focustrap';
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
const TAB_KEY = 'Tab';
const TAB_NAV_FORWARD = 'forward';
const TAB_NAV_BACKWARD = 'backward';
const Default$7 = {
  autofocus: true,
  trapElement: null // The element to trap focus inside of

};
const DefaultType$7 = {
  autofocus: 'boolean',
  trapElement: 'element'
};
/**
 * Class definition
 */

class FocusTrap extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isActive = false;
    this._lastTabNavDirection = null;
  } // Getters


  static get Default() {
    return Default$7;
  }

  static get DefaultType() {
    return DefaultType$7;
  }

  static get NAME() {
    return NAME$8;
  } // Public


  activate() {
    if (this._isActive) {
      return;
    }

    if (this._config.autofocus) {
      this._config.trapElement.focus();
    }

    EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop

    EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
    this._isActive = true;
  }

  deactivate() {
    if (!this._isActive) {
      return;
    }

    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$5);
  } // Private


  _handleFocusin(event) {
    const {
      trapElement
    } = this._config;

    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
      return;
    }

    const elements = SelectorEngine.focusableChildren(trapElement);

    if (elements.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements[elements.length - 1].focus();
    } else {
      elements[0].focus();
    }
  }

  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }

    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }

}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const NAME$7 = 'modal';
const DATA_KEY$4 = 'bs.modal';
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const DATA_API_KEY$2 = '.data-api';
const ESCAPE_KEY$1 = 'Escape';
const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
const CLASS_NAME_OPEN = 'modal-open';
const CLASS_NAME_FADE$3 = 'fade';
const CLASS_NAME_SHOW$4 = 'show';
const CLASS_NAME_STATIC = 'modal-static';
const OPEN_SELECTOR$1 = '.modal.show';
const SELECTOR_DIALOG = '.modal-dialog';
const SELECTOR_MODAL_BODY = '.modal-body';
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
const Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
const DefaultType$6 = {
  backdrop: '(boolean|string)',
  focus: 'boolean',
  keyboard: 'boolean'
};
/**
 * Class definition
 */

class Modal extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper();

    this._addEventListeners();
  } // Getters


  static get Default() {
    return Default$6;
  }

  static get DefaultType() {
    return DefaultType$6;
  }

  static get NAME() {
    return NAME$7;
  } // Public


  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }

  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }

    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
      relatedTarget
    });

    if (showEvent.defaultPrevented) {
      return;
    }

    this._isShown = true;
    this._isTransitioning = true;

    this._scrollBar.hide();

    document.body.classList.add(CLASS_NAME_OPEN);

    this._adjustDialog();

    this._backdrop.show(() => this._showElement(relatedTarget));
  }

  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }

    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);

    if (hideEvent.defaultPrevented) {
      return;
    }

    this._isShown = false;
    this._isTransitioning = true;

    this._focustrap.deactivate();

    this._element.classList.remove(CLASS_NAME_SHOW$4);

    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
  }

  dispose() {
    for (const htmlElement of [window, this._dialog]) {
      EventHandler.off(htmlElement, EVENT_KEY$4);
    }

    this._backdrop.dispose();

    this._focustrap.deactivate();

    super.dispose();
  }

  handleUpdate() {
    this._adjustDialog();
  } // Private


  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }

  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }

  _showElement(relatedTarget) {
    // try to append dynamic modal
    if (!document.body.contains(this._element)) {
      document.body.append(this._element);
    }

    this._element.style.display = 'block';

    this._element.removeAttribute('aria-hidden');

    this._element.setAttribute('aria-modal', true);

    this._element.setAttribute('role', 'dialog');

    this._element.scrollTop = 0;
    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);

    if (modalBody) {
      modalBody.scrollTop = 0;
    }

    reflow(this._element);

    this._element.classList.add(CLASS_NAME_SHOW$4);

    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }

      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$4, {
        relatedTarget
      });
    };

    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
  }

  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
      if (event.key !== ESCAPE_KEY$1) {
        return;
      }

      if (this._config.keyboard) {
        event.preventDefault();
        this.hide();
        return;
      }

      this._triggerBackdropTransition();
    });
    EventHandler.on(window, EVENT_RESIZE$1, () => {
      if (this._isShown && !this._isTransitioning) {
        this._adjustDialog();
      }
    });
    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {
      if (event.target !== event.currentTarget) {
        // click is inside modal-dialog
        return;
      }

      if (this._config.backdrop === 'static') {
        this._triggerBackdropTransition();

        return;
      }

      if (this._config.backdrop) {
        this.hide();
      }
    });
  }

  _hideModal() {
    this._element.style.display = 'none';

    this._element.setAttribute('aria-hidden', true);

    this._element.removeAttribute('aria-modal');

    this._element.removeAttribute('role');

    this._isTransitioning = false;

    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);

      this._resetAdjustments();

      this._scrollBar.reset();

      EventHandler.trigger(this._element, EVENT_HIDDEN$4);
    });
  }

  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }

  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);

    if (hideEvent.defaultPrevented) {
      return;
    }

    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const initialOverflowY = this._element.style.overflowY; // return if the following background transition hasn't yet completed

    if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
      return;
    }

    if (!isModalOverflowing) {
      this._element.style.overflowY = 'hidden';
    }

    this._element.classList.add(CLASS_NAME_STATIC);

    this._queueCallback(() => {
      this._element.classList.remove(CLASS_NAME_STATIC);

      this._queueCallback(() => {
        this._element.style.overflowY = initialOverflowY;
      }, this._dialog);
    }, this._dialog);

    this._element.focus();
  }
  /**
   * The following methods are used to handle overflowing modals
   */


  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

    const scrollbarWidth = this._scrollBar.getWidth();

    const isBodyOverflowing = scrollbarWidth > 0;

    if (isBodyOverflowing && !isModalOverflowing) {
      const property = isRTL() ? 'paddingLeft' : 'paddingRight';
      this._element.style[property] = `${scrollbarWidth}px`;
    }

    if (!isBodyOverflowing && isModalOverflowing) {
      const property = isRTL() ? 'paddingRight' : 'paddingLeft';
      this._element.style[property] = `${scrollbarWidth}px`;
    }
  }

  _resetAdjustments() {
    this._element.style.paddingLeft = '';
    this._element.style.paddingRight = '';
  } // Static


  static jQueryInterface(config, relatedTarget) {
    return this.each(function () {
      const data = Modal.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config](relatedTarget);
    });
  }

}
/**
 * Data API implementation
 */


exports.Modal = Modal;
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
  const target = getElementFromSelector(this);

  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  EventHandler.one(target, EVENT_SHOW$4, showEvent => {
    if (showEvent.defaultPrevented) {
      // only register focus restorer if modal will actually get shown
      return;
    }

    EventHandler.one(target, EVENT_HIDDEN$4, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  }); // avoid conflict when clicking modal toggler while another one is open

  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);

  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }

  const data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});
enableDismissTrigger(Modal);
/**
 * jQuery
 */

defineJQueryPlugin(Modal);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): offcanvas.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$6 = 'offcanvas';
const DATA_KEY$3 = 'bs.offcanvas';
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const DATA_API_KEY$1 = '.data-api';
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
const ESCAPE_KEY = 'Escape';
const CLASS_NAME_SHOW$3 = 'show';
const CLASS_NAME_SHOWING$1 = 'showing';
const CLASS_NAME_HIDING = 'hiding';
const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
const OPEN_SELECTOR = '.offcanvas.show';
const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
const Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
const DefaultType$5 = {
  backdrop: '(boolean|string)',
  keyboard: 'boolean',
  scroll: 'boolean'
};
/**
 * Class definition
 */

class Offcanvas extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();

    this._addEventListeners();
  } // Getters


  static get Default() {
    return Default$5;
  }

  static get DefaultType() {
    return DefaultType$5;
  }

  static get NAME() {
    return NAME$6;
  } // Public


  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }

  show(relatedTarget) {
    if (this._isShown) {
      return;
    }

    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });

    if (showEvent.defaultPrevented) {
      return;
    }

    this._isShown = true;

    this._backdrop.show();

    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }

    this._element.setAttribute('aria-modal', true);

    this._element.setAttribute('role', 'dialog');

    this._element.classList.add(CLASS_NAME_SHOWING$1);

    const completeCallBack = () => {
      if (!this._config.scroll || this._config.backdrop) {
        this._focustrap.activate();
      }

      this._element.classList.add(CLASS_NAME_SHOW$3);

      this._element.classList.remove(CLASS_NAME_SHOWING$1);

      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };

    this._queueCallback(completeCallBack, this._element, true);
  }

  hide() {
    if (!this._isShown) {
      return;
    }

    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);

    if (hideEvent.defaultPrevented) {
      return;
    }

    this._focustrap.deactivate();

    this._element.blur();

    this._isShown = false;

    this._element.classList.add(CLASS_NAME_HIDING);

    this._backdrop.hide();

    const completeCallback = () => {
      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);

      this._element.removeAttribute('aria-modal');

      this._element.removeAttribute('role');

      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }

      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    };

    this._queueCallback(completeCallback, this._element, true);
  }

  dispose() {
    this._backdrop.dispose();

    this._focustrap.deactivate();

    super.dispose();
  } // Private


  _initializeBackDrop() {
    const clickCallback = () => {
      if (this._config.backdrop === 'static') {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }

      this.hide();
    }; // 'static' option will be translated to true, and booleans will keep their value


    const isVisible = Boolean(this._config.backdrop);
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: isVisible ? clickCallback : null
    });
  }

  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }

  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
      if (event.key !== ESCAPE_KEY) {
        return;
      }

      if (!this._config.keyboard) {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }

      this.hide();
    });
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Offcanvas.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config](this);
    });
  }

}
/**
 * Data API implementation
 */


exports.Offcanvas = Offcanvas;
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
  const target = getElementFromSelector(this);

  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  if (isDisabled(this)) {
    return;
  }

  EventHandler.one(target, EVENT_HIDDEN$3, () => {
    // focus on trigger when it is closed
    if (isVisible(this)) {
      this.focus();
    }
  }); // avoid conflict when clicking a toggler of an offcanvas, while another is open

  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);

  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }

  const data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
    Offcanvas.getOrCreateInstance(selector).show();
  }
});
EventHandler.on(window, EVENT_RESIZE, () => {
  for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {
    if (getComputedStyle(element).position !== 'fixed') {
      Offcanvas.getOrCreateInstance(element).hide();
    }
  }
});
enableDismissTrigger(Offcanvas);
/**
 * jQuery
 */

defineJQueryPlugin(Offcanvas);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
/**
 * A pattern that recognizes a commonly useful subset of URLs that are safe.
 *
 * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */

const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
/**
 * A pattern that matches safe data URLs. Only matches image, video and audio types.
 *
 * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */

const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

const allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();

  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
    }

    return true;
  } // Check if a regular expression validates the attribute.


  return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));
};

const DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
  a: ['target', 'href', 'title', 'rel'],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};

function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }

  if (sanitizeFunction && typeof sanitizeFunction === 'function') {
    return sanitizeFunction(unsafeHtml);
  }

  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));

  for (const element of elements) {
    const elementName = element.nodeName.toLowerCase();

    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }

    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);

    for (const attribute of attributeList) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    }
  }

  return createdDocument.body.innerHTML;
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): util/template-factory.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const NAME$5 = 'TemplateFactory';
const Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: '',
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: '<div></div>'
};
const DefaultType$4 = {
  allowList: 'object',
  content: 'object',
  extraClass: '(string|function)',
  html: 'boolean',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  template: 'string'
};
const DefaultContentType = {
  entry: '(string|element|function|null)',
  selector: '(string|element)'
};
/**
 * Class definition
 */

class TemplateFactory extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
  } // Getters


  static get Default() {
    return Default$4;
  }

  static get DefaultType() {
    return DefaultType$4;
  }

  static get NAME() {
    return NAME$5;
  } // Public


  getContent() {
    return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);
  }

  hasContent() {
    return this.getContent().length > 0;
  }

  changeContent(content) {
    this._checkContent(content);

    this._config.content = { ...this._config.content,
      ...content
    };
    return this;
  }

  toHtml() {
    const templateWrapper = document.createElement('div');
    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);

    for (const [selector, text] of Object.entries(this._config.content)) {
      this._setContent(templateWrapper, text, selector);
    }

    const template = templateWrapper.children[0];

    const extraClass = this._resolvePossibleFunction(this._config.extraClass);

    if (extraClass) {
      template.classList.add(...extraClass.split(' '));
    }

    return template;
  } // Private


  _typeCheckConfig(config) {
    super._typeCheckConfig(config);

    this._checkContent(config.content);
  }

  _checkContent(arg) {
    for (const [selector, content] of Object.entries(arg)) {
      super._typeCheckConfig({
        selector,
        entry: content
      }, DefaultContentType);
    }
  }

  _setContent(template, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template);

    if (!templateElement) {
      return;
    }

    content = this._resolvePossibleFunction(content);

    if (!content) {
      templateElement.remove();
      return;
    }

    if (isElement(content)) {
      this._putElementInTemplate(getElement(content), templateElement);

      return;
    }

    if (this._config.html) {
      templateElement.innerHTML = this._maybeSanitize(content);
      return;
    }

    templateElement.textContent = content;
  }

  _maybeSanitize(arg) {
    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
  }

  _resolvePossibleFunction(arg) {
    return typeof arg === 'function' ? arg(this) : arg;
  }

  _putElementInTemplate(element, templateElement) {
    if (this._config.html) {
      templateElement.innerHTML = '';
      templateElement.append(element);
      return;
    }

    templateElement.textContent = element.textContent;
  }

}
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */


const NAME$4 = 'tooltip';
const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
const CLASS_NAME_FADE$2 = 'fade';
const CLASS_NAME_MODAL = 'modal';
const CLASS_NAME_SHOW$2 = 'show';
const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = 'hide.bs.modal';
const TRIGGER_HOVER = 'hover';
const TRIGGER_FOCUS = 'focus';
const TRIGGER_CLICK = 'click';
const TRIGGER_MANUAL = 'manual';
const EVENT_HIDE$2 = 'hide';
const EVENT_HIDDEN$2 = 'hidden';
const EVENT_SHOW$2 = 'show';
const EVENT_SHOWN$2 = 'shown';
const EVENT_INSERTED = 'inserted';
const EVENT_CLICK$1 = 'click';
const EVENT_FOCUSIN$1 = 'focusin';
const EVENT_FOCUSOUT$1 = 'focusout';
const EVENT_MOUSEENTER = 'mouseenter';
const EVENT_MOUSELEAVE = 'mouseleave';
const AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: isRTL() ? 'left' : 'right',
  BOTTOM: 'bottom',
  LEFT: isRTL() ? 'right' : 'left'
};
const Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: 'clippingParents',
  container: false,
  customClass: '',
  delay: 0,
  fallbackPlacements: ['top', 'right', 'bottom', 'left'],
  html: false,
  offset: [0, 0],
  placement: 'top',
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
  title: '',
  trigger: 'hover focus'
};
const DefaultType$3 = {
  allowList: 'object',
  animation: 'boolean',
  boundary: '(string|element)',
  container: '(string|element|boolean)',
  customClass: '(string|function)',
  delay: '(number|object)',
  fallbackPlacements: 'array',
  html: 'boolean',
  offset: '(array|string|function)',
  placement: '(string|function)',
  popperConfig: '(null|object|function)',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  selector: '(string|boolean)',
  template: 'string',
  title: '(string|element|function)',
  trigger: 'string'
};
/**
 * Class definition
 */

class Tooltip extends BaseComponent {
  constructor(element, config) {
    if (typeof Popper === 'undefined') {
      throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
    }

    super(element, config); // Private

    this._isEnabled = true;
    this._timeout = 0;
    this._isHovered = false;
    this._activeTrigger = {};
    this._popper = null;
    this._templateFactory = null;
    this._newContent = null; // Protected

    this.tip = null;

    this._setListeners();
  } // Getters


  static get Default() {
    return Default$3;
  }

  static get DefaultType() {
    return DefaultType$3;
  }

  static get NAME() {
    return NAME$4;
  } // Public


  enable() {
    this._isEnabled = true;
  }

  disable() {
    this._isEnabled = false;
  }

  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }

  toggle(event) {
    if (!this._isEnabled) {
      return;
    }

    if (event) {
      const context = this._initializeOnDelegatedTarget(event);

      context._activeTrigger.click = !context._activeTrigger.click;

      if (context._isWithActiveTrigger()) {
        context._enter();
      } else {
        context._leave();
      }

      return;
    }

    if (this._isShown()) {
      this._leave();

      return;
    }

    this._enter();
  }

  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

    if (this.tip) {
      this.tip.remove();
    }

    this._disposePopper();

    super.dispose();
  }

  show() {
    if (this._element.style.display === 'none') {
      throw new Error('Please use show on visible elements');
    }

    if (!(this._isWithContent() && this._isEnabled)) {
      return;
    }

    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
    const shadowRoot = findShadowRoot(this._element);

    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);

    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    } // todo v6 remove this OR make it optional


    if (this.tip) {
      this.tip.remove();
      this.tip = null;
    }

    const tip = this._getTipElement();

    this._element.setAttribute('aria-describedby', tip.getAttribute('id'));

    const {
      container
    } = this._config;

    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
    }

    if (this._popper) {
      this._popper.update();
    } else {
      this._popper = this._createPopper(tip);
    }

    tip.classList.add(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we add extra
    // empty mouseover listeners to the body's immediate children;
    // only needed because of broken event delegation on iOS
    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, 'mouseover', noop);
      }
    }

    const complete = () => {
      const previousHoverState = this._isHovered;
      this._isHovered = false;
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));

      if (previousHoverState) {
        this._leave();
      }
    };

    this._queueCallback(complete, this.tip, this._isAnimated());
  }

  hide() {
    if (!this._isShown()) {
      return;
    }

    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));

    if (hideEvent.defaultPrevented) {
      return;
    }

    const tip = this._getTipElement();

    tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra
    // empty mouseover listeners we added for iOS support

    if ('ontouchstart' in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, 'mouseover', noop);
      }
    }

    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    this._isHovered = false;

    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }

      if (!this._isHovered) {
        tip.remove();
      }

      this._element.removeAttribute('aria-describedby');

      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));

      this._disposePopper();
    };

    this._queueCallback(complete, this.tip, this._isAnimated());
  }

  update() {
    if (this._popper) {
      this._popper.update();
    }
  } // Protected


  _isWithContent() {
    return Boolean(this._getTitle());
  }

  _getTipElement() {
    if (!this.tip) {
      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
    }

    return this.tip;
  }

  _createTipElement(content) {
    const tip = this._getTemplateFactory(content).toHtml(); // todo: remove this check on v6


    if (!tip) {
      return null;
    }

    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2); // todo: on v6 the following can be achieved with CSS only

    tip.classList.add(`bs-${this.constructor.NAME}-auto`);
    const tipId = getUID(this.constructor.NAME).toString();
    tip.setAttribute('id', tipId);

    if (this._isAnimated()) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }

    return tip;
  }

  setContent(content) {
    this._newContent = content;

    if (this._isShown()) {
      this._disposePopper();

      this.show();
    }
  }

  _getTemplateFactory(content) {
    if (this._templateFactory) {
      this._templateFactory.changeContent(content);
    } else {
      this._templateFactory = new TemplateFactory({ ...this._config,
        // the `content` var has to be after `this._config`
        // to override config.content in case of popover
        content,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      });
    }

    return this._templateFactory;
  }

  _getContentForTemplate() {
    return {
      [SELECTOR_TOOLTIP_INNER]: this._getTitle()
    };
  }

  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle;
  } // Private


  _initializeOnDelegatedTarget(event) {
    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }

  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
  }

  _isShown() {
    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
  }

  _createPopper(tip) {
    const placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;
    const attachment = AttachmentMap[placement.toUpperCase()];
    return Popper.createPopper(this._element, tip, this._getPopperConfig(attachment));
  }

  _getOffset() {
    const {
      offset
    } = this._config;

    if (typeof offset === 'string') {
      return offset.split(',').map(value => Number.parseInt(value, 10));
    }

    if (typeof offset === 'function') {
      return popperData => offset(popperData, this._element);
    }

    return offset;
  }

  _resolvePossibleFunction(arg) {
    return typeof arg === 'function' ? arg.call(this._element) : arg;
  }

  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: 'flip',
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: 'offset',
        options: {
          offset: this._getOffset()
        }
      }, {
        name: 'preventOverflow',
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: 'arrow',
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: 'preSetPlacement',
        enabled: true,
        phase: 'beforeMain',
        fn: data => {
          // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
          // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
          this._getTipElement().setAttribute('data-popper-placement', data.state.placement);
        }
      }]
    };
    return { ...defaultBsPopperConfig,
      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
    };
  }

  _setListeners() {
    const triggers = this._config.trigger.split(' ');

    for (const trigger of triggers) {
      if (trigger === 'click') {
        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => this.toggle(event));
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
        EventHandler.on(this._element, eventIn, this._config.selector, event => {
          const context = this._initializeOnDelegatedTarget(event);

          context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;

          context._enter();
        });
        EventHandler.on(this._element, eventOut, this._config.selector, event => {
          const context = this._initializeOnDelegatedTarget(event);

          context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);

          context._leave();
        });
      }
    }

    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };

    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

    if (this._config.selector) {
      this._config = { ...this._config,
        trigger: 'manual',
        selector: ''
      };
    } else {
      this._fixTitle();
    }
  }

  _fixTitle() {
    const title = this._config.originalTitle;

    if (!title) {
      return;
    }

    if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {
      this._element.setAttribute('aria-label', title);
    }

    this._element.removeAttribute('title');
  }

  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = true;
      return;
    }

    this._isHovered = true;

    this._setTimeout(() => {
      if (this._isHovered) {
        this.show();
      }
    }, this._config.delay.show);
  }

  _leave() {
    if (this._isWithActiveTrigger()) {
      return;
    }

    this._isHovered = false;

    this._setTimeout(() => {
      if (!this._isHovered) {
        this.hide();
      }
    }, this._config.delay.hide);
  }

  _setTimeout(handler, timeout) {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(handler, timeout);
  }

  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(true);
  }

  _getConfig(config) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);

    for (const dataAttribute of Object.keys(dataAttributes)) {
      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
        delete dataAttributes[dataAttribute];
      }
    }

    config = { ...dataAttributes,
      ...(typeof config === 'object' && config ? config : {})
    };
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);

    this._typeCheckConfig(config);

    return config;
  }

  _configAfterMerge(config) {
    config.container = config.container === false ? document.body : getElement(config.container);

    if (typeof config.delay === 'number') {
      config.delay = {
        show: config.delay,
        hide: config.delay
      };
    }

    config.originalTitle = this._element.getAttribute('title') || '';

    if (typeof config.title === 'number') {
      config.title = config.title.toString();
    }

    if (typeof config.content === 'number') {
      config.content = config.content.toString();
    }

    return config;
  }

  _getDelegateConfig() {
    const config = {};

    for (const key in this._config) {
      if (this.constructor.Default[key] !== this._config[key]) {
        config[key] = this._config[key];
      }
    } // In the future can be replaced with:
    // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
    // `Object.fromEntries(keysWithDifferentValues)`


    return config;
  }

  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();

      this._popper = null;
    }
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Tooltip.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config]();
    });
  }

}
/**
 * jQuery
 */


exports.Tooltip = Tooltip;
defineJQueryPlugin(Tooltip);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$3 = 'popover';
const SELECTOR_TITLE = '.popover-header';
const SELECTOR_CONTENT = '.popover-body';
const Default$2 = { ...Tooltip.Default,
  content: '',
  offset: [0, 8],
  placement: 'right',
  template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>',
  trigger: 'click'
};
const DefaultType$2 = { ...Tooltip.DefaultType,
  content: '(null|string|element|function)'
};
/**
 * Class definition
 */

class Popover extends Tooltip {
  // Getters
  static get Default() {
    return Default$2;
  }

  static get DefaultType() {
    return DefaultType$2;
  }

  static get NAME() {
    return NAME$3;
  } // Overrides


  _isWithContent() {
    return this._getTitle() || this._getContent();
  } // Private


  _getContentForTemplate() {
    return {
      [SELECTOR_TITLE]: this._getTitle(),
      [SELECTOR_CONTENT]: this._getContent()
    };
  }

  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Popover.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config]();
    });
  }

}
/**
 * jQuery
 */


exports.Popover = Popover;
defineJQueryPlugin(Popover);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$2 = 'scrollspy';
const DATA_KEY$2 = 'bs.scrollspy';
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY = '.data-api';
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_CLICK = `click${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
const CLASS_NAME_ACTIVE$1 = 'active';
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_TARGET_LINKS = '[href]';
const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
const SELECTOR_NAV_LINKS = '.nav-link';
const SELECTOR_NAV_ITEMS = '.nav-item';
const SELECTOR_LIST_ITEMS = '.list-group-item';
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
const SELECTOR_DROPDOWN = '.dropdown';
const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
const Default$1 = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: '0px 0px -25%',
  smoothScroll: false,
  target: null
};
const DefaultType$1 = {
  offset: '(number|null)',
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: 'string',
  smoothScroll: 'boolean',
  target: 'element'
};
/**
 * Class definition
 */

class ScrollSpy extends BaseComponent {
  constructor(element, config) {
    super(element, config); // this._element is the observablesContainer and config.target the menu links wrapper

    this._targetLinks = new Map();
    this._observableSections = new Map();
    this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;
    this._activeTarget = null;
    this._observer = null;
    this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    this.refresh(); // initialize
  } // Getters


  static get Default() {
    return Default$1;
  }

  static get DefaultType() {
    return DefaultType$1;
  }

  static get NAME() {
    return NAME$2;
  } // Public


  refresh() {
    this._initializeTargetsAndObservables();

    this._maybeEnableSmoothScroll();

    if (this._observer) {
      this._observer.disconnect();
    } else {
      this._observer = this._getNewObserver();
    }

    for (const section of this._observableSections.values()) {
      this._observer.observe(section);
    }
  }

  dispose() {
    this._observer.disconnect();

    super.dispose();
  } // Private


  _configAfterMerge(config) {
    // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
    config.target = getElement(config.target) || document.body;
    return config;
  }

  _maybeEnableSmoothScroll() {
    if (!this._config.smoothScroll) {
      return;
    } // unregister any previous listeners


    EventHandler.off(this._config.target, EVENT_CLICK);
    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {
      const observableSection = this._observableSections.get(event.target.hash);

      if (observableSection) {
        event.preventDefault();
        const root = this._rootElement || window;
        const height = observableSection.offsetTop - this._element.offsetTop;

        if (root.scrollTo) {
          root.scrollTo({
            top: height,
            behavior: 'smooth'
          });
          return;
        } // Chrome 60 doesn't support `scrollTo`


        root.scrollTop = height;
      }
    });
  }

  _getNewObserver() {
    const options = {
      root: this._rootElement,
      threshold: [0.1, 0.5, 1],
      rootMargin: this._getRootMargin()
    };
    return new IntersectionObserver(entries => this._observerCallback(entries), options);
  } // The logic of selection


  _observerCallback(entries) {
    const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);

    const activate = entry => {
      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;

      this._process(targetElement(entry));
    };

    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = parentScrollTop;

    for (const entry of entries) {
      if (!entry.isIntersecting) {
        this._activeTarget = null;

        this._clearActiveClass(targetElement(entry));

        continue;
      }

      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop; // if we are scrolling down, pick the bigger offsetTop

      if (userScrollsDown && entryIsLowerThanPrevious) {
        activate(entry); // if parent isn't scrolled, let's keep the first visible item, breaking the iteration

        if (!parentScrollTop) {
          return;
        }

        continue;
      } // if we are scrolling up, pick the smallest offsetTop


      if (!userScrollsDown && !entryIsLowerThanPrevious) {
        activate(entry);
      }
    }
  } // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only


  _getRootMargin() {
    return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin;
  }

  _initializeTargetsAndObservables() {
    this._targetLinks = new Map();
    this._observableSections = new Map();
    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);

    for (const anchor of targetLinks) {
      // ensure that the anchor has an id and is not disabled
      if (!anchor.hash || isDisabled(anchor)) {
        continue;
      }

      const observableSection = SelectorEngine.findOne(anchor.hash, this._element); // ensure that the observableSection exists & is visible

      if (isVisible(observableSection)) {
        this._targetLinks.set(anchor.hash, anchor);

        this._observableSections.set(anchor.hash, observableSection);
      }
    }
  }

  _process(target) {
    if (this._activeTarget === target) {
      return;
    }

    this._clearActiveClass(this._config.target);

    this._activeTarget = target;
    target.classList.add(CLASS_NAME_ACTIVE$1);

    this._activateParents(target);

    EventHandler.trigger(this._element, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }

  _activateParents(target) {
    // Activate dropdown parents
    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
      return;
    }

    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
      // Set triggered links parents as active
      // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
        item.classList.add(CLASS_NAME_ACTIVE$1);
      }
    }
  }

  _clearActiveClass(parent) {
    parent.classList.remove(CLASS_NAME_ACTIVE$1);
    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);

    for (const node of activeNodes) {
      node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = ScrollSpy.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config]();
    });
  }

}
/**
 * Data API implementation
 */


exports.ScrollSpy = ScrollSpy;
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
    ScrollSpy.getOrCreateInstance(spy);
  }
});
/**
 * jQuery
 */

defineJQueryPlugin(ScrollSpy);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME$1 = 'tab';
const DATA_KEY$1 = 'bs.tab';
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
const ARROW_LEFT_KEY = 'ArrowLeft';
const ARROW_RIGHT_KEY = 'ArrowRight';
const ARROW_UP_KEY = 'ArrowUp';
const ARROW_DOWN_KEY = 'ArrowDown';
const CLASS_NAME_ACTIVE = 'active';
const CLASS_NAME_FADE$1 = 'fade';
const CLASS_NAME_SHOW$1 = 'show';
const CLASS_DROPDOWN = 'dropdown';
const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
const SELECTOR_DROPDOWN_ITEM = '.dropdown-item';
const NOT_SELECTOR_DROPDOWN_TOGGLE = ':not(.dropdown-toggle)';
const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
const SELECTOR_OUTER = '.nav-item, .list-group-item';
const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // todo:v6: could be only `tab`

const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
/**
 * Class definition
 */

class Tab extends BaseComponent {
  constructor(element) {
    super(element);
    this._parent = this._element.closest(SELECTOR_TAB_PANEL);

    if (!this._parent) {
      return; // todo: should Throw exception on v6
      // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
    } // Set up initial aria attributes


    this._setInitialAttributes(this._parent, this._getChildren());

    EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));
  } // Getters


  static get NAME() {
    return NAME$1;
  } // Public


  show() {
    // Shows this elem and deactivate the active sibling if exists
    const innerElem = this._element;

    if (this._elemIsActive(innerElem)) {
      return;
    } // Search for active tab on same parent to deactivate it


    const active = this._getActiveElem();

    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
      relatedTarget: innerElem
    }) : null;
    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
      relatedTarget: active
    });

    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
      return;
    }

    this._deactivate(active, innerElem);

    this._activate(innerElem, active);
  } // Private


  _activate(element, relatedElem) {
    if (!element) {
      return;
    }

    element.classList.add(CLASS_NAME_ACTIVE);

    this._activate(getElementFromSelector(element)); // Search and activate/show the proper section


    const complete = () => {
      if (element.getAttribute('role') !== 'tab') {
        element.classList.add(CLASS_NAME_SHOW$1);
        return;
      }

      element.focus();
      element.removeAttribute('tabindex');
      element.setAttribute('aria-selected', true);

      this._toggleDropDown(element, true);

      EventHandler.trigger(element, EVENT_SHOWN$1, {
        relatedTarget: relatedElem
      });
    };

    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }

  _deactivate(element, relatedElem) {
    if (!element) {
      return;
    }

    element.classList.remove(CLASS_NAME_ACTIVE);
    element.blur();

    this._deactivate(getElementFromSelector(element)); // Search and deactivate the shown section too


    const complete = () => {
      if (element.getAttribute('role') !== 'tab') {
        element.classList.remove(CLASS_NAME_SHOW$1);
        return;
      }

      element.setAttribute('aria-selected', false);
      element.setAttribute('tabindex', '-1');

      this._toggleDropDown(element, false);

      EventHandler.trigger(element, EVENT_HIDDEN$1, {
        relatedTarget: relatedElem
      });
    };

    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }

  _keydown(event) {
    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {
      return;
    }

    event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page

    event.preventDefault();
    const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
    const nextActiveElement = getNextActiveElement(this._getChildren().filter(element => !isDisabled(element)), event.target, isNext, true);

    if (nextActiveElement) {
      Tab.getOrCreateInstance(nextActiveElement).show();
    }
  }

  _getChildren() {
    // collection of inner elements
    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
  }

  _getActiveElem() {
    return this._getChildren().find(child => this._elemIsActive(child)) || null;
  }

  _setInitialAttributes(parent, children) {
    this._setAttributeIfNotExists(parent, 'role', 'tablist');

    for (const child of children) {
      this._setInitialAttributesOnChild(child);
    }
  }

  _setInitialAttributesOnChild(child) {
    child = this._getInnerElement(child);

    const isActive = this._elemIsActive(child);

    const outerElem = this._getOuterElement(child);

    child.setAttribute('aria-selected', isActive);

    if (outerElem !== child) {
      this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
    }

    if (!isActive) {
      child.setAttribute('tabindex', '-1');
    }

    this._setAttributeIfNotExists(child, 'role', 'tab'); // set attributes to the related panel too


    this._setInitialAttributesOnTargetPanel(child);
  }

  _setInitialAttributesOnTargetPanel(child) {
    const target = getElementFromSelector(child);

    if (!target) {
      return;
    }

    this._setAttributeIfNotExists(target, 'role', 'tabpanel');

    if (child.id) {
      this._setAttributeIfNotExists(target, 'aria-labelledby', `#${child.id}`);
    }
  }

  _toggleDropDown(element, open) {
    const outerElem = this._getOuterElement(element);

    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
      return;
    }

    const toggle = (selector, className) => {
      const element = SelectorEngine.findOne(selector, outerElem);

      if (element) {
        element.classList.toggle(className, open);
      }
    };

    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
    toggle(SELECTOR_DROPDOWN_ITEM, CLASS_NAME_ACTIVE);
    outerElem.setAttribute('aria-expanded', open);
  }

  _setAttributeIfNotExists(element, attribute, value) {
    if (!element.hasAttribute(attribute)) {
      element.setAttribute(attribute, value);
    }
  }

  _elemIsActive(elem) {
    return elem.classList.contains(CLASS_NAME_ACTIVE);
  } // Try to get the inner element (usually the .nav-link)


  _getInnerElement(elem) {
    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
  } // Try to get the outer element (usually the .nav-item)


  _getOuterElement(elem) {
    return elem.closest(SELECTOR_OUTER) || elem;
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Tab.getOrCreateInstance(this);

      if (typeof config !== 'string') {
        return;
      }

      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config]();
    });
  }

}
/**
 * Data API implementation
 */


exports.Tab = Tab;
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  if (isDisabled(this)) {
    return;
  }

  Tab.getOrCreateInstance(this).show();
});
/**
 * Initialize on focus
 */

EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
    Tab.getOrCreateInstance(element);
  }
});
/**
 * jQuery
 */

defineJQueryPlugin(Tab);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.2.0): toast.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Constants
 */

const NAME = 'toast';
const DATA_KEY = 'bs.toast';
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = 'fade';
const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility

const CLASS_NAME_SHOW = 'show';
const CLASS_NAME_SHOWING = 'showing';
const DefaultType = {
  animation: 'boolean',
  autohide: 'boolean',
  delay: 'number'
};
const Default = {
  animation: true,
  autohide: true,
  delay: 5000
};
/**
 * Class definition
 */

class Toast extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;

    this._setListeners();
  } // Getters


  static get Default() {
    return Default;
  }

  static get DefaultType() {
    return DefaultType;
  }

  static get NAME() {
    return NAME;
  } // Public


  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);

    if (showEvent.defaultPrevented) {
      return;
    }

    this._clearTimeout();

    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }

    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);

      EventHandler.trigger(this._element, EVENT_SHOWN);

      this._maybeScheduleHide();
    };

    this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated


    reflow(this._element);

    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);

    this._queueCallback(complete, this._element, this._config.animation);
  }

  hide() {
    if (!this.isShown()) {
      return;
    }

    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);

    if (hideEvent.defaultPrevented) {
      return;
    }

    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE); // @deprecated


      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);

      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };

    this._element.classList.add(CLASS_NAME_SHOWING);

    this._queueCallback(complete, this._element, this._config.animation);
  }

  dispose() {
    this._clearTimeout();

    if (this.isShown()) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }

    super.dispose();
  }

  isShown() {
    return this._element.classList.contains(CLASS_NAME_SHOW);
  } // Private


  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }

    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }

    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }

  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case 'mouseover':
      case 'mouseout':
        this._hasMouseInteraction = isInteracting;
        break;

      case 'focusin':
      case 'focusout':
        this._hasKeyboardInteraction = isInteracting;
        break;
    }

    if (isInteracting) {
      this._clearTimeout();

      return;
    }

    const nextElement = event.relatedTarget;

    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }

    this._maybeScheduleHide();
  }

  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));
  }

  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Toast.getOrCreateInstance(this, config);

      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config](this);
      }
    });
  }

}
/**
 * Data API implementation
 */


exports.Toast = Toast;
enableDismissTrigger(Toast);
/**
 * jQuery
 */

defineJQueryPlugin(Toast);
},{"@popperjs/core":"vePw"}],"VUDL":[function(require,module,exports) {

},{}],"jUDY":[function(require,module,exports) {
var global = arguments[3];
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

},{}],"UkOL":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"nx4R":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"pwJ5":[function(require,module,exports) {
var process = require("process");
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


},{"process":"nx4R"}],"pRlI":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"hAhw":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
},{}],"b5wN":[function(require,module,exports) {
module.exports = require('events').EventEmitter;

},{"events":"hAhw"}],"Gvp3":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"jJYq":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"wYDm":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"Gvp3","ieee754":"jJYq","isarray":"pRlI","buffer":"wYDm"}],"eWhT":[function(require,module,exports) {

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"wYDm"}],"goj7":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":"wYDm"}],"IY8E":[function(require,module,exports) {

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":"eWhT","util":"VUDL"}],"CN6D":[function(require,module,exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":"pwJ5"}],"j7kG":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"Tl2L":[function(require,module,exports) {
var process = require("process");

var global = arguments[3];
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !true && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/


var Buffer = require('safe-buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
},{"process-nextick-args":"pwJ5","core-util-is":"goj7","inherits":"UkOL","util-deprecate":"j7kG","./internal/streams/stream":"b5wN","safe-buffer":"eWhT","./internal/streams/destroy":"CN6D","./_stream_duplex":"Z4vW","process":"nx4R"}],"Z4vW":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"process-nextick-args":"pwJ5","core-util-is":"goj7","inherits":"UkOL","./_stream_readable":"xDmC","./_stream_writable":"Tl2L"}],"EDtE":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"eWhT"}],"xDmC":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"process-nextick-args":"pwJ5","isarray":"pRlI","events":"hAhw","./internal/streams/stream":"b5wN","safe-buffer":"eWhT","core-util-is":"goj7","inherits":"UkOL","util":"VUDL","./internal/streams/BufferList":"IY8E","./internal/streams/destroy":"CN6D","./_stream_duplex":"Z4vW","string_decoder/":"EDtE","process":"nx4R"}],"Cc0Q":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"Z4vW","core-util-is":"goj7","inherits":"UkOL"}],"xg44":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"Cc0Q","core-util-is":"goj7","inherits":"UkOL"}],"aCYX":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_readable.js":"xDmC","./lib/_stream_writable.js":"Tl2L","./lib/_stream_duplex.js":"Z4vW","./lib/_stream_transform.js":"Cc0Q","./lib/_stream_passthrough.js":"xg44"}],"NJ5X":[function(require,module,exports) {
var process = require("process");
var Buffer = require("buffer").Buffer;
var global = arguments[3];
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

},{"./capability":"jUDY","inherits":"UkOL","readable-stream":"aCYX","process":"nx4R","buffer":"wYDm"}],"Ufxy":[function(require,module,exports) {

var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":"wYDm"}],"lWCq":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var global = arguments[3];
var process = require("process");
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')
var toArrayBuffer = require('to-arraybuffer')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

},{"./capability":"jUDY","inherits":"UkOL","./response":"NJ5X","readable-stream":"aCYX","to-arraybuffer":"Ufxy","buffer":"wYDm","process":"nx4R"}],"AHA8":[function(require,module,exports) {
module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}
},{}],"qX7j":[function(require,module,exports) {
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],"O2Ju":[function(require,module,exports) {
var global = arguments[3];
var define;
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

},{}],"SChV":[function(require,module,exports) {
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],"yvXZ":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict'; // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
},{}],"zkwv":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};
},{}],"Z1BA":[function(require,module,exports) {
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');
},{"./decode":"yvXZ","./encode":"zkwv"}],"uTlm":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"punycode":"O2Ju","./util":"SChV","querystring":"Z1BA"}],"fwyw":[function(require,module,exports) {
var global = arguments[3];
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
},{"./lib/request":"lWCq","./lib/response":"NJ5X","xtend":"AHA8","builtin-status-codes":"qX7j","url":"uTlm"}],"d0NU":[function(require,module,exports) {
var process = require("process");
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"process":"nx4R"}],"liHC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ValidateModule = exports.TooltipModule = exports.TabulatorFull = exports.Tabulator = exports.SortModule = exports.SelectRowModule = exports.RowComponent = exports.ResponsiveLayoutModule = exports.ResizeTableModule = exports.ResizeRowsModule = exports.ResizeColumnsModule = exports.Renderer = exports.ReactiveDataModule = exports.PseudoRow = exports.PrintModule = exports.PopupModule = exports.PersistenceModule = exports.PageModule = exports.MutatorModule = exports.MoveRowsModule = exports.MoveColumnsModule = exports.Module = exports.MenuModule = exports.KeybindingsModule = exports.InteractionModule = exports.ImportModule = exports.HtmlTableImportModule = exports.HistoryModule = exports.GroupRowsModule = exports.GroupComponent = exports.FrozenRowsModule = exports.FrozenColumnsModule = exports.FormatModule = exports.FilterModule = exports.ExportModule = exports.EditModule = exports.DownloadModule = exports.DataTreeModule = exports.ColumnComponent = exports.ColumnCalcsModule = exports.ClipboardModule = exports.CellComponent = exports.CalcComponent = exports.AjaxModule = exports.AccessorModule = void 0;

/* Tabulator v5.3.1 (c) Oliver Folkerd 2022 */
class CoreFeature {
  constructor(table) {
    this.table = table;
  } //////////////////////////////////////////
  /////////////// DataLoad /////////////////
  //////////////////////////////////////////


  reloadData(data, silent, columnsChanged) {
    return this.table.dataLoader.load(data, undefined, undefined, undefined, silent, columnsChanged);
  } //////////////////////////////////////////
  ///////////// Localization ///////////////
  //////////////////////////////////////////


  langText() {
    return this.table.modules.localize.getText(...arguments);
  }

  langBind() {
    return this.table.modules.localize.bind(...arguments);
  }

  langLocale() {
    return this.table.modules.localize.getLocale(...arguments);
  } //////////////////////////////////////////
  ////////// Inter Table Comms /////////////
  //////////////////////////////////////////


  commsConnections() {
    return this.table.modules.comms.getConnections(...arguments);
  }

  commsSend() {
    return this.table.modules.comms.send(...arguments);
  } //////////////////////////////////////////
  //////////////// Layout  /////////////////
  //////////////////////////////////////////


  layoutMode() {
    return this.table.modules.layout.getMode();
  }

  layoutRefresh(force) {
    return this.table.modules.layout.layout(force);
  } //////////////////////////////////////////
  /////////////// Event Bus ////////////////
  //////////////////////////////////////////


  subscribe() {
    return this.table.eventBus.subscribe(...arguments);
  }

  unsubscribe() {
    return this.table.eventBus.unsubscribe(...arguments);
  }

  subscribed(key) {
    return this.table.eventBus.subscribed(key);
  }

  subscriptionChange() {
    return this.table.eventBus.subscriptionChange(...arguments);
  }

  dispatch() {
    return this.table.eventBus.dispatch(...arguments);
  }

  chain() {
    return this.table.eventBus.chain(...arguments);
  }

  confirm() {
    return this.table.eventBus.confirm(...arguments);
  }

  dispatchExternal() {
    return this.table.externalEvents.dispatch(...arguments);
  }

  subscribedExternal(key) {
    return this.table.externalEvents.subscribed(key);
  }

  subscriptionChangeExternal() {
    return this.table.externalEvents.subscriptionChange(...arguments);
  } //////////////////////////////////////////
  //////////////// Options /////////////////
  //////////////////////////////////////////


  options(key) {
    return this.table.options[key];
  }

  setOption(key, value) {
    if (typeof value !== "undefined") {
      this.table.options[key] = value;
    }

    return this.table.options[key];
  } //////////////////////////////////////////
  /////////// Deprecation Checks ///////////
  //////////////////////////////////////////


  deprecationCheck(oldOption, newOption) {
    return this.table.deprecationAdvisor.check(oldOption, newOption);
  }

  deprecationCheckMsg(oldOption, msg) {
    return this.table.deprecationAdvisor.checkMsg(oldOption, msg);
  }

  deprecationMsg(msg) {
    return this.table.deprecationAdvisor.msg(msg);
  } //////////////////////////////////////////
  //////////////// Modules /////////////////
  //////////////////////////////////////////


  module(key) {
    return this.table.module(key);
  }

}

class Helpers {
  static elVisible(el) {
    return !(el.offsetWidth <= 0 && el.offsetHeight <= 0);
  }

  static elOffset(el) {
    var box = el.getBoundingClientRect();
    return {
      top: box.top + window.pageYOffset - document.documentElement.clientTop,
      left: box.left + window.pageXOffset - document.documentElement.clientLeft
    };
  }

  static deepClone(obj, clone, list = []) {
    var objectProto = {}.__proto__,
        arrayProto = [].__proto__;

    if (!clone) {
      clone = Object.assign(Array.isArray(obj) ? [] : {}, obj);
    }

    for (var i in obj) {
      let subject = obj[i],
          match,
          copy;

      if (subject != null && typeof subject === "object" && (subject.__proto__ === objectProto || subject.__proto__ === arrayProto)) {
        match = list.findIndex(item => {
          return item.subject === subject;
        });

        if (match > -1) {
          clone[i] = list[match].copy;
        } else {
          copy = Object.assign(Array.isArray(subject) ? [] : {}, subject);
          list.unshift({
            subject,
            copy
          });
          clone[i] = this.deepClone(subject, copy, list);
        }
      }
    }

    return clone;
  }

}

class Popup extends CoreFeature {
  constructor(table, element, parent) {
    super(table);
    this.element = element;
    this.container = this._lookupContainer();
    this.parent = parent;
    this.reversedX = false;
    this.childPopup = null;
    this.blurable = false;
    this.blurCallback = null;
    this.renderedCallback = null;
    this.visible = false;
    this.hideable = true;
    this.element.classList.add("tabulator-popup-container");
    this.blurEvent = this.hide.bind(this, false);
    this.escEvent = this._escapeCheck.bind(this);
    this.destroyBinding = this.tableDestroyed;
    this.destroyed = false;
  }

  tableDestroyed() {
    this.destroyed = true;
    this.hide(true);
  }

  _lookupContainer() {
    var container = this.table.options.popupContainer;

    if (typeof container === "string") {
      container = document.querySelector(container);

      if (!container) {
        console.warn("Menu Error - no container element found matching selector:", this.table.options.popupContainer, "(defaulting to document body)");
      }
    } else if (container === true) {
      container = this.table.element;
    }

    if (container && !this._checkContainerIsParent(container)) {
      container = false;
      console.warn("Menu Error - container element does not contain this table:", this.table.options.popupContainer, "(defaulting to document body)");
    }

    if (!container) {
      container = document.body;
    }

    return container;
  }

  _checkContainerIsParent(container, element = this.table.element) {
    if (container === element) {
      return true;
    } else {
      return element.parentNode ? this._checkContainerIsParent(container, element.parentNode) : false;
    }
  }

  renderCallback(callback) {
    this.renderedCallback = callback;
  }

  containerEventCoords(e) {
    var touch = !(e instanceof MouseEvent);
    var x = touch ? e.touches[0].pageX : e.pageX;
    var y = touch ? e.touches[0].pageY : e.pageY;

    if (this.container !== document.body) {
      let parentOffset = Helpers.elOffset(this.container);
      x -= parentOffset.left;
      y -= parentOffset.top;
    }

    return {
      x,
      y
    };
  }

  elementPositionCoords(element, position = "right") {
    var offset = Helpers.elOffset(element),
        containerOffset,
        x,
        y;

    if (this.container !== document.body) {
      containerOffset = Helpers.elOffset(this.container);
      offset.left -= containerOffset.left;
      offset.top -= containerOffset.top;
    }

    switch (position) {
      case "right":
        x = offset.left + element.offsetWidth;
        y = offset.top - 1;
        break;

      case "bottom":
        x = offset.left;
        y = offset.top + element.offsetHeight;
        break;
    }

    return {
      x,
      y,
      offset
    };
  }

  show(origin, position) {
    var x, y, parentEl, parentOffset, coords;

    if (this.destroyed || this.table.destroyed) {
      return this;
    }

    if (origin instanceof HTMLElement) {
      parentEl = origin;
      coords = this.elementPositionCoords(origin, position);
      parentOffset = coords.offset;
      x = coords.x;
      y = coords.y;
    } else if (typeof origin === "number") {
      parentOffset = {
        top: 0,
        left: 0
      };
      x = origin;
      y = position;
    } else {
      coords = this.containerEventCoords(origin);
      x = coords.x;
      y = coords.y;
      this.reversedX = false;
    }

    this.element.style.top = y + "px";
    this.element.style.left = x + "px";
    this.container.appendChild(this.element);

    if (typeof this.renderedCallback === "function") {
      this.renderedCallback();
    }

    this._fitToScreen(x, y, parentEl, parentOffset, position);

    this.visible = true;
    this.subscribe("table-destroy", this.destroyBinding);
    this.element.addEventListener("mousedown", e => {
      e.stopPropagation();
    });
    return this;
  }

  _fitToScreen(x, y, parentEl, parentOffset, position) {
    var scrollTop = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop; //move menu to start on right edge if it is too close to the edge of the screen

    if (x + this.element.offsetWidth >= this.container.offsetWidth || this.reversedX) {
      this.element.style.left = "";

      if (parentEl) {
        this.element.style.right = this.container.offsetWidth - parentOffset.left + "px";
      } else {
        this.element.style.right = this.container.offsetWidth - x + "px";
      }

      this.reversedX = true;
    } //move menu to start on bottom edge if it is too close to the edge of the screen


    if (y + this.element.offsetHeight > Math.max(this.container.offsetHeight, scrollTop ? this.container.scrollHeight : 0)) {
      if (parentEl) {
        switch (position) {
          case "bottom":
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight - parentEl.offsetHeight - 1 + "px";
            break;

          default:
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + parentEl.offsetHeight + 1 + "px";
        }
      } else {
        this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + "px";
      }
    }
  }

  isVisible() {
    return this.visible;
  }

  hideOnBlur(callback) {
    this.blurable = true;

    if (this.visible) {
      setTimeout(() => {
        this.table.rowManager.element.addEventListener("scroll", this.blurEvent);
        this.subscribe("cell-editing", this.blurEvent);
        document.body.addEventListener("click", this.blurEvent);
        document.body.addEventListener("contextmenu", this.blurEvent);
        document.body.addEventListener("mousedown", this.blurEvent);
        window.addEventListener("resize", this.blurEvent);
        document.body.addEventListener("keydown", this.escEvent);
      }, 100);
      this.blurCallback = callback;
    }

    return this;
  }

  _escapeCheck(e) {
    if (e.keyCode == 27) {
      this.hide();
    }
  }

  blockHide() {
    this.hideable = false;
  }

  restoreHide() {
    this.hideable = true;
  }

  hide(silent = false) {
    if (this.visible && this.hideable) {
      if (this.blurable) {
        document.body.removeEventListener("keydown", this.escEvent);
        document.body.removeEventListener("click", this.blurEvent);
        document.body.removeEventListener("contextmenu", this.blurEvent);
        document.body.removeEventListener("mousedown", this.blurEvent);
        window.removeEventListener("resize", this.blurEvent);
        this.table.rowManager.element.removeEventListener("scroll", this.blurEvent);
        this.unsubscribe("cell-editing", this.blurEvent);
      }

      if (this.childPopup) {
        this.childPopup.hide();
      }

      if (this.parent) {
        this.parent.childPopup = null;
      }

      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }

      this.visible = false;

      if (this.blurCallback && !silent) {
        this.blurCallback();
      }

      this.unsubscribe("table-destroy", this.destroyBinding);
    }

    return this;
  }

  child(element) {
    if (this.childPopup) {
      this.childPopup.hide();
    }

    this.childPopup = new Popup(this.table, element, this);
    return this.childPopup;
  }

}

class Module extends CoreFeature {
  constructor(table, name) {
    super(table);
    this._handler = null;
  }

  initialize() {// setup module when table is initialized, to be overridden in module
  } ///////////////////////////////////
  ////// Options Registration ///////
  ///////////////////////////////////


  registerTableOption(key, value) {
    this.table.optionsList.register(key, value);
  }

  registerColumnOption(key, value) {
    this.table.columnManager.optionsList.register(key, value);
  } ///////////////////////////////////
  /// Public Function Registration ///
  ///////////////////////////////////


  registerTableFunction(name, func) {
    if (typeof this.table[name] === "undefined") {
      this.table[name] = (...args) => {
        this.table.initGuard(name);
        return func(...args);
      };
    } else {
      console.warn("Unable to bind table function, name already in use", name);
    }
  }

  registerComponentFunction(component, func, handler) {
    return this.table.componentFunctionBinder.bind(component, func, handler);
  } ///////////////////////////////////
  ////////// Data Pipeline //////////
  ///////////////////////////////////


  registerDataHandler(handler, priority) {
    this.table.rowManager.registerDataPipelineHandler(handler, priority);
    this._handler = handler;
  }

  registerDisplayHandler(handler, priority) {
    this.table.rowManager.registerDisplayPipelineHandler(handler, priority);
    this._handler = handler;
  }

  refreshData(renderInPosition, handler) {
    if (!handler) {
      handler = this._handler;
    }

    if (handler) {
      this.table.rowManager.refreshActiveData(handler, false, renderInPosition);
    }
  } ///////////////////////////////////
  //////// Footer Management ////////
  ///////////////////////////////////


  footerAppend(element) {
    return this.table.footerManager.append(element);
  }

  footerPrepend(element) {
    return this.table.footerManager.prepend(element);
  }

  footerRemove(element) {
    return this.table.footerManager.remove(element);
  } ///////////////////////////////////
  //////// Popups Management ////////
  ///////////////////////////////////


  popup(menuEl, menuContainer) {
    return new Popup(this.table, menuEl, menuContainer);
  } ///////////////////////////////////
  //////// Alert Management ////////
  ///////////////////////////////////


  alert(content, type) {
    return this.table.alertManager.alert(content, type);
  }

  clearAlert() {
    return this.table.alertManager.clear();
  }

}

exports.Module = Module;
var defaultAccessors = {};

class Accessor extends Module {
  constructor(table) {
    super(table);
    this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"]; //list of accessor types

    this.registerColumnOption("accessor");
    this.registerColumnOption("accessorParams");
    this.registerColumnOption("accessorData");
    this.registerColumnOption("accessorDataParams");
    this.registerColumnOption("accessorDownload");
    this.registerColumnOption("accessorDownloadParams");
    this.registerColumnOption("accessorClipboard");
    this.registerColumnOption("accessorClipboardParams");
    this.registerColumnOption("accessorPrint");
    this.registerColumnOption("accessorPrintParams");
    this.registerColumnOption("accessorHtmlOutput");
    this.registerColumnOption("accessorHtmlOutputParams");
  }

  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("row-data-retrieve", this.transformRow.bind(this));
  } //initialize column accessor


  initializeColumn(column) {
    var match = false,
        config = {};
    this.allowedTypes.forEach(type => {
      var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)),
          accessor;

      if (column.definition[key]) {
        accessor = this.lookupAccessor(column.definition[key]);

        if (accessor) {
          match = true;
          config[key] = {
            accessor: accessor,
            params: column.definition[key + "Params"] || {}
          };
        }
      }
    });

    if (match) {
      column.modules.accessor = config;
    }
  }

  lookupAccessor(value) {
    var accessor = false; //set column accessor

    switch (typeof value) {
      case "string":
        if (Accessor.accessors[value]) {
          accessor = Accessor.accessors[value];
        } else {
          console.warn("Accessor Error - No such accessor found, ignoring: ", value);
        }

        break;

      case "function":
        accessor = value;
        break;
    }

    return accessor;
  } //apply accessor to row


  transformRow(row, type) {
    var key = "accessor" + (type.charAt(0).toUpperCase() + type.slice(1)),
        rowComponent = row.getComponent(); //clone data object with deep copy to isolate internal data from returned result

    var data = Helpers.deepClone(row.data || {});
    this.table.columnManager.traverse(function (column) {
      var value, accessor, params, colComponent;

      if (column.modules.accessor) {
        accessor = column.modules.accessor[key] || column.modules.accessor.accessor || false;

        if (accessor) {
          value = column.getFieldValue(data);

          if (value != "undefined") {
            colComponent = column.getComponent();
            params = typeof accessor.params === "function" ? accessor.params(value, data, type, colComponent, rowComponent) : accessor.params;
            column.setFieldValue(data, accessor.accessor(value, data, type, params, colComponent, rowComponent));
          }
        }
      }
    });
    return data;
  }

} //load defaults


exports.AccessorModule = Accessor;
Accessor.moduleName = "accessor";
Accessor.accessors = defaultAccessors;
var defaultConfig = {
  method: "GET"
};

function generateParamsList(data, prefix) {
  var output = [];
  prefix = prefix || "";

  if (Array.isArray(data)) {
    data.forEach((item, i) => {
      output = output.concat(generateParamsList(item, prefix ? prefix + "[" + i + "]" : i));
    });
  } else if (typeof data === "object") {
    for (var key in data) {
      output = output.concat(generateParamsList(data[key], prefix ? prefix + "[" + key + "]" : key));
    }
  } else {
    output.push({
      key: prefix,
      value: data
    });
  }

  return output;
}

function serializeParams(params) {
  var output = generateParamsList(params),
      encoded = [];
  output.forEach(function (item) {
    encoded.push(encodeURIComponent(item.key) + "=" + encodeURIComponent(item.value));
  });
  return encoded.join("&");
}

function urlBuilder(url, config, params) {
  if (url) {
    if (params && Object.keys(params).length) {
      if (!config.method || config.method.toLowerCase() == "get") {
        config.method = "get";
        url += (url.includes("?") ? "&" : "?") + serializeParams(params);
      }
    }
  }

  return url;
}

function defaultLoaderPromise(url, config, params) {
  var contentType;
  return new Promise((resolve, reject) => {
    //set url
    url = this.urlGenerator.call(this.table, url, config, params); //set body content if not GET request

    if (config.method.toUpperCase() != "GET") {
      contentType = typeof this.table.options.ajaxContentType === "object" ? this.table.options.ajaxContentType : this.contentTypeFormatters[this.table.options.ajaxContentType];

      if (contentType) {
        for (var key in contentType.headers) {
          if (!config.headers) {
            config.headers = {};
          }

          if (typeof config.headers[key] === "undefined") {
            config.headers[key] = contentType.headers[key];
          }
        }

        config.body = contentType.body.call(this, url, config, params);
      } else {
        console.warn("Ajax Error - Invalid ajaxContentType value:", this.table.options.ajaxContentType);
      }
    }

    if (url) {
      //configure headers
      if (typeof config.headers === "undefined") {
        config.headers = {};
      }

      if (typeof config.headers.Accept === "undefined") {
        config.headers.Accept = "application/json";
      }

      if (typeof config.headers["X-Requested-With"] === "undefined") {
        config.headers["X-Requested-With"] = "XMLHttpRequest";
      }

      if (typeof config.mode === "undefined") {
        config.mode = "cors";
      }

      if (config.mode == "cors") {
        if (typeof config.headers["Origin"] === "undefined") {
          config.headers["Origin"] = window.location.origin;
        }

        if (typeof config.credentials === "undefined") {
          config.credentials = 'same-origin';
        }
      } else {
        if (typeof config.credentials === "undefined") {
          config.credentials = 'include';
        }
      } //send request


      fetch(url, config).then(response => {
        if (response.ok) {
          response.json().then(data => {
            resolve(data);
          }).catch(error => {
            reject(error);
            console.warn("Ajax Load Error - Invalid JSON returned", error);
          });
        } else {
          console.error("Ajax Load Error - Connection Error: " + response.status, response.statusText);
          reject(response);
        }
      }).catch(error => {
        console.error("Ajax Load Error - Connection Error: ", error);
        reject(error);
      });
    } else {
      console.warn("Ajax Load Error - No URL Set");
      resolve([]);
    }
  });
}

function generateParamsList$1(data, prefix) {
  var output = [];
  prefix = prefix || "";

  if (Array.isArray(data)) {
    data.forEach((item, i) => {
      output = output.concat(generateParamsList$1(item, prefix ? prefix + "[" + i + "]" : i));
    });
  } else if (typeof data === "object") {
    for (var key in data) {
      output = output.concat(generateParamsList$1(data[key], prefix ? prefix + "[" + key + "]" : key));
    }
  } else {
    output.push({
      key: prefix,
      value: data
    });
  }

  return output;
}

var defaultContentTypeFormatters = {
  "json": {
    headers: {
      'Content-Type': 'application/json'
    },
    body: function (url, config, params) {
      return JSON.stringify(params);
    }
  },
  "form": {
    headers: {},
    body: function (url, config, params) {
      var output = generateParamsList$1(params),
          form = new FormData();
      output.forEach(function (item) {
        form.append(item.key, item.value);
      });
      return form;
    }
  }
};

class Ajax extends Module {
  constructor(table) {
    super(table);
    this.config = {}; //hold config object for ajax request

    this.url = ""; //request URL

    this.urlGenerator = false;
    this.params = false; //request parameters

    this.loaderPromise = false;
    this.registerTableOption("ajaxURL", false); //url for ajax loading

    this.registerTableOption("ajaxURLGenerator", false);
    this.registerTableOption("ajaxParams", {}); //params for ajax loading

    this.registerTableOption("ajaxConfig", "get"); //ajax request type

    this.registerTableOption("ajaxContentType", "form"); //ajax request type

    this.registerTableOption("ajaxRequestFunc", false); //promise function

    this.registerTableOption("ajaxRequesting", function () {});
    this.registerTableOption("ajaxResponse", false);
    this.contentTypeFormatters = Ajax.contentTypeFormatters;
  } //initialize setup options


  initialize() {
    this.loaderPromise = this.table.options.ajaxRequestFunc || Ajax.defaultLoaderPromise;
    this.urlGenerator = this.table.options.ajaxURLGenerator || Ajax.defaultURLGenerator;

    if (this.table.options.ajaxURL) {
      this.setUrl(this.table.options.ajaxURL);
    }

    this.setDefaultConfig(this.table.options.ajaxConfig);
    this.registerTableFunction("getAjaxUrl", this.getUrl.bind(this));
    this.subscribe("data-loading", this.requestDataCheck.bind(this));
    this.subscribe("data-params", this.requestParams.bind(this));
    this.subscribe("data-load", this.requestData.bind(this));
  }

  requestParams(data, config, silent, params) {
    var ajaxParams = this.table.options.ajaxParams;

    if (ajaxParams) {
      if (typeof ajaxParams === "function") {
        ajaxParams = ajaxParams.call(this.table);
      }

      params = Object.assign(params, ajaxParams);
    }

    return params;
  }

  requestDataCheck(data, params, config, silent) {
    return !!(!data && this.url || typeof data === "string");
  }

  requestData(url, params, config, silent, previousData) {
    var ajaxConfig;

    if (!previousData && this.requestDataCheck(url)) {
      if (url) {
        this.setUrl(url);
      }

      ajaxConfig = this.generateConfig(config);
      return this.sendRequest(this.url, params, ajaxConfig);
    } else {
      return previousData;
    }
  }

  setDefaultConfig(config = {}) {
    this.config = Object.assign({}, Ajax.defaultConfig);

    if (typeof config == "string") {
      this.config.method = config;
    } else {
      Object.assign(this.config, config);
    }
  } //load config object


  generateConfig(config = {}) {
    var ajaxConfig = Object.assign({}, this.config);

    if (typeof config == "string") {
      ajaxConfig.method = config;
    } else {
      Object.assign(ajaxConfig, config);
    }

    return ajaxConfig;
  } //set request url


  setUrl(url) {
    this.url = url;
  } //get request url


  getUrl() {
    return this.url;
  } //send ajax request


  sendRequest(url, params, config) {
    if (this.table.options.ajaxRequesting.call(this.table, url, params) !== false) {
      return this.loaderPromise(url, config, params).then(data => {
        if (this.table.options.ajaxResponse) {
          data = this.table.options.ajaxResponse.call(this.table, url, params, data);
        }

        return data;
      });
    } else {
      return Promise.reject();
    }
  }

}

exports.AjaxModule = Ajax;
Ajax.moduleName = "ajax"; //load defaults

Ajax.defaultConfig = defaultConfig;
Ajax.defaultURLGenerator = urlBuilder;
Ajax.defaultLoaderPromise = defaultLoaderPromise;
Ajax.contentTypeFormatters = defaultContentTypeFormatters;
var defaultPasteActions = {
  replace: function (rows) {
    return this.table.setData(rows);
  },
  update: function (rows) {
    return this.table.updateOrAddData(rows);
  },
  insert: function (rows) {
    return this.table.addData(rows);
  }
};
var defaultPasteParsers = {
  table: function (clipboard) {
    var data = [],
        headerFindSuccess = true,
        columns = this.table.columnManager.columns,
        columnMap = [],
        rows = []; //get data from clipboard into array of columns and rows.

    clipboard = clipboard.split("\n");
    clipboard.forEach(function (row) {
      data.push(row.split("\t"));
    });

    if (data.length && !(data.length === 1 && data[0].length < 2)) {
      //check if headers are present by title
      data[0].forEach(function (value) {
        var column = columns.find(function (column) {
          return value && column.definition.title && value.trim() && column.definition.title.trim() === value.trim();
        });

        if (column) {
          columnMap.push(column);
        } else {
          headerFindSuccess = false;
        }
      }); //check if column headers are present by field

      if (!headerFindSuccess) {
        headerFindSuccess = true;
        columnMap = [];
        data[0].forEach(function (value) {
          var column = columns.find(function (column) {
            return value && column.field && value.trim() && column.field.trim() === value.trim();
          });

          if (column) {
            columnMap.push(column);
          } else {
            headerFindSuccess = false;
          }
        });

        if (!headerFindSuccess) {
          columnMap = this.table.columnManager.columnsByIndex;
        }
      } //remove header row if found


      if (headerFindSuccess) {
        data.shift();
      }

      data.forEach(function (item) {
        var row = {};
        item.forEach(function (value, i) {
          if (columnMap[i]) {
            row[columnMap[i].field] = value;
          }
        });
        rows.push(row);
      });
      return rows;
    } else {
      return false;
    }
  }
};

class Clipboard extends Module {
  constructor(table) {
    super(table);
    this.mode = true;

    this.pasteParser = function () {};

    this.pasteAction = function () {};

    this.customSelection = false;
    this.rowRange = false;
    this.blocked = true; //block copy actions not originating from this command

    this.registerTableOption("clipboard", false); //enable clipboard

    this.registerTableOption("clipboardCopyStyled", true); //formatted table data

    this.registerTableOption("clipboardCopyConfig", false); //clipboard config

    this.registerTableOption("clipboardCopyFormatter", false); //DEPRECATED - REMOVE in 5.0

    this.registerTableOption("clipboardCopyRowRange", "active"); //restrict clipboard to visible rows only

    this.registerTableOption("clipboardPasteParser", "table"); //convert pasted clipboard data to rows

    this.registerTableOption("clipboardPasteAction", "insert"); //how to insert pasted data into the table

    this.registerColumnOption("clipboard");
    this.registerColumnOption("titleClipboard");
  }

  initialize() {
    this.mode = this.table.options.clipboard;
    this.rowRange = this.table.options.clipboardCopyRowRange;

    if (this.mode === true || this.mode === "copy") {
      this.table.element.addEventListener("copy", e => {
        var plain, html, list;

        if (!this.blocked) {
          e.preventDefault();

          if (this.customSelection) {
            plain = this.customSelection;

            if (this.table.options.clipboardCopyFormatter) {
              plain = this.table.options.clipboardCopyFormatter("plain", plain);
            }
          } else {
            list = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard");
            html = this.table.modules.export.generateHTMLTable(list);
            plain = html ? this.generatePlainContent(list) : "";

            if (this.table.options.clipboardCopyFormatter) {
              plain = this.table.options.clipboardCopyFormatter("plain", plain);
              html = this.table.options.clipboardCopyFormatter("html", html);
            }
          }

          if (window.clipboardData && window.clipboardData.setData) {
            window.clipboardData.setData('Text', plain);
          } else if (e.clipboardData && e.clipboardData.setData) {
            e.clipboardData.setData('text/plain', plain);

            if (html) {
              e.clipboardData.setData('text/html', html);
            }
          } else if (e.originalEvent && e.originalEvent.clipboardData.setData) {
            e.originalEvent.clipboardData.setData('text/plain', plain);

            if (html) {
              e.originalEvent.clipboardData.setData('text/html', html);
            }
          }

          this.dispatchExternal("clipboardCopied", plain, html);
          this.reset();
        }
      });
    }

    if (this.mode === true || this.mode === "paste") {
      this.table.element.addEventListener("paste", e => {
        this.paste(e);
      });
    }

    this.setPasteParser(this.table.options.clipboardPasteParser);
    this.setPasteAction(this.table.options.clipboardPasteAction);
    this.registerTableFunction("copyToClipboard", this.copy.bind(this));
  }

  reset() {
    this.blocked = true;
    this.customSelection = false;
  }

  generatePlainContent(list) {
    var output = [];
    list.forEach(row => {
      var rowData = [];
      row.columns.forEach(col => {
        var value = "";

        if (col) {
          if (row.type === "group") {
            col.value = col.component.getKey();
          }

          if (col.value === null) {
            value = "";
          } else {
            switch (typeof col.value) {
              case "object":
                value = JSON.stringify(col.value);
                break;

              case "undefined":
                value = "";
                break;

              default:
                value = col.value;
            }
          }
        }

        rowData.push(value);
      });
      output.push(rowData.join("\t"));
    });
    return output.join("\n");
  }

  copy(range, internal) {
    var sel, textRange;
    this.blocked = false;
    this.customSelection = false;

    if (this.mode === true || this.mode === "copy") {
      this.rowRange = range || this.table.options.clipboardCopyRowRange;

      if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
        range = document.createRange();
        range.selectNodeContents(this.table.element);
        sel = window.getSelection();

        if (sel.toString() && internal) {
          this.customSelection = sel.toString();
        }

        sel.removeAllRanges();
        sel.addRange(range);
      } else if (typeof document.selection != "undefined" && typeof document.body.createTextRange != "undefined") {
        textRange = document.body.createTextRange();
        textRange.moveToElementText(this.table.element);
        textRange.select();
      }

      document.execCommand('copy');

      if (sel) {
        sel.removeAllRanges();
      }
    }
  } //PASTE EVENT HANDLING


  setPasteAction(action) {
    switch (typeof action) {
      case "string":
        this.pasteAction = Clipboard.pasteActions[action];

        if (!this.pasteAction) {
          console.warn("Clipboard Error - No such paste action found:", action);
        }

        break;

      case "function":
        this.pasteAction = action;
        break;
    }
  }

  setPasteParser(parser) {
    switch (typeof parser) {
      case "string":
        this.pasteParser = Clipboard.pasteParsers[parser];

        if (!this.pasteParser) {
          console.warn("Clipboard Error - No such paste parser found:", parser);
        }

        break;

      case "function":
        this.pasteParser = parser;
        break;
    }
  }

  paste(e) {
    var data, rowData, rows;

    if (this.checkPaseOrigin(e)) {
      data = this.getPasteData(e);
      rowData = this.pasteParser.call(this, data);

      if (rowData) {
        e.preventDefault();

        if (this.table.modExists("mutator")) {
          rowData = this.mutateData(rowData);
        }

        rows = this.pasteAction.call(this, rowData);
        this.dispatchExternal("clipboardPasted", data, rowData, rows);
      } else {
        this.dispatchExternal("clipboardPasteError", data);
      }
    }
  }

  mutateData(data) {
    var output = [];

    if (Array.isArray(data)) {
      data.forEach(row => {
        output.push(this.table.modules.mutator.transformRow(row, "clipboard"));
      });
    } else {
      output = data;
    }

    return output;
  }

  checkPaseOrigin(e) {
    var valid = true;

    if (e.target.tagName != "DIV" || this.table.modules.edit.currentCell) {
      valid = false;
    }

    return valid;
  }

  getPasteData(e) {
    var data;

    if (window.clipboardData && window.clipboardData.getData) {
      data = window.clipboardData.getData('Text');
    } else if (e.clipboardData && e.clipboardData.getData) {
      data = e.clipboardData.getData('text/plain');
    } else if (e.originalEvent && e.originalEvent.clipboardData.getData) {
      data = e.originalEvent.clipboardData.getData('text/plain');
    }

    return data;
  }

}

exports.ClipboardModule = Clipboard;
Clipboard.moduleName = "clipboard"; //load defaults

Clipboard.pasteActions = defaultPasteActions;
Clipboard.pasteParsers = defaultPasteParsers;

class CalcComponent {
  constructor(row) {
    this._row = row;
    return new Proxy(this, {
      get: function (target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._row.table.componentFunctionBinder.handle("row", target._row, name);
        }
      }
    });
  }

  getData(transform) {
    return this._row.getData(transform);
  }

  getElement() {
    return this._row.getElement();
  }

  getTable() {
    return this._row.table;
  }

  getCells() {
    var cells = [];

    this._row.getCells().forEach(function (cell) {
      cells.push(cell.getComponent());
    });

    return cells;
  }

  getCell(column) {
    var cell = this._row.getCell(column);

    return cell ? cell.getComponent() : false;
  }

  _getSelf() {
    return this._row;
  }

} //public cell object


exports.CalcComponent = CalcComponent;

class CellComponent {
  constructor(cell) {
    this._cell = cell;
    return new Proxy(this, {
      get: function (target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._cell.table.componentFunctionBinder.handle("cell", target._cell, name);
        }
      }
    });
  }

  getValue() {
    return this._cell.getValue();
  }

  getOldValue() {
    return this._cell.getOldValue();
  }

  getInitialValue() {
    return this._cell.initialValue;
  }

  getElement() {
    return this._cell.getElement();
  }

  getRow() {
    return this._cell.row.getComponent();
  }

  getData() {
    return this._cell.row.getData();
  }

  getField() {
    return this._cell.column.getField();
  }

  getColumn() {
    return this._cell.column.getComponent();
  }

  setValue(value, mutate) {
    if (typeof mutate == "undefined") {
      mutate = true;
    }

    this._cell.setValue(value, mutate);
  }

  restoreOldValue() {
    this._cell.setValueActual(this._cell.getOldValue());
  }

  restoreInitialValue() {
    this._cell.setValueActual(this._cell.initialValue);
  }

  checkHeight() {
    this._cell.checkHeight();
  }

  getTable() {
    return this._cell.table;
  }

  _getSelf() {
    return this._cell;
  }

}

exports.CellComponent = CellComponent;

class Cell extends CoreFeature {
  constructor(column, row) {
    super(column.table);
    this.table = column.table;
    this.column = column;
    this.row = row;
    this.element = null;
    this.value = null;
    this.initialValue;
    this.oldValue = null;
    this.modules = {};
    this.height = null;
    this.width = null;
    this.minWidth = null;
    this.component = null;
    this.loaded = false; //track if the cell has been added to the DOM yet

    this.build();
  } //////////////// Setup Functions /////////////////
  //generate element


  build() {
    this.generateElement();
    this.setWidth();

    this._configureCell();

    this.setValueActual(this.column.getFieldValue(this.row.data));
    this.initialValue = this.value;
  }

  generateElement() {
    this.element = document.createElement('div');
    this.element.className = "tabulator-cell";
    this.element.setAttribute("role", "gridcell");
  }

  _configureCell() {
    var element = this.element,
        field = this.column.getField(),
        vertAligns = {
      top: "flex-start",
      bottom: "flex-end",
      middle: "center"
    },
        hozAligns = {
      left: "flex-start",
      right: "flex-end",
      center: "center"
    }; //set text alignment

    element.style.textAlign = this.column.hozAlign;

    if (this.column.vertAlign) {
      element.style.display = "inline-flex";
      element.style.alignItems = vertAligns[this.column.vertAlign] || "";

      if (this.column.hozAlign) {
        element.style.justifyContent = hozAligns[this.column.hozAlign] || "";
      }
    }

    if (field) {
      element.setAttribute("tabulator-field", field);
    } //add class to cell if needed


    if (this.column.definition.cssClass) {
      var classNames = this.column.definition.cssClass.split(" ");
      classNames.forEach(className => {
        element.classList.add(className);
      });
    }

    this.dispatch("cell-init", this); //hide cell if not visible

    if (!this.column.visible) {
      this.hide();
    }
  } //generate cell contents


  _generateContents() {
    var val;
    val = this.chain("cell-format", this, null, () => {
      return this.element.innerHTML = this.value;
    });

    switch (typeof val) {
      case "object":
        if (val instanceof Node) {
          //clear previous cell contents
          while (this.element.firstChild) this.element.removeChild(this.element.firstChild);

          this.element.appendChild(val);
        } else {
          this.element.innerHTML = "";

          if (val != null) {
            console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", val);
          }
        }

        break;

      case "undefined":
        this.element.innerHTML = "";
        break;

      default:
        this.element.innerHTML = val;
    }
  }

  cellRendered() {
    this.dispatch("cell-rendered", this);
  } //////////////////// Getters ////////////////////


  getElement(containerOnly) {
    if (!this.loaded) {
      this.loaded = true;

      if (!containerOnly) {
        this.layoutElement();
      }
    }

    return this.element;
  }

  getValue() {
    return this.value;
  }

  getOldValue() {
    return this.oldValue;
  } //////////////////// Actions ////////////////////


  setValue(value, mutate, force) {
    var changed = this.setValueProcessData(value, mutate, force);

    if (changed) {
      this.dispatch("cell-value-updated", this);
      this.cellRendered();

      if (this.column.definition.cellEdited) {
        this.column.definition.cellEdited.call(this.table, this.getComponent());
      }

      this.dispatchExternal("cellEdited", this.getComponent());

      if (this.subscribedExternal("dataChanged")) {
        this.dispatchExternal("dataChanged", this.table.rowManager.getData());
      }
    }
  }

  setValueProcessData(value, mutate, force) {
    var changed = false;

    if (this.value !== value || force) {
      changed = true;

      if (mutate) {
        value = this.chain("cell-value-changing", [this, value], null, value);
      }
    }

    this.setValueActual(value);

    if (changed) {
      this.dispatch("cell-value-changed", this);
    }

    return changed;
  }

  setValueActual(value) {
    this.oldValue = this.value;
    this.value = value;
    this.dispatch("cell-value-save-before", this);
    this.column.setFieldValue(this.row.data, value);
    this.dispatch("cell-value-save-after", this);

    if (this.loaded) {
      this.layoutElement();
    }
  }

  layoutElement() {
    this._generateContents();

    this.dispatch("cell-layout", this);
  }

  setWidth() {
    this.width = this.column.width;
    this.element.style.width = this.column.widthStyled;
  }

  clearWidth() {
    this.width = "";
    this.element.style.width = "";
  }

  getWidth() {
    return this.width || this.element.offsetWidth;
  }

  setMinWidth() {
    this.minWidth = this.column.minWidth;
    this.element.style.minWidth = this.column.minWidthStyled;
  }

  setMaxWidth() {
    this.maxWidth = this.column.maxWidth;
    this.element.style.maxWidth = this.column.maxWidthStyled;
  }

  checkHeight() {
    // var height = this.element.css("height");
    this.row.reinitializeHeight();
  }

  clearHeight() {
    this.element.style.height = "";
    this.height = null;
    this.dispatch("cell-height", this, "");
  }

  setHeight() {
    this.height = this.row.height;
    this.element.style.height = this.row.heightStyled;
    this.dispatch("cell-height", this, this.row.heightStyled);
  }

  getHeight() {
    return this.height || this.element.offsetHeight;
  }

  show() {
    this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
  }

  hide() {
    this.element.style.display = "none";
  }

  delete() {
    this.dispatch("cell-delete", this);

    if (!this.table.rowManager.redrawBlock && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }

    this.element = false;
    this.column.deleteCell(this);
    this.row.deleteCell(this);
    this.calcs = {};
  }

  getIndex() {
    return this.row.getCellIndex(this);
  } //////////////// Object Generation /////////////////


  getComponent() {
    if (!this.component) {
      this.component = new CellComponent(this);
    }

    return this.component;
  }

} //public column object


class ColumnComponent {
  constructor(column) {
    this._column = column;
    this.type = "ColumnComponent";
    return new Proxy(this, {
      get: function (target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._column.table.componentFunctionBinder.handle("column", target._column, name);
        }
      }
    });
  }

  getElement() {
    return this._column.getElement();
  }

  getDefinition() {
    return this._column.getDefinition();
  }

  getField() {
    return this._column.getField();
  }

  getTitleDownload() {
    return this._column.getTitleDownload();
  }

  getCells() {
    var cells = [];

    this._column.cells.forEach(function (cell) {
      cells.push(cell.getComponent());
    });

    return cells;
  }

  isVisible() {
    return this._column.visible;
  }

  show() {
    if (this._column.isGroup) {
      this._column.columns.forEach(function (column) {
        column.show();
      });
    } else {
      this._column.show();
    }
  }

  hide() {
    if (this._column.isGroup) {
      this._column.columns.forEach(function (column) {
        column.hide();
      });
    } else {
      this._column.hide();
    }
  }

  toggle() {
    if (this._column.visible) {
      this.hide();
    } else {
      this.show();
    }
  }

  delete() {
    return this._column.delete();
  }

  getSubColumns() {
    var output = [];

    if (this._column.columns.length) {
      this._column.columns.forEach(function (column) {
        output.push(column.getComponent());
      });
    }

    return output;
  }

  getParentColumn() {
    return this._column.parent instanceof Column ? this._column.parent.getComponent() : false;
  }

  _getSelf() {
    return this._column;
  }

  scrollTo() {
    return this._column.table.columnManager.scrollToColumn(this._column);
  }

  getTable() {
    return this._column.table;
  }

  move(to, after) {
    var toColumn = this._column.table.columnManager.findColumn(to);

    if (toColumn) {
      this._column.table.columnManager.moveColumn(this._column, toColumn, after);
    } else {
      console.warn("Move Error - No matching column found:", toColumn);
    }
  }

  getNextColumn() {
    var nextCol = this._column.nextColumn();

    return nextCol ? nextCol.getComponent() : false;
  }

  getPrevColumn() {
    var prevCol = this._column.prevColumn();

    return prevCol ? prevCol.getComponent() : false;
  }

  updateDefinition(updates) {
    return this._column.updateDefinition(updates);
  }

  getWidth() {
    return this._column.getWidth();
  }

  setWidth(width) {
    var result;

    if (width === true) {
      result = this._column.reinitializeWidth(true);
    } else {
      result = this._column.setWidth(width);
    }

    this._column.table.columnManager.rerenderColumns(true);

    return result;
  }

}

exports.ColumnComponent = ColumnComponent;
var defaultColumnOptions = {
  "title": undefined,
  "field": undefined,
  "columns": undefined,
  "visible": undefined,
  "hozAlign": undefined,
  "vertAlign": undefined,
  "width": undefined,
  "minWidth": 40,
  "maxWidth": undefined,
  "maxInitialWidth": undefined,
  "cssClass": undefined,
  "variableHeight": undefined,
  "headerVertical": undefined,
  "headerHozAlign": undefined,
  "editableTitle": undefined
};

class Column extends CoreFeature {
  constructor(def, parent) {
    super(parent.table);
    this.definition = def; //column definition

    this.parent = parent; //hold parent object

    this.type = "column"; //type of element

    this.columns = []; //child columns

    this.cells = []; //cells bound to this column

    this.element = this.createElement(); //column header element

    this.contentElement = false;
    this.titleHolderElement = false;
    this.titleElement = false;
    this.groupElement = this.createGroupElement(); //column group holder element

    this.isGroup = false;
    this.hozAlign = ""; //horizontal text alignment

    this.vertAlign = ""; //vert text alignment
    //multi dimensional filed handling

    this.field = "";
    this.fieldStructure = "";
    this.getFieldValue = "";
    this.setFieldValue = "";
    this.titleDownload = null;
    this.titleFormatterRendered = false;
    this.mapDefinitions();
    this.setField(this.definition.field);
    this.modules = {}; //hold module variables;

    this.width = null; //column width

    this.widthStyled = ""; //column width pre-styled to improve render efficiency

    this.maxWidth = null; //column maximum width

    this.maxWidthStyled = ""; //column maximum pre-styled to improve render efficiency

    this.maxInitialWidth = null;
    this.minWidth = null; //column minimum width

    this.minWidthStyled = ""; //column minimum pre-styled to improve render efficiency

    this.widthFixed = false; //user has specified a width for this column

    this.visible = true; //default visible state

    this.component = null; //initialize column

    if (this.definition.columns) {
      this.isGroup = true;
      this.definition.columns.forEach((def, i) => {
        var newCol = new Column(def, this);
        this.attachColumn(newCol);
      });
      this.checkColumnVisibility();
    } else {
      parent.registerColumnField(this);
    }

    this._initialize();
  }

  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col");
    el.setAttribute("role", "columnheader");
    el.setAttribute("aria-sort", "none");

    switch (this.table.options.columnHeaderVertAlign) {
      case "middle":
        el.style.justifyContent = "center";
        break;

      case "bottom":
        el.style.justifyContent = "flex-end";
        break;
    }

    return el;
  }

  createGroupElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col-group-cols");
    return el;
  }

  mapDefinitions() {
    var defaults = this.table.options.columnDefaults; //map columnDefaults onto column definitions

    if (defaults) {
      for (let key in defaults) {
        if (typeof this.definition[key] === "undefined") {
          this.definition[key] = defaults[key];
        }
      }
    }

    this.definition = this.table.columnManager.optionsList.generate(Column.defaultOptionList, this.definition);
  }

  checkDefinition() {
    Object.keys(this.definition).forEach(key => {
      if (Column.defaultOptionList.indexOf(key) === -1) {
        console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", key);
      }
    });
  }

  setField(field) {
    this.field = field;
    this.fieldStructure = field ? this.table.options.nestedFieldSeparator ? field.split(this.table.options.nestedFieldSeparator) : [field] : [];
    this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData;
    this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
  } //register column position with column manager


  registerColumnPosition(column) {
    this.parent.registerColumnPosition(column);
  } //register column position with column manager


  registerColumnField(column) {
    this.parent.registerColumnField(column);
  } //trigger position registration


  reRegisterPosition() {
    if (this.isGroup) {
      this.columns.forEach(function (column) {
        column.reRegisterPosition();
      });
    } else {
      this.registerColumnPosition(this);
    }
  } //build header element


  _initialize() {
    var def = this.definition;

    while (this.element.firstChild) this.element.removeChild(this.element.firstChild);

    if (def.headerVertical) {
      this.element.classList.add("tabulator-col-vertical");

      if (def.headerVertical === "flip") {
        this.element.classList.add("tabulator-col-vertical-flip");
      }
    }

    this.contentElement = this._buildColumnHeaderContent();
    this.element.appendChild(this.contentElement);

    if (this.isGroup) {
      this._buildGroupHeader();
    } else {
      this._buildColumnHeader();
    }

    this.dispatch("column-init", this);
  } //build header element for header


  _buildColumnHeader() {
    var def = this.definition;
    this.dispatch("column-layout", this); //set column visibility

    if (typeof def.visible != "undefined") {
      if (def.visible) {
        this.show(true);
      } else {
        this.hide(true);
      }
    } //assign additional css classes to column header


    if (def.cssClass) {
      var classNames = def.cssClass.split(" ");
      classNames.forEach(className => {
        this.element.classList.add(className);
      });
    }

    if (def.field) {
      this.element.setAttribute("tabulator-field", def.field);
    } //set min width if present


    this.setMinWidth(parseInt(def.minWidth));

    if (def.maxInitialWidth) {
      this.maxInitialWidth = parseInt(def.maxInitialWidth);
    }

    if (def.maxWidth) {
      this.setMaxWidth(parseInt(def.maxWidth));
    }

    this.reinitializeWidth(); //set horizontal text alignment

    this.hozAlign = this.definition.hozAlign;
    this.vertAlign = this.definition.vertAlign;
    this.titleElement.style.textAlign = this.definition.headerHozAlign;
  }

  _buildColumnHeaderContent() {
    var contentElement = document.createElement("div");
    contentElement.classList.add("tabulator-col-content");
    this.titleHolderElement = document.createElement("div");
    this.titleHolderElement.classList.add("tabulator-col-title-holder");
    contentElement.appendChild(this.titleHolderElement);
    this.titleElement = this._buildColumnHeaderTitle();
    this.titleHolderElement.appendChild(this.titleElement);
    return contentElement;
  } //build title element of column


  _buildColumnHeaderTitle() {
    var def = this.definition;
    var titleHolderElement = document.createElement("div");
    titleHolderElement.classList.add("tabulator-col-title");

    if (def.editableTitle) {
      var titleElement = document.createElement("input");
      titleElement.classList.add("tabulator-title-editor");
      titleElement.addEventListener("click", e => {
        e.stopPropagation();
        titleElement.focus();
      });
      titleElement.addEventListener("change", () => {
        def.title = titleElement.value;
        this.dispatchExternal("columnTitleChanged", this.getComponent());
      });
      titleHolderElement.appendChild(titleElement);

      if (def.field) {
        this.langBind("columns|" + def.field, text => {
          titleElement.value = text || def.title || "&nbsp;";
        });
      } else {
        titleElement.value = def.title || "&nbsp;";
      }
    } else {
      if (def.field) {
        this.langBind("columns|" + def.field, text => {
          this._formatColumnHeaderTitle(titleHolderElement, text || def.title || "&nbsp;");
        });
      } else {
        this._formatColumnHeaderTitle(titleHolderElement, def.title || "&nbsp;");
      }
    }

    return titleHolderElement;
  }

  _formatColumnHeaderTitle(el, title) {
    var contents = this.chain("column-format", [this, title, el], null, () => {
      return title;
    });

    switch (typeof contents) {
      case "object":
        if (contents instanceof Node) {
          el.appendChild(contents);
        } else {
          el.innerHTML = "";
          console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", contents);
        }

        break;

      case "undefined":
        el.innerHTML = "";
        break;

      default:
        el.innerHTML = contents;
    }
  } //build header element for column group


  _buildGroupHeader() {
    this.element.classList.add("tabulator-col-group");
    this.element.setAttribute("role", "columngroup");
    this.element.setAttribute("aria-title", this.definition.title); //asign additional css classes to column header

    if (this.definition.cssClass) {
      var classNames = this.definition.cssClass.split(" ");
      classNames.forEach(className => {
        this.element.classList.add(className);
      });
    }

    this.titleElement.style.textAlign = this.definition.headerHozAlign;
    this.element.appendChild(this.groupElement);
  } //flat field lookup


  _getFlatData(data) {
    return data[this.field];
  } //nested field lookup


  _getNestedData(data) {
    var dataObj = data,
        structure = this.fieldStructure,
        length = structure.length,
        output;

    for (let i = 0; i < length; i++) {
      dataObj = dataObj[structure[i]];
      output = dataObj;

      if (!dataObj) {
        break;
      }
    }

    return output;
  } //flat field set


  _setFlatData(data, value) {
    if (this.field) {
      data[this.field] = value;
    }
  } //nested field set


  _setNestedData(data, value) {
    var dataObj = data,
        structure = this.fieldStructure,
        length = structure.length;

    for (let i = 0; i < length; i++) {
      if (i == length - 1) {
        dataObj[structure[i]] = value;
      } else {
        if (!dataObj[structure[i]]) {
          if (typeof value !== "undefined") {
            dataObj[structure[i]] = {};
          } else {
            break;
          }
        }

        dataObj = dataObj[structure[i]];
      }
    }
  } //attach column to this group


  attachColumn(column) {
    if (this.groupElement) {
      this.columns.push(column);
      this.groupElement.appendChild(column.getElement());
      column.columnRendered();
    } else {
      console.warn("Column Warning - Column being attached to another column instead of column group");
    }
  } //vertically align header in column


  verticalAlign(alignment, height) {
    //calculate height of column header and group holder element
    var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : height || this.parent.getHeadersElement().clientHeight; // var parentHeight = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : this.parent.getHeadersElement().clientHeight;

    this.element.style.height = parentHeight + "px";
    this.dispatch("column-height", this, this.element.style.height);

    if (this.isGroup) {
      this.groupElement.style.minHeight = parentHeight - this.contentElement.offsetHeight + "px";
    } //vertically align cell contents
    // if(!this.isGroup && alignment !== "top"){
    // 	if(alignment === "bottom"){
    // 		this.element.style.paddingTop = (this.element.clientHeight - this.contentElement.offsetHeight) + "px";
    // 	}else{
    // 		this.element.style.paddingTop = ((this.element.clientHeight - this.contentElement.offsetHeight) / 2) + "px";
    // 	}
    // }


    this.columns.forEach(function (column) {
      column.verticalAlign(alignment);
    });
  } //clear vertical alignment


  clearVerticalAlign() {
    this.element.style.paddingTop = "";
    this.element.style.height = "";
    this.element.style.minHeight = "";
    this.groupElement.style.minHeight = "";
    this.columns.forEach(function (column) {
      column.clearVerticalAlign();
    });
    this.dispatch("column-height", this, "");
  } //// Retrieve Column Information ////
  //return column header element


  getElement() {
    return this.element;
  } //return column group element


  getGroupElement() {
    return this.groupElement;
  } //return field name


  getField() {
    return this.field;
  }

  getTitleDownload() {
    return this.titleDownload;
  } //return the first column in a group


  getFirstColumn() {
    if (!this.isGroup) {
      return this;
    } else {
      if (this.columns.length) {
        return this.columns[0].getFirstColumn();
      } else {
        return false;
      }
    }
  } //return the last column in a group


  getLastColumn() {
    if (!this.isGroup) {
      return this;
    } else {
      if (this.columns.length) {
        return this.columns[this.columns.length - 1].getLastColumn();
      } else {
        return false;
      }
    }
  } //return all columns in a group


  getColumns(traverse) {
    var columns = [];

    if (traverse) {
      this.columns.forEach(column => {
        columns.push(column);
        columns = columns.concat(column.getColumns(true));
      });
    } else {
      columns = this.columns;
    }

    return columns;
  } //return all columns in a group


  getCells() {
    return this.cells;
  } //retrieve the top column in a group of columns


  getTopColumn() {
    if (this.parent.isGroup) {
      return this.parent.getTopColumn();
    } else {
      return this;
    }
  } //return column definition object


  getDefinition(updateBranches) {
    var colDefs = [];

    if (this.isGroup && updateBranches) {
      this.columns.forEach(function (column) {
        colDefs.push(column.getDefinition(true));
      });
      this.definition.columns = colDefs;
    }

    return this.definition;
  } //////////////////// Actions ////////////////////


  checkColumnVisibility() {
    var visible = false;
    this.columns.forEach(function (column) {
      if (column.visible) {
        visible = true;
      }
    });

    if (visible) {
      this.show();
      this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
    } else {
      this.hide();
    }
  } //show column


  show(silent, responsiveToggle) {
    if (!this.visible) {
      this.visible = true;
      this.element.style.display = "";

      if (this.parent.isGroup) {
        this.parent.checkColumnVisibility();
      }

      this.cells.forEach(function (cell) {
        cell.show();
      });

      if (!this.isGroup && this.width === null) {
        this.reinitializeWidth();
      }

      this.table.columnManager.verticalAlignHeaders();
      this.dispatch("column-show", this, responsiveToggle);

      if (!silent) {
        this.dispatchExternal("columnVisibilityChanged", this.getComponent(), true);
      }

      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }

      if (!this.silent) {
        this.table.columnManager.rerenderColumns();
      }
    }
  } //hide column


  hide(silent, responsiveToggle) {
    if (this.visible) {
      this.visible = false;
      this.element.style.display = "none";
      this.table.columnManager.verticalAlignHeaders();

      if (this.parent.isGroup) {
        this.parent.checkColumnVisibility();
      }

      this.cells.forEach(function (cell) {
        cell.hide();
      });
      this.dispatch("column-hide", this, responsiveToggle);

      if (!silent) {
        this.dispatchExternal("columnVisibilityChanged", this.getComponent(), false);
      }

      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }

      if (!this.silent) {
        this.table.columnManager.rerenderColumns();
      }
    }
  }

  matchChildWidths() {
    var childWidth = 0;

    if (this.contentElement && this.columns.length) {
      this.columns.forEach(function (column) {
        if (column.visible) {
          childWidth += column.getWidth();
        }
      });
      this.contentElement.style.maxWidth = childWidth - 1 + "px";

      if (this.parent.isGroup) {
        this.parent.matchChildWidths();
      }
    }
  }

  removeChild(child) {
    var index = this.columns.indexOf(child);

    if (index > -1) {
      this.columns.splice(index, 1);
    }

    if (!this.columns.length) {
      this.delete();
    }
  }

  setWidth(width) {
    this.widthFixed = true;
    this.setWidthActual(width);
  }

  setWidthActual(width) {
    if (isNaN(width)) {
      width = Math.floor(this.table.element.clientWidth / 100 * parseInt(width));
    }

    width = Math.max(this.minWidth, width);

    if (this.maxWidth) {
      width = Math.min(this.maxWidth, width);
    }

    this.width = width;
    this.widthStyled = width ? width + "px" : "";
    this.element.style.width = this.widthStyled;

    if (!this.isGroup) {
      this.cells.forEach(function (cell) {
        cell.setWidth();
      });
    }

    if (this.parent.isGroup) {
      this.parent.matchChildWidths();
    }

    this.dispatch("column-width", this);
  }

  checkCellHeights() {
    var rows = [];
    this.cells.forEach(function (cell) {
      if (cell.row.heightInitialized) {
        if (cell.row.getElement().offsetParent !== null) {
          rows.push(cell.row);
          cell.row.clearCellHeight();
        } else {
          cell.row.heightInitialized = false;
        }
      }
    });
    rows.forEach(function (row) {
      row.calcHeight();
    });
    rows.forEach(function (row) {
      row.setCellHeight();
    });
  }

  getWidth() {
    var width = 0;

    if (this.isGroup) {
      this.columns.forEach(function (column) {
        if (column.visible) {
          width += column.getWidth();
        }
      });
    } else {
      width = this.width;
    }

    return width;
  }

  getHeight() {
    return Math.ceil(this.element.getBoundingClientRect().height);
  }

  setMinWidth(minWidth) {
    if (this.maxWidth && minWidth > this.maxWidth) {
      minWidth = this.maxWidth;
      console.warn("the minWidth (" + minWidth + "px) for column '" + this.field + "' cannot be bigger that its maxWidth (" + this.maxWidthStyled + ")");
    }

    this.minWidth = minWidth;
    this.minWidthStyled = minWidth ? minWidth + "px" : "";
    this.element.style.minWidth = this.minWidthStyled;
    this.cells.forEach(function (cell) {
      cell.setMinWidth();
    });
  }

  setMaxWidth(maxWidth) {
    if (this.minWidth && maxWidth < this.minWidth) {
      maxWidth = this.minWidth;
      console.warn("the maxWidth (" + maxWidth + "px) for column '" + this.field + "' cannot be smaller that its minWidth (" + this.minWidthStyled + ")");
    }

    this.maxWidth = maxWidth;
    this.maxWidthStyled = maxWidth ? maxWidth + "px" : "";
    this.element.style.maxWidth = this.maxWidthStyled;
    this.cells.forEach(function (cell) {
      cell.setMaxWidth();
    });
  }

  delete() {
    return new Promise((resolve, reject) => {
      if (this.isGroup) {
        this.columns.forEach(function (column) {
          column.delete();
        });
      }

      this.dispatch("column-delete", this);
      var cellCount = this.cells.length;

      for (let i = 0; i < cellCount; i++) {
        this.cells[0].delete();
      }

      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }

      this.element = false;
      this.contentElement = false;
      this.titleElement = false;
      this.groupElement = false;

      if (this.parent.isGroup) {
        this.parent.removeChild(this);
      }

      this.table.columnManager.deregisterColumn(this);
      this.table.columnManager.rerenderColumns(true);
      resolve();
    });
  }

  columnRendered() {
    if (this.titleFormatterRendered) {
      this.titleFormatterRendered();
    }

    this.dispatch("column-rendered", this);
  } //////////////// Cell Management /////////////////
  //generate cell for this column


  generateCell(row) {
    var cell = new Cell(this, row);
    this.cells.push(cell);
    return cell;
  }

  nextColumn() {
    var index = this.table.columnManager.findColumnIndex(this);
    return index > -1 ? this._nextVisibleColumn(index + 1) : false;
  }

  _nextVisibleColumn(index) {
    var column = this.table.columnManager.getColumnByIndex(index);
    return !column || column.visible ? column : this._nextVisibleColumn(index + 1);
  }

  prevColumn() {
    var index = this.table.columnManager.findColumnIndex(this);
    return index > -1 ? this._prevVisibleColumn(index - 1) : false;
  }

  _prevVisibleColumn(index) {
    var column = this.table.columnManager.getColumnByIndex(index);
    return !column || column.visible ? column : this._prevVisibleColumn(index - 1);
  }

  reinitializeWidth(force) {
    this.widthFixed = false; //set width if present

    if (typeof this.definition.width !== "undefined" && !force) {
      // maxInitialWidth ignored here as width specified
      this.setWidth(this.definition.width);
    }

    this.dispatch("column-width-fit-before", this);
    this.fitToData(force);
    this.dispatch("column-width-fit-after", this);
  } //set column width to maximum cell width for non group columns


  fitToData(force) {
    if (this.isGroup) {
      return;
    }

    if (!this.widthFixed) {
      this.element.style.width = "";
      this.cells.forEach(cell => {
        cell.clearWidth();
      });
    }

    var maxWidth = this.element.offsetWidth;

    if (!this.width || !this.widthFixed) {
      this.cells.forEach(cell => {
        var width = cell.getWidth();

        if (width > maxWidth) {
          maxWidth = width;
        }
      });

      if (maxWidth) {
        var setTo = maxWidth + 1;

        if (this.maxInitialWidth && !force) {
          setTo = Math.min(setTo, this.maxInitialWidth);
        }

        this.setWidthActual(setTo);
      }
    }
  }

  updateDefinition(updates) {
    var definition;

    if (!this.isGroup) {
      if (!this.parent.isGroup) {
        definition = Object.assign({}, this.getDefinition());
        definition = Object.assign(definition, updates);
        return this.table.columnManager.addColumn(definition, false, this).then(column => {
          if (definition.field == this.field) {
            this.field = false; //clear field name to prevent deletion of duplicate column from arrays
          }

          return this.delete().then(() => {
            return column.getComponent();
          });
        });
      } else {
        console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
        return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
      }
    } else {
      console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns");
      return Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups");
    }
  }

  deleteCell(cell) {
    var index = this.cells.indexOf(cell);

    if (index > -1) {
      this.cells.splice(index, 1);
    }
  } //////////////// Object Generation /////////////////


  getComponent() {
    if (!this.component) {
      this.component = new ColumnComponent(this);
    }

    return this.component;
  }

}

Column.defaultOptionList = defaultColumnOptions; //public row object

class RowComponent {
  constructor(row) {
    this._row = row;
    return new Proxy(this, {
      get: function (target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._row.table.componentFunctionBinder.handle("row", target._row, name);
        }
      }
    });
  }

  getData(transform) {
    return this._row.getData(transform);
  }

  getElement() {
    return this._row.getElement();
  }

  getCells() {
    var cells = [];

    this._row.getCells().forEach(function (cell) {
      cells.push(cell.getComponent());
    });

    return cells;
  }

  getCell(column) {
    var cell = this._row.getCell(column);

    return cell ? cell.getComponent() : false;
  }

  getIndex() {
    return this._row.getData("data")[this._row.table.options.index];
  }

  getPosition() {
    return this._row.getPosition();
  }

  watchPosition(callback) {
    return this._row.watchPosition(callback);
  }

  delete() {
    return this._row.delete();
  }

  scrollTo() {
    return this._row.table.rowManager.scrollToRow(this._row);
  }

  move(to, after) {
    this._row.moveToRow(to, after);
  }

  update(data) {
    return this._row.updateData(data);
  }

  normalizeHeight() {
    this._row.normalizeHeight(true);
  }

  _getSelf() {
    return this._row;
  }

  reformat() {
    return this._row.reinitialize();
  }

  getTable() {
    return this._row.table;
  }

  getNextRow() {
    var row = this._row.nextRow();

    return row ? row.getComponent() : row;
  }

  getPrevRow() {
    var row = this._row.prevRow();

    return row ? row.getComponent() : row;
  }

}

exports.RowComponent = RowComponent;

class Row extends CoreFeature {
  constructor(data, parent, type = "row") {
    super(parent.table);
    this.parent = parent;
    this.data = {};
    this.type = type; //type of element

    this.element = false;
    this.modules = {}; //hold module variables;

    this.cells = [];
    this.height = 0; //hold element height

    this.heightStyled = ""; //hold element height pre-styled to improve render efficiency

    this.manualHeight = false; //user has manually set row height

    this.outerHeight = 0; //hold elements outer height

    this.initialized = false; //element has been rendered

    this.heightInitialized = false; //element has resized cells to fit

    this.position = 0; //store position of element in row list

    this.positionWatchers = [];
    this.component = null;
    this.created = false;
    this.setData(data);
  }

  create() {
    if (!this.created) {
      this.created = true;
      this.generateElement();
    }
  }

  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-row");
    el.setAttribute("role", "row");
    this.element = el;
  }

  getElement() {
    this.create();
    return this.element;
  }

  detachElement() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }

  generateElement() {
    this.createElement();
    this.dispatch("row-init", this);
  }

  generateCells() {
    this.cells = this.table.columnManager.generateCells(this);
  } //functions to setup on first render


  initialize(force) {
    this.create();

    if (!this.initialized || force) {
      this.deleteCells();

      while (this.element.firstChild) this.element.removeChild(this.element.firstChild);

      this.dispatch("row-layout-before", this);
      this.generateCells();
      this.initialized = true;
      this.table.columnManager.renderer.renderRowCells(this);

      if (force) {
        this.normalizeHeight();
      }

      this.dispatch("row-layout", this);

      if (this.table.options.rowFormatter) {
        this.table.options.rowFormatter(this.getComponent());
      }

      this.dispatch("row-layout-after", this);
    } else {
      this.table.columnManager.renderer.rerenderRowCells(this);
    }
  }

  reinitializeHeight() {
    this.heightInitialized = false;

    if (this.element && this.element.offsetParent !== null) {
      this.normalizeHeight(true);
    }
  }

  deinitialize() {
    this.initialized = false;
  }

  deinitializeHeight() {
    this.heightInitialized = false;
  }

  reinitialize(children) {
    this.initialized = false;
    this.heightInitialized = false;

    if (!this.manualHeight) {
      this.height = 0;
      this.heightStyled = "";
    }

    if (this.element && this.element.offsetParent !== null) {
      this.initialize(true);
    }

    this.dispatch("row-relayout", this);
  } //get heights when doing bulk row style calcs in virtual DOM


  calcHeight(force) {
    var maxHeight = 0,
        minHeight;

    if (this.table.options.rowHeight) {
      this.height = this.table.options.rowHeight;
    } else {
      minHeight = this.table.options.resizableRows ? this.element.clientHeight : 0;
      this.cells.forEach(function (cell) {
        var height = cell.getHeight();

        if (height > maxHeight) {
          maxHeight = height;
        }
      });

      if (force) {
        this.height = Math.max(maxHeight, minHeight);
      } else {
        this.height = this.manualHeight ? this.height : Math.max(maxHeight, minHeight);
      }
    }

    this.heightStyled = this.height ? this.height + "px" : "";
    this.outerHeight = this.element.offsetHeight;
  } //set of cells


  setCellHeight() {
    this.cells.forEach(function (cell) {
      cell.setHeight();
    });
    this.heightInitialized = true;
  }

  clearCellHeight() {
    this.cells.forEach(function (cell) {
      cell.clearHeight();
    });
  } //normalize the height of elements in the row


  normalizeHeight(force) {
    if (force && !this.table.options.rowHeight) {
      this.clearCellHeight();
    }

    this.calcHeight(force);
    this.setCellHeight();
  } //set height of rows


  setHeight(height, force) {
    if (this.height != height || force) {
      this.manualHeight = true;
      this.height = height;
      this.heightStyled = height ? height + "px" : "";
      this.setCellHeight(); // this.outerHeight = this.element.outerHeight();

      this.outerHeight = this.element.offsetHeight;
    }
  } //return rows outer height


  getHeight() {
    return this.outerHeight;
  } //return rows outer Width


  getWidth() {
    return this.element.offsetWidth;
  } //////////////// Cell Management /////////////////


  deleteCell(cell) {
    var index = this.cells.indexOf(cell);

    if (index > -1) {
      this.cells.splice(index, 1);
    }
  } //////////////// Data Management /////////////////


  setData(data) {
    this.data = this.chain("row-data-init-before", [this, data], undefined, data);
    this.dispatch("row-data-init-after", this);
  } //update the rows data


  updateData(updatedData) {
    var visible = this.element && Helpers.elVisible(this.element),
        tempData = {},
        newRowData;
    return new Promise((resolve, reject) => {
      if (typeof updatedData === "string") {
        updatedData = JSON.parse(updatedData);
      }

      this.dispatch("row-data-save-before", this);

      if (this.subscribed("row-data-changing")) {
        tempData = Object.assign(tempData, this.data);
        tempData = Object.assign(tempData, updatedData);
      }

      newRowData = this.chain("row-data-changing", [this, tempData, updatedData], null, updatedData); //set data

      for (let attrname in newRowData) {
        this.data[attrname] = newRowData[attrname];
      }

      this.dispatch("row-data-save-after", this); //update affected cells only

      for (let attrname in updatedData) {
        let columns = this.table.columnManager.getColumnsByFieldRoot(attrname);
        columns.forEach(column => {
          let cell = this.getCell(column.getField());

          if (cell) {
            let value = column.getFieldValue(newRowData);

            if (cell.getValue() != value) {
              cell.setValueProcessData(value);

              if (visible) {
                cell.cellRendered();
              }
            }
          }
        });
      } //Partial reinitialization if visible


      if (visible) {
        this.normalizeHeight(true);

        if (this.table.options.rowFormatter) {
          this.table.options.rowFormatter(this.getComponent());
        }
      } else {
        this.initialized = false;
        this.height = 0;
        this.heightStyled = "";
      }

      this.dispatch("row-data-changed", this, visible, updatedData); //this.reinitialize();

      this.dispatchExternal("rowUpdated", this.getComponent());

      if (this.subscribedExternal("dataChanged")) {
        this.dispatchExternal("dataChanged", this.table.rowManager.getData());
      }

      resolve();
    });
  }

  getData(transform) {
    if (transform) {
      return this.chain("row-data-retrieve", [this, transform], null, this.data);
    }

    return this.data;
  }

  getCell(column) {
    var match = false;
    column = this.table.columnManager.findColumn(column);

    if (!this.initialized) {
      this.generateCells();
    }

    match = this.cells.find(function (cell) {
      return cell.column === column;
    });
    return match;
  }

  getCellIndex(findCell) {
    return this.cells.findIndex(function (cell) {
      return cell === findCell;
    });
  }

  findCell(subject) {
    return this.cells.find(cell => {
      return cell.element === subject;
    });
  }

  getCells() {
    if (!this.initialized) {
      this.generateCells();
    }

    return this.cells;
  }

  nextRow() {
    var row = this.table.rowManager.nextDisplayRow(this, true);
    return row || false;
  }

  prevRow() {
    var row = this.table.rowManager.prevDisplayRow(this, true);
    return row || false;
  }

  moveToRow(to, before) {
    var toRow = this.table.rowManager.findRow(to);

    if (toRow) {
      this.table.rowManager.moveRowActual(this, toRow, !before);
      this.table.rowManager.refreshActiveData("display", false, true);
    } else {
      console.warn("Move Error - No matching row found:", to);
    }
  } ///////////////////// Actions  /////////////////////


  delete() {
    this.dispatch("row-delete", this);
    this.deleteActual();
    return Promise.resolve();
  }

  deleteActual(blockRedraw) {
    this.detachModules();
    this.table.rowManager.deleteRow(this, blockRedraw);
    this.deleteCells();
    this.initialized = false;
    this.heightInitialized = false;
    this.element = false;
    this.dispatch("row-deleted", this);
  }

  detachModules() {
    this.dispatch("row-deleting", this);
  }

  deleteCells() {
    var cellCount = this.cells.length;

    for (let i = 0; i < cellCount; i++) {
      this.cells[0].delete();
    }
  }

  wipe() {
    this.detachModules();
    this.deleteCells();

    if (this.element) {
      while (this.element.firstChild) this.element.removeChild(this.element.firstChild);

      if (this.element.parentNode) {
        this.element.parentNode.removeChild(this.element);
      }
    }

    this.element = false;
    this.modules = {};
  }

  isDisplayed() {
    return this.table.rowManager.getDisplayRows().includes(this);
  }

  getPosition() {
    return this.isDisplayed() ? this.position : false;
  }

  setPosition(position) {
    if (position != this.position) {
      this.position = position;
      this.positionWatchers.forEach(callback => {
        callback(this.position);
      });
    }
  }

  watchPosition(callback) {
    this.positionWatchers.push(callback);
    callback(this.position);
  }

  getGroup() {
    return this.modules.group || false;
  } //////////////// Object Generation /////////////////


  getComponent() {
    if (!this.component) {
      this.component = new RowComponent(this);
    }

    return this.component;
  }

}

var defaultCalculations = {
  "avg": function (values, data, calcParams) {
    var output = 0,
        precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : 2;

    if (values.length) {
      output = values.reduce(function (sum, value) {
        return Number(sum) + Number(value);
      });
      output = output / values.length;
      output = precision !== false ? output.toFixed(precision) : output;
    }

    return parseFloat(output).toString();
  },
  "max": function (values, data, calcParams) {
    var output = null,
        precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;
    values.forEach(function (value) {
      value = Number(value);

      if (value > output || output === null) {
        output = value;
      }
    });
    return output !== null ? precision !== false ? output.toFixed(precision) : output : "";
  },
  "min": function (values, data, calcParams) {
    var output = null,
        precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;
    values.forEach(function (value) {
      value = Number(value);

      if (value < output || output === null) {
        output = value;
      }
    });
    return output !== null ? precision !== false ? output.toFixed(precision) : output : "";
  },
  "sum": function (values, data, calcParams) {
    var output = 0,
        precision = typeof calcParams.precision !== "undefined" ? calcParams.precision : false;

    if (values.length) {
      values.forEach(function (value) {
        value = Number(value);
        output += !isNaN(value) ? Number(value) : 0;
      });
    }

    return precision !== false ? output.toFixed(precision) : output;
  },
  "concat": function (values, data, calcParams) {
    var output = 0;

    if (values.length) {
      output = values.reduce(function (sum, value) {
        return String(sum) + String(value);
      });
    }

    return output;
  },
  "count": function (values, data, calcParams) {
    var output = 0;

    if (values.length) {
      values.forEach(function (value) {
        if (value) {
          output++;
        }
      });
    }

    return output;
  }
};

class ColumnCalcs extends Module {
  constructor(table) {
    super(table);
    this.topCalcs = [];
    this.botCalcs = [];
    this.genColumn = false;
    this.topElement = this.createElement();
    this.botElement = this.createElement();
    this.topRow = false;
    this.botRow = false;
    this.topInitialized = false;
    this.botInitialized = false;
    this.registerTableOption("columnCalcs", true);
    this.registerColumnOption("topCalc");
    this.registerColumnOption("topCalcParams");
    this.registerColumnOption("topCalcFormatter");
    this.registerColumnOption("topCalcFormatterParams");
    this.registerColumnOption("bottomCalc");
    this.registerColumnOption("bottomCalcParams");
    this.registerColumnOption("bottomCalcFormatter");
    this.registerColumnOption("bottomCalcFormatterParams");
  }

  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-calcs-holder");
    return el;
  }

  initialize() {
    this.genColumn = new Column({
      field: "value"
    }, this);
    this.subscribe("cell-value-changed", this.cellValueChanged.bind(this));
    this.subscribe("column-init", this.initializeColumnCheck.bind(this));
    this.subscribe("row-deleted", this.rowsUpdated.bind(this));
    this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
    this.subscribe("row-added", this.rowsUpdated.bind(this));
    this.subscribe("column-moved", this.recalcActiveRows.bind(this));
    this.subscribe("column-add", this.recalcActiveRows.bind(this));
    this.subscribe("data-refreshed", this.recalcActiveRowsRefresh.bind(this));
    this.subscribe("table-redraw", this.tableRedraw.bind(this));
    this.subscribe("rows-visible", this.visibleRows.bind(this));
    this.registerTableFunction("getCalcResults", this.getResults.bind(this));
    this.registerTableFunction("recalc", this.userRecalc.bind(this));
  }

  tableRedraw(force) {
    this.recalc(this.table.rowManager.activeRows);

    if (force) {
      this.redraw();
    }
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////


  userRecalc() {
    this.recalc(this.table.rowManager.activeRows);
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  visibleRows(viewable, rows) {
    if (this.topRow) {
      rows.unshift(this.topRow);
    }

    if (this.botRow) {
      rows.push(this.botRow);
    }

    return rows;
  }

  rowsUpdated(row) {
    if (this.table.options.groupBy) {
      this.recalcRowGroup(row);
    } else {
      this.recalcActiveRows();
    }
  }

  recalcActiveRowsRefresh() {
    if (this.table.options.groupBy && this.table.options.dataTreeStartExpanded && this.table.options.dataTree) {
      this.recalcAll();
    } else {
      this.recalcActiveRows();
    }
  }

  recalcActiveRows() {
    this.recalc(this.table.rowManager.activeRows);
  }

  cellValueChanged(cell) {
    if (cell.column.definition.topCalc || cell.column.definition.bottomCalc) {
      if (this.table.options.groupBy) {
        if (this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both") {
          this.recalcActiveRows();
        }

        if (this.table.options.columnCalcs != "table") {
          this.recalcRowGroup(cell.row);
        }
      } else {
        this.recalcActiveRows();
      }
    }
  }

  initializeColumnCheck(column) {
    if (column.definition.topCalc || column.definition.bottomCalc) {
      this.initializeColumn(column);
    }
  } //initialize column calcs


  initializeColumn(column) {
    var def = column.definition;
    var config = {
      topCalcParams: def.topCalcParams || {},
      botCalcParams: def.bottomCalcParams || {}
    };

    if (def.topCalc) {
      switch (typeof def.topCalc) {
        case "string":
          if (ColumnCalcs.calculations[def.topCalc]) {
            config.topCalc = ColumnCalcs.calculations[def.topCalc];
          } else {
            console.warn("Column Calc Error - No such calculation found, ignoring: ", def.topCalc);
          }

          break;

        case "function":
          config.topCalc = def.topCalc;
          break;
      }

      if (config.topCalc) {
        column.modules.columnCalcs = config;
        this.topCalcs.push(column);

        if (this.table.options.columnCalcs != "group") {
          this.initializeTopRow();
        }
      }
    }

    if (def.bottomCalc) {
      switch (typeof def.bottomCalc) {
        case "string":
          if (ColumnCalcs.calculations[def.bottomCalc]) {
            config.botCalc = ColumnCalcs.calculations[def.bottomCalc];
          } else {
            console.warn("Column Calc Error - No such calculation found, ignoring: ", def.bottomCalc);
          }

          break;

        case "function":
          config.botCalc = def.bottomCalc;
          break;
      }

      if (config.botCalc) {
        column.modules.columnCalcs = config;
        this.botCalcs.push(column);

        if (this.table.options.columnCalcs != "group") {
          this.initializeBottomRow();
        }
      }
    }
  } //dummy functions to handle being mock column manager


  registerColumnField() {}

  removeCalcs() {
    var changed = false;

    if (this.topInitialized) {
      this.topInitialized = false;
      this.topElement.parentNode.removeChild(this.topElement);
      changed = true;
    }

    if (this.botInitialized) {
      this.botInitialized = false;
      this.footerRemove(this.botElement);
      changed = true;
    }

    if (changed) {
      this.table.rowManager.adjustTableSize();
    }
  }

  initializeTopRow() {
    if (!this.topInitialized) {
      this.table.columnManager.getElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling);
      this.topInitialized = true;
    }
  }

  initializeBottomRow() {
    if (!this.botInitialized) {
      this.footerPrepend(this.botElement);
      this.botInitialized = true;
    }
  }

  scrollHorizontal(left) {
    if (this.botInitialized && this.botRow) {
      if (this.table.rtl) {
        this.botRow.getElement().style.marginRight = left + "px";
      } else {
        this.botRow.getElement().style.marginLeft = -left + "px";
      }
    }
  }

  recalc(rows) {
    var data, row;

    if (this.topInitialized || this.botInitialized) {
      data = this.rowsToData(rows);

      if (this.topInitialized) {
        if (this.topRow) {
          this.topRow.deleteCells();
        }

        row = this.generateRow("top", data);
        this.topRow = row;

        while (this.topElement.firstChild) this.topElement.removeChild(this.topElement.firstChild);

        this.topElement.appendChild(row.getElement());
        row.initialize(true);
      }

      if (this.botInitialized) {
        if (this.botRow) {
          this.botRow.deleteCells();
        }

        row = this.generateRow("bottom", data);
        this.botRow = row;

        while (this.botElement.firstChild) this.botElement.removeChild(this.botElement.firstChild);

        this.botElement.appendChild(row.getElement());
        row.initialize(true);
      }

      this.table.rowManager.adjustTableSize(); //set resizable handles

      if (this.table.modExists("frozenColumns")) {
        this.table.modules.frozenColumns.layout();
      }
    }
  }

  recalcRowGroup(row) {
    this.recalcGroup(this.table.modules.groupRows.getRowGroup(row));
  }

  recalcAll() {
    if (this.topCalcs.length || this.botCalcs.length) {
      if (this.table.options.columnCalcs !== "group") {
        this.recalcActiveRows();
      }

      if (this.table.options.groupBy && this.table.options.columnCalcs !== "table") {
        var groups = this.table.modules.groupRows.getChildGroups();
        groups.forEach(group => {
          this.recalcGroup(group);
        });
      }
    }
  }

  recalcGroup(group) {
    var data, rowData;

    if (group) {
      if (group.calcs) {
        if (group.calcs.bottom) {
          data = this.rowsToData(group.rows);
          rowData = this.generateRowData("bottom", data);
          group.calcs.bottom.updateData(rowData);
          group.calcs.bottom.reinitialize();
        }

        if (group.calcs.top) {
          data = this.rowsToData(group.rows);
          rowData = this.generateRowData("top", data);
          group.calcs.top.updateData(rowData);
          group.calcs.top.reinitialize();
        }
      }
    }
  } //generate top stats row


  generateTopRow(rows) {
    return this.generateRow("top", this.rowsToData(rows));
  } //generate bottom stats row


  generateBottomRow(rows) {
    return this.generateRow("bottom", this.rowsToData(rows));
  }

  rowsToData(rows) {
    var data = [];
    rows.forEach(row => {
      data.push(row.getData());

      if (this.table.options.dataTree && this.table.options.dataTreeChildColumnCalcs) {
        if (row.modules.dataTree && row.modules.dataTree.open) {
          var children = this.rowsToData(this.table.modules.dataTree.getFilteredTreeChildren(row));
          data = data.concat(children);
        }
      }
    });
    return data;
  } //generate stats row


  generateRow(pos, data) {
    var rowData = this.generateRowData(pos, data),
        row;

    if (this.table.modExists("mutator")) {
      this.table.modules.mutator.disable();
    }

    row = new Row(rowData, this, "calc");

    if (this.table.modExists("mutator")) {
      this.table.modules.mutator.enable();
    }

    row.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + pos);
    row.component = false;

    row.getComponent = () => {
      if (!row.component) {
        row.component = new CalcComponent(row);
      }

      return row.component;
    };

    row.generateCells = () => {
      var cells = [];
      this.table.columnManager.columnsByIndex.forEach(column => {
        //set field name of mock column
        this.genColumn.setField(column.getField());
        this.genColumn.hozAlign = column.hozAlign;

        if (column.definition[pos + "CalcFormatter"] && this.table.modExists("format")) {
          this.genColumn.modules.format = {
            formatter: this.table.modules.format.getFormatter(column.definition[pos + "CalcFormatter"]),
            params: column.definition[pos + "CalcFormatterParams"] || {}
          };
        } else {
          this.genColumn.modules.format = {
            formatter: this.table.modules.format.getFormatter("plaintext"),
            params: {}
          };
        } //ensure css class definition is replicated to calculation cell


        this.genColumn.definition.cssClass = column.definition.cssClass; //generate cell and assign to correct column

        var cell = new Cell(this.genColumn, row);
        cell.getElement();
        cell.column = column;
        cell.setWidth();
        column.cells.push(cell);
        cells.push(cell);

        if (!column.visible) {
          cell.hide();
        }
      });
      row.cells = cells;
    };

    return row;
  } //generate stats row


  generateRowData(pos, data) {
    var rowData = {},
        calcs = pos == "top" ? this.topCalcs : this.botCalcs,
        type = pos == "top" ? "topCalc" : "botCalc",
        params,
        paramKey;
    calcs.forEach(function (column) {
      var values = [];

      if (column.modules.columnCalcs && column.modules.columnCalcs[type]) {
        data.forEach(function (item) {
          values.push(column.getFieldValue(item));
        });
        paramKey = type + "Params";
        params = typeof column.modules.columnCalcs[paramKey] === "function" ? column.modules.columnCalcs[paramKey](values, data) : column.modules.columnCalcs[paramKey];
        column.setFieldValue(rowData, column.modules.columnCalcs[type](values, data, params));
      }
    });
    return rowData;
  }

  hasTopCalcs() {
    return !!this.topCalcs.length;
  }

  hasBottomCalcs() {
    return !!this.botCalcs.length;
  } //handle table redraw


  redraw() {
    if (this.topRow) {
      this.topRow.normalizeHeight(true);
    }

    if (this.botRow) {
      this.botRow.normalizeHeight(true);
    }
  } //return the calculated


  getResults() {
    var results = {},
        groups;

    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      groups = this.table.modules.groupRows.getGroups(true);
      groups.forEach(group => {
        results[group.getKey()] = this.getGroupResults(group);
      });
    } else {
      results = {
        top: this.topRow ? this.topRow.getData() : {},
        bottom: this.botRow ? this.botRow.getData() : {}
      };
    }

    return results;
  } //get results from a group


  getGroupResults(group) {
    var groupObj = group._getSelf(),
        subGroups = group.getSubGroups(),
        subGroupResults = {},
        results = {};

    subGroups.forEach(subgroup => {
      subGroupResults[subgroup.getKey()] = this.getGroupResults(subgroup);
    });
    results = {
      top: groupObj.calcs.top ? groupObj.calcs.top.getData() : {},
      bottom: groupObj.calcs.bottom ? groupObj.calcs.bottom.getData() : {},
      groups: subGroupResults
    };
    return results;
  }

}

exports.ColumnCalcsModule = ColumnCalcs;
ColumnCalcs.moduleName = "columnCalcs"; //load defaults

ColumnCalcs.calculations = defaultCalculations;

class DataTree extends Module {
  constructor(table) {
    super(table);
    this.indent = 10;
    this.field = "";
    this.collapseEl = null;
    this.expandEl = null;
    this.branchEl = null;
    this.elementField = false;

    this.startOpen = function () {};

    this.displayIndex = 0;
    this.registerTableOption("dataTree", false); //enable data tree

    this.registerTableOption("dataTreeFilter", true); //filter child rows

    this.registerTableOption("dataTreeSort", true); //sort child rows

    this.registerTableOption("dataTreeElementColumn", false);
    this.registerTableOption("dataTreeBranchElement", true); //show data tree branch element

    this.registerTableOption("dataTreeChildIndent", 9); //data tree child indent in px

    this.registerTableOption("dataTreeChildField", "_children"); //data tre column field to look for child rows

    this.registerTableOption("dataTreeCollapseElement", false); //data tree row collapse element

    this.registerTableOption("dataTreeExpandElement", false); //data tree row expand element

    this.registerTableOption("dataTreeStartExpanded", false);
    this.registerTableOption("dataTreeChildColumnCalcs", false); //include visible data tree rows in column calculations

    this.registerTableOption("dataTreeSelectPropagate", false); //selecting a parent row selects its children
    //register component functions

    this.registerComponentFunction("row", "treeCollapse", this.collapseRow.bind(this));
    this.registerComponentFunction("row", "treeExpand", this.expandRow.bind(this));
    this.registerComponentFunction("row", "treeToggle", this.toggleRow.bind(this));
    this.registerComponentFunction("row", "getTreeParent", this.getTreeParent.bind(this));
    this.registerComponentFunction("row", "getTreeChildren", this.getRowChildren.bind(this));
    this.registerComponentFunction("row", "addTreeChild", this.addTreeChildRow.bind(this));
    this.registerComponentFunction("row", "isTreeExpanded", this.isRowExpanded.bind(this));
  }

  initialize() {
    if (this.table.options.dataTree) {
      var dummyEl = null,
          options = this.table.options;
      this.field = options.dataTreeChildField;
      this.indent = options.dataTreeChildIndent;

      if (this.options("movableRows")) {
        console.warn("The movableRows option is not available with dataTree enabled, moving of child rows could result in unpredictable behavior");
      }

      if (options.dataTreeBranchElement) {
        if (options.dataTreeBranchElement === true) {
          this.branchEl = document.createElement("div");
          this.branchEl.classList.add("tabulator-data-tree-branch");
        } else {
          if (typeof options.dataTreeBranchElement === "string") {
            dummyEl = document.createElement("div");
            dummyEl.innerHTML = options.dataTreeBranchElement;
            this.branchEl = dummyEl.firstChild;
          } else {
            this.branchEl = options.dataTreeBranchElement;
          }
        }
      }

      if (options.dataTreeCollapseElement) {
        if (typeof options.dataTreeCollapseElement === "string") {
          dummyEl = document.createElement("div");
          dummyEl.innerHTML = options.dataTreeCollapseElement;
          this.collapseEl = dummyEl.firstChild;
        } else {
          this.collapseEl = options.dataTreeCollapseElement;
        }
      } else {
        this.collapseEl = document.createElement("div");
        this.collapseEl.classList.add("tabulator-data-tree-control");
        this.collapseEl.tabIndex = 0;
        this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>";
      }

      if (options.dataTreeExpandElement) {
        if (typeof options.dataTreeExpandElement === "string") {
          dummyEl = document.createElement("div");
          dummyEl.innerHTML = options.dataTreeExpandElement;
          this.expandEl = dummyEl.firstChild;
        } else {
          this.expandEl = options.dataTreeExpandElement;
        }
      } else {
        this.expandEl = document.createElement("div");
        this.expandEl.classList.add("tabulator-data-tree-control");
        this.expandEl.tabIndex = 0;
        this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>";
      }

      switch (typeof options.dataTreeStartExpanded) {
        case "boolean":
          this.startOpen = function (row, index) {
            return options.dataTreeStartExpanded;
          };

          break;

        case "function":
          this.startOpen = options.dataTreeStartExpanded;
          break;

        default:
          this.startOpen = function (row, index) {
            return options.dataTreeStartExpanded[index];
          };

          break;
      }

      this.subscribe("row-init", this.initializeRow.bind(this));
      this.subscribe("row-layout-after", this.layoutRow.bind(this));
      this.subscribe("row-deleted", this.rowDelete.bind(this), 0);
      this.subscribe("row-data-changed", this.rowDataChanged.bind(this), 10);
      this.subscribe("cell-value-updated", this.cellValueChanged.bind(this));
      this.subscribe("edit-cancelled", this.cellValueChanged.bind(this));
      this.subscribe("column-moving-rows", this.columnMoving.bind(this));
      this.subscribe("table-built", this.initializeElementField.bind(this));
      this.subscribe("table-redrawing", this.tableRedrawing.bind(this));
      this.registerDisplayHandler(this.getRows.bind(this), 30);
    }
  }

  tableRedrawing(force) {
    var rows;

    if (force) {
      rows = this.table.rowManager.getRows();
      rows.forEach(row => {
        this.reinitializeRowChildren(row);
      });
    }
  }

  initializeElementField() {
    var firstCol = this.table.columnManager.getFirstVisibleColumn();
    this.elementField = this.table.options.dataTreeElementColumn || (firstCol ? firstCol.field : false);
  }

  getRowChildren(row) {
    return this.getTreeChildren(row, true);
  }

  columnMoving() {
    var rows = [];
    this.table.rowManager.rows.forEach(row => {
      rows = rows.concat(this.getTreeChildren(row, false, true));
    });
    return rows;
  }

  rowDataChanged(row, visible, updatedData) {
    if (this.redrawNeeded(updatedData)) {
      this.initializeRow(row);

      if (visible) {
        this.layoutRow(row);
        this.refreshData(true);
      }
    }
  }

  cellValueChanged(cell) {
    var field = cell.column.getField();

    if (field === this.elementField) {
      this.layoutRow(cell.row);
    }
  }

  initializeRow(row) {
    var childArray = row.getData()[this.field];
    var isArray = Array.isArray(childArray);
    var children = isArray || !isArray && typeof childArray === "object" && childArray !== null;

    if (!children && row.modules.dataTree && row.modules.dataTree.branchEl) {
      row.modules.dataTree.branchEl.parentNode.removeChild(row.modules.dataTree.branchEl);
    }

    if (!children && row.modules.dataTree && row.modules.dataTree.controlEl) {
      row.modules.dataTree.controlEl.parentNode.removeChild(row.modules.dataTree.controlEl);
    }

    row.modules.dataTree = {
      index: row.modules.dataTree ? row.modules.dataTree.index : 0,
      open: children ? row.modules.dataTree ? row.modules.dataTree.open : this.startOpen(row.getComponent(), 0) : false,
      controlEl: row.modules.dataTree && children ? row.modules.dataTree.controlEl : false,
      branchEl: row.modules.dataTree && children ? row.modules.dataTree.branchEl : false,
      parent: row.modules.dataTree ? row.modules.dataTree.parent : false,
      children: children
    };
  }

  reinitializeRowChildren(row) {
    var children = this.getTreeChildren(row, false, true);
    children.forEach(function (child) {
      child.reinitialize(true);
    });
  }

  layoutRow(row) {
    var cell = this.elementField ? row.getCell(this.elementField) : row.getCells()[0],
        el = cell.getElement(),
        config = row.modules.dataTree;

    if (config.branchEl) {
      if (config.branchEl.parentNode) {
        config.branchEl.parentNode.removeChild(config.branchEl);
      }

      config.branchEl = false;
    }

    if (config.controlEl) {
      if (config.controlEl.parentNode) {
        config.controlEl.parentNode.removeChild(config.controlEl);
      }

      config.controlEl = false;
    }

    this.generateControlElement(row, el);
    row.getElement().classList.add("tabulator-tree-level-" + config.index);

    if (config.index) {
      if (this.branchEl) {
        config.branchEl = this.branchEl.cloneNode(true);
        el.insertBefore(config.branchEl, el.firstChild);

        if (this.table.rtl) {
          config.branchEl.style.marginRight = (config.branchEl.offsetWidth + config.branchEl.style.marginLeft) * (config.index - 1) + config.index * this.indent + "px";
        } else {
          config.branchEl.style.marginLeft = (config.branchEl.offsetWidth + config.branchEl.style.marginRight) * (config.index - 1) + config.index * this.indent + "px";
        }
      } else {
        if (this.table.rtl) {
          el.style.paddingRight = parseInt(window.getComputedStyle(el, null).getPropertyValue('padding-right')) + config.index * this.indent + "px";
        } else {
          el.style.paddingLeft = parseInt(window.getComputedStyle(el, null).getPropertyValue('padding-left')) + config.index * this.indent + "px";
        }
      }
    }
  }

  generateControlElement(row, el) {
    var config = row.modules.dataTree,
        oldControl = config.controlEl;
    el = el || row.getCells()[0].getElement();

    if (config.children !== false) {
      if (config.open) {
        config.controlEl = this.collapseEl.cloneNode(true);
        config.controlEl.addEventListener("click", e => {
          e.stopPropagation();
          this.collapseRow(row);
        });
      } else {
        config.controlEl = this.expandEl.cloneNode(true);
        config.controlEl.addEventListener("click", e => {
          e.stopPropagation();
          this.expandRow(row);
        });
      }

      config.controlEl.addEventListener("mousedown", e => {
        e.stopPropagation();
      });

      if (oldControl && oldControl.parentNode === el) {
        oldControl.parentNode.replaceChild(config.controlEl, oldControl);
      } else {
        el.insertBefore(config.controlEl, el.firstChild);
      }
    }
  }

  setDisplayIndex(index) {
    this.displayIndex = index;
  }

  getDisplayIndex() {
    return this.displayIndex;
  }

  getRows(rows) {
    var output = [];
    rows.forEach((row, i) => {
      var config, children;
      output.push(row);

      if (row instanceof Row) {
        row.create();
        config = row.modules.dataTree.children;

        if (!config.index && config.children !== false) {
          children = this.getChildren(row);
          children.forEach(child => {
            child.create();
            output.push(child);
          });
        }
      }
    });
    return output;
  }

  getChildren(row, allChildren) {
    var config = row.modules.dataTree,
        children = [],
        output = [];

    if (config.children !== false && (config.open || allChildren)) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row);
      }

      if (this.table.modExists("filter") && this.table.options.dataTreeFilter) {
        children = this.table.modules.filter.filter(config.children);
      } else {
        children = config.children;
      }

      if (this.table.modExists("sort") && this.table.options.dataTreeSort) {
        this.table.modules.sort.sort(children);
      }

      children.forEach(child => {
        output.push(child);
        var subChildren = this.getChildren(child);
        subChildren.forEach(sub => {
          output.push(sub);
        });
      });
    }

    return output;
  }

  generateChildren(row) {
    var children = [];
    var childArray = row.getData()[this.field];

    if (!Array.isArray(childArray)) {
      childArray = [childArray];
    }

    childArray.forEach(childData => {
      var childRow = new Row(childData || {}, this.table.rowManager);
      childRow.create();
      childRow.modules.dataTree.index = row.modules.dataTree.index + 1;
      childRow.modules.dataTree.parent = row;

      if (childRow.modules.dataTree.children) {
        childRow.modules.dataTree.open = this.startOpen(childRow.getComponent(), childRow.modules.dataTree.index);
      }

      children.push(childRow);
    });
    return children;
  }

  expandRow(row, silent) {
    var config = row.modules.dataTree;

    if (config.children !== false) {
      config.open = true;
      row.reinitialize();
      this.refreshData(true);
      this.dispatchExternal("dataTreeRowExpanded", row.getComponent(), row.modules.dataTree.index);
    }
  }

  collapseRow(row) {
    var config = row.modules.dataTree;

    if (config.children !== false) {
      config.open = false;
      row.reinitialize();
      this.refreshData(true);
      this.dispatchExternal("dataTreeRowCollapsed", row.getComponent(), row.modules.dataTree.index);
    }
  }

  toggleRow(row) {
    var config = row.modules.dataTree;

    if (config.children !== false) {
      if (config.open) {
        this.collapseRow(row);
      } else {
        this.expandRow(row);
      }
    }
  }

  isRowExpanded(row) {
    return row.modules.dataTree.open;
  }

  getTreeParent(row) {
    return row.modules.dataTree.parent ? row.modules.dataTree.parent.getComponent() : false;
  }

  getTreeParentRoot(row) {
    return row.modules.dataTree && row.modules.dataTree.parent ? this.getTreeParentRoot(row.modules.dataTree.parent) : row;
  }

  getFilteredTreeChildren(row) {
    var config = row.modules.dataTree,
        output = [],
        children;

    if (config.children) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row);
      }

      if (this.table.modExists("filter") && this.table.options.dataTreeFilter) {
        children = this.table.modules.filter.filter(config.children);
      } else {
        children = config.children;
      }

      children.forEach(childRow => {
        if (childRow instanceof Row) {
          output.push(childRow);
        }
      });
    }

    return output;
  }

  rowDelete(row) {
    var parent = row.modules.dataTree.parent,
        childIndex;

    if (parent) {
      childIndex = this.findChildIndex(row, parent);

      if (childIndex !== false) {
        parent.data[this.field].splice(childIndex, 1);
      }

      if (!parent.data[this.field].length) {
        delete parent.data[this.field];
      }

      this.initializeRow(parent);
      this.layoutRow(parent);
    }

    this.refreshData(true);
  }

  addTreeChildRow(row, data, top, index) {
    var childIndex = false;

    if (typeof data === "string") {
      data = JSON.parse(data);
    }

    if (!Array.isArray(row.data[this.field])) {
      row.data[this.field] = [];
      row.modules.dataTree.open = this.startOpen(row.getComponent(), row.modules.dataTree.index);
    }

    if (typeof index !== "undefined") {
      childIndex = this.findChildIndex(index, row);

      if (childIndex !== false) {
        row.data[this.field].splice(top ? childIndex : childIndex + 1, 0, data);
      }
    }

    if (childIndex === false) {
      if (top) {
        row.data[this.field].unshift(data);
      } else {
        row.data[this.field].push(data);
      }
    }

    this.initializeRow(row);
    this.layoutRow(row);
    this.refreshData(true);
  }

  findChildIndex(subject, parent) {
    var match = false;

    if (typeof subject == "object") {
      if (subject instanceof Row) {
        //subject is row element
        match = subject.data;
      } else if (subject instanceof RowComponent) {
        //subject is public row component
        match = subject._getSelf().data;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        if (parent.modules.dataTree) {
          match = parent.modules.dataTree.children.find(childRow => {
            return childRow instanceof Row ? childRow.element === subject : false;
          });

          if (match) {
            match = match.data;
          }
        }
      } else if (subject === null) {
        match = false;
      }
    } else if (typeof subject == "undefined") {
      match = false;
    } else {
      //subject should be treated as the index of the row
      match = parent.data[this.field].find(row => {
        return row.data[this.table.options.index] == subject;
      });
    }

    if (match) {
      if (Array.isArray(parent.data[this.field])) {
        match = parent.data[this.field].indexOf(match);
      }

      if (match == -1) {
        match = false;
      }
    } //catch all for any other type of input


    return match;
  }

  getTreeChildren(row, component, recurse) {
    var config = row.modules.dataTree,
        output = [];

    if (config.children) {
      if (!Array.isArray(config.children)) {
        config.children = this.generateChildren(row);
      }

      config.children.forEach(childRow => {
        if (childRow instanceof Row) {
          output.push(component ? childRow.getComponent() : childRow);

          if (recurse) {
            output = output.concat(this.getTreeChildren(childRow, component, recurse));
          }
        }
      });
    }

    return output;
  }

  getChildField() {
    return this.field;
  }

  redrawNeeded(data) {
    return (this.field ? typeof data[this.field] !== "undefined" : false) || (this.elementField ? typeof data[this.elementField] !== "undefined" : false);
  }

}

exports.DataTreeModule = DataTree;
DataTree.moduleName = "dataTree";

function csv(list, options = {}, setFileContents) {
  var delimiter = options.delimiter ? options.delimiter : ",",
      fileContents = [],
      headers = [];
  list.forEach(row => {
    var item = [];

    switch (row.type) {
      case "group":
        console.warn("Download Warning - CSV downloader cannot process row groups");
        break;

      case "calc":
        console.warn("Download Warning - CSV downloader cannot process column calculations");
        break;

      case "header":
        row.columns.forEach((col, i) => {
          if (col && col.depth === 1) {
            headers[i] = typeof col.value == "undefined" || col.value === null ? "" : '"' + String(col.value).split('"').join('""') + '"';
          }
        });
        break;

      case "row":
        row.columns.forEach(col => {
          if (col) {
            switch (typeof col.value) {
              case "object":
                col.value = col.value !== null ? JSON.stringify(col.value) : "";
                break;

              case "undefined":
                col.value = "";
                break;
            }

            item.push('"' + String(col.value).split('"').join('""') + '"');
          }
        });
        fileContents.push(item.join(delimiter));
        break;
    }
  });

  if (headers.length) {
    fileContents.unshift(headers.join(delimiter));
  }

  fileContents = fileContents.join("\n");

  if (options.bom) {
    fileContents = "\ufeff" + fileContents;
  }

  setFileContents(fileContents, "text/csv");
}

function json(list, options, setFileContents) {
  var fileContents = [];
  list.forEach(row => {
    var item = {};

    switch (row.type) {
      case "header":
        break;

      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;

      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;

      case "row":
        row.columns.forEach(col => {
          if (col) {
            item[col.component.getTitleDownload() || col.component.getField()] = col.value;
          }
        });
        fileContents.push(item);
        break;
    }
  });
  fileContents = JSON.stringify(fileContents, null, '\t');
  setFileContents(fileContents, "application/json");
}

function pdf(list, options = {}, setFileContents) {
  var header = [],
      body = [],
      autoTableParams = {},
      rowGroupStyles = options.rowGroupStyles || {
    fontStyle: "bold",
    fontSize: 12,
    cellPadding: 6,
    fillColor: 220
  },
      rowCalcStyles = options.rowCalcStyles || {
    fontStyle: "bold",
    fontSize: 10,
    cellPadding: 4,
    fillColor: 232
  },
      jsPDFParams = options.jsPDF || {},
      title = options.title ? options.title : "";

  if (!jsPDFParams.orientation) {
    jsPDFParams.orientation = options.orientation || "landscape";
  }

  if (!jsPDFParams.unit) {
    jsPDFParams.unit = "pt";
  } //parse row list


  list.forEach(row => {
    switch (row.type) {
      case "header":
        header.push(parseRow(row));
        break;

      case "group":
        body.push(parseRow(row, rowGroupStyles));
        break;

      case "calc":
        body.push(parseRow(row, rowCalcStyles));
        break;

      case "row":
        body.push(parseRow(row));
        break;
    }
  });

  function parseRow(row, styles) {
    var rowData = [];
    row.columns.forEach(col => {
      var cell;

      if (col) {
        switch (typeof col.value) {
          case "object":
            col.value = col.value !== null ? JSON.stringify(col.value) : "";
            break;

          case "undefined":
            col.value = "";
            break;
        }

        cell = {
          content: col.value,
          colSpan: col.width,
          rowSpan: col.height
        };

        if (styles) {
          cell.styles = styles;
        }

        rowData.push(cell);
      }
    });
    return rowData;
  } //configure PDF


  var doc = new jspdf.jsPDF(jsPDFParams); //set document to landscape, better for most tables

  if (options.autoTable) {
    if (typeof options.autoTable === "function") {
      autoTableParams = options.autoTable(doc) || {};
    } else {
      autoTableParams = options.autoTable;
    }
  }

  if (title) {
    autoTableParams.didDrawPage = function (data) {
      doc.text(title, 40, 30);
    };
  }

  autoTableParams.head = header;
  autoTableParams.body = body;
  doc.autoTable(autoTableParams);

  if (options.documentProcessing) {
    options.documentProcessing(doc);
  }

  setFileContents(doc.output("arraybuffer"), "application/pdf");
}

function xlsx(list, options, setFileContents) {
  var self = this,
      sheetName = options.sheetName || "Sheet1",
      workbook = XLSX.utils.book_new(),
      tableFeatures = new CoreFeature(this),
      output;
  workbook.SheetNames = [];
  workbook.Sheets = {};

  function generateSheet() {
    var rows = [],
        merges = [],
        worksheet = {},
        range = {
      s: {
        c: 0,
        r: 0
      },
      e: {
        c: list[0] ? list[0].columns.reduce((a, b) => a + (b && b.width ? b.width : 1), 0) : 0,
        r: list.length
      }
    }; //parse row list

    list.forEach((row, i) => {
      var rowData = [];
      row.columns.forEach(function (col, j) {
        if (col) {
          rowData.push(!(col.value instanceof Date) && typeof col.value === "object" ? JSON.stringify(col.value) : col.value);

          if (col.width > 1 || col.height > -1) {
            if (col.height > 1 || col.width > 1) {
              merges.push({
                s: {
                  r: i,
                  c: j
                },
                e: {
                  r: i + col.height - 1,
                  c: j + col.width - 1
                }
              });
            }
          }
        } else {
          rowData.push("");
        }
      });
      rows.push(rowData);
    }); //convert rows to worksheet

    XLSX.utils.sheet_add_aoa(worksheet, rows);
    worksheet['!ref'] = XLSX.utils.encode_range(range);

    if (merges.length) {
      worksheet["!merges"] = merges;
    }

    return worksheet;
  }

  if (options.sheetOnly) {
    setFileContents(generateSheet());
    return;
  }

  if (options.sheets) {
    for (var sheet in options.sheets) {
      if (options.sheets[sheet] === true) {
        workbook.SheetNames.push(sheet);
        workbook.Sheets[sheet] = generateSheet();
      } else {
        workbook.SheetNames.push(sheet);
        tableFeatures.commsSend(options.sheets[sheet], "download", "intercept", {
          type: "xlsx",
          options: {
            sheetOnly: true
          },
          active: self.active,
          intercept: function (data) {
            workbook.Sheets[sheet] = data;
          }
        });
      }
    }
  } else {
    workbook.SheetNames.push(sheetName);
    workbook.Sheets[sheetName] = generateSheet();
  }

  if (options.documentProcessing) {
    workbook = options.documentProcessing(workbook);
  } //convert workbook to binary array


  function s2ab(s) {
    var buf = new ArrayBuffer(s.length);
    var view = new Uint8Array(buf);

    for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;

    return buf;
  }

  output = XLSX.write(workbook, {
    bookType: 'xlsx',
    bookSST: true,
    type: 'binary'
  });
  setFileContents(s2ab(output), "application/octet-stream");
}

function html(list, options, setFileContents) {
  if (this.modExists("export", true)) {
    setFileContents(this.modules.export.generateHTMLTable(list), "text/html");
  }
}

function jsonLines(list, options, setFileContents) {
  const fileContents = [];
  list.forEach(row => {
    const item = {};

    switch (row.type) {
      case "header":
        break;

      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;

      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;

      case "row":
        row.columns.forEach(col => {
          if (col) {
            item[col.component.getTitleDownload() || col.component.getField()] = col.value;
          }
        });
        fileContents.push(JSON.stringify(item));
        break;
    }
  });
  setFileContents(fileContents.join("\n"), "application/x-ndjson");
}

var defaultDownloaders = {
  csv: csv,
  json: json,
  jsonLines: jsonLines,
  pdf: pdf,
  xlsx: xlsx,
  html: html
};

class Download extends Module {
  constructor(table) {
    super(table);
    this.registerTableOption("downloadEncoder", function (data, mimeType) {
      return new Blob([data], {
        type: mimeType
      });
    }); //function to manipulate download data

    this.registerTableOption("downloadReady", undefined); //warn of function deprecation

    this.registerTableOption("downloadConfig", {}); //download config

    this.registerTableOption("downloadRowRange", "active"); //restrict download to active rows only

    this.registerColumnOption("download");
    this.registerColumnOption("titleDownload");
  }

  initialize() {
    this.deprecatedOptionsCheck();
    this.registerTableFunction("download", this.download.bind(this));
    this.registerTableFunction("downloadToTab", this.downloadToTab.bind(this));
  }

  deprecatedOptionsCheck() {
    this.deprecationCheck("downloadReady", "downloadEncoder");
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////


  downloadToTab(type, filename, options, active) {
    this.download(type, filename, options, active, true);
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //trigger file download


  download(type, filename, options, range, interceptCallback) {
    var downloadFunc = false;

    function buildLink(data, mime) {
      if (interceptCallback) {
        if (interceptCallback === true) {
          this.triggerDownload(data, mime, type, filename, true);
        } else {
          interceptCallback(data);
        }
      } else {
        this.triggerDownload(data, mime, type, filename);
      }
    }

    if (typeof type == "function") {
      downloadFunc = type;
    } else {
      if (Download.downloaders[type]) {
        downloadFunc = Download.downloaders[type];
      } else {
        console.warn("Download Error - No such download type found: ", type);
      }
    }

    if (downloadFunc) {
      var list = this.generateExportList(range);
      downloadFunc.call(this.table, list, options || {}, buildLink.bind(this));
    }
  }

  generateExportList(range) {
    var list = this.table.modules.export.generateExportList(this.table.options.downloadConfig, false, range || this.table.options.downloadRowRange, "download"); //assign group header formatter

    var groupHeader = this.table.options.groupHeaderDownload;

    if (groupHeader && !Array.isArray(groupHeader)) {
      groupHeader = [groupHeader];
    }

    list.forEach(row => {
      var group;

      if (row.type === "group") {
        group = row.columns[0];

        if (groupHeader && groupHeader[row.indent]) {
          group.value = groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
        }
      }
    });
    return list;
  }

  triggerDownload(data, mime, type, filename, newTab) {
    var element = document.createElement('a'),
        blob = this.table.options.downloadEncoder(data, mime);

    if (blob) {
      if (newTab) {
        window.open(window.URL.createObjectURL(blob));
      } else {
        filename = filename || "Tabulator." + (typeof type === "function" ? "txt" : type);

        if (navigator.msSaveOrOpenBlob) {
          navigator.msSaveOrOpenBlob(blob, filename);
        } else {
          element.setAttribute('href', window.URL.createObjectURL(blob)); //set file title

          element.setAttribute('download', filename); //trigger download

          element.style.display = 'none';
          document.body.appendChild(element);
          element.click(); //remove temporary link element

          document.body.removeChild(element);
        }
      }

      this.dispatchExternal("downloadComplete");
    }
  }

  commsReceived(table, action, data) {
    switch (action) {
      case "intercept":
        this.download(data.type, "", data.options, data.active, data.intercept);
        break;
    }
  }

}

exports.DownloadModule = Download;
Download.moduleName = "download"; //load defaults

Download.downloaders = defaultDownloaders;

function maskInput(el, options) {
  var mask = options.mask,
      maskLetter = typeof options.maskLetterChar !== "undefined" ? options.maskLetterChar : "A",
      maskNumber = typeof options.maskNumberChar !== "undefined" ? options.maskNumberChar : "9",
      maskWildcard = typeof options.maskWildcardChar !== "undefined" ? options.maskWildcardChar : "*";

  function fillSymbols(index) {
    var symbol = mask[index];

    if (typeof symbol !== "undefined" && symbol !== maskWildcard && symbol !== maskLetter && symbol !== maskNumber) {
      el.value = el.value + "" + symbol;
      fillSymbols(index + 1);
    }
  }

  el.addEventListener("keydown", e => {
    var index = el.value.length,
        char = e.key;

    if (e.keyCode > 46) {
      if (index >= mask.length) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      } else {
        switch (mask[index]) {
          case maskLetter:
            if (char.toUpperCase() == char.toLowerCase()) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }

            break;

          case maskNumber:
            if (isNaN(char)) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }

            break;

          case maskWildcard:
            break;

          default:
            if (char !== mask[index]) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }

        }
      }
    }

    return;
  });
  el.addEventListener("keyup", e => {
    if (e.keyCode > 46) {
      if (options.maskAutoFill) {
        fillSymbols(el.value.length);
      }
    }
  });

  if (!el.placeholder) {
    el.placeholder = mask;
  }

  if (options.maskAutoFill) {
    fillSymbols(el.value.length);
  }
} //input element


function input(cell, onRendered, success, cancel, editorParams) {
  //create and style input
  var cellValue = cell.getValue(),
      input = document.createElement("input");
  input.setAttribute("type", editorParams.search ? "search" : "text");
  input.style.padding = "4px";
  input.style.width = "100%";
  input.style.boxSizing = "border-box";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }

  input.value = typeof cellValue !== "undefined" ? cellValue : "";
  onRendered(function () {
    input.focus({
      preventScroll: true
    });
    input.style.height = "100%";

    if (editorParams.selectContents) {
      input.select();
    }
  });

  function onChange(e) {
    if ((cellValue === null || typeof cellValue === "undefined") && input.value !== "" || input.value !== cellValue) {
      if (success(input.value)) {
        cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
      }
    } else {
      cancel();
    }
  } //submit new value on blur or change


  input.addEventListener("change", onChange);
  input.addEventListener("blur", onChange); //submit new value on enter

  input.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      // case 9:
      case 13:
        onChange();
        break;

      case 27:
        cancel();
        break;

      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });

  if (editorParams.mask) {
    maskInput(input, editorParams);
  }

  return input;
} //resizable text area element


function textarea(cell, onRendered, success, cancel, editorParams) {
  var cellValue = cell.getValue(),
      vertNav = editorParams.verticalNavigation || "hybrid",
      value = String(cellValue !== null && typeof cellValue !== "undefined" ? cellValue : ""),
      input = document.createElement("textarea"),
      scrollHeight = 0; //create and style input

  input.style.display = "block";
  input.style.padding = "2px";
  input.style.height = "100%";
  input.style.width = "100%";
  input.style.boxSizing = "border-box";
  input.style.whiteSpace = "pre-wrap";
  input.style.resize = "none";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }

  input.value = value;
  onRendered(function () {
    input.focus({
      preventScroll: true
    });
    input.style.height = "100%";
    input.scrollHeight;
    input.style.height = input.scrollHeight + "px";
    cell.getRow().normalizeHeight();

    if (editorParams.selectContents) {
      input.select();
    }
  });

  function onChange(e) {
    if ((cellValue === null || typeof cellValue === "undefined") && input.value !== "" || input.value !== cellValue) {
      if (success(input.value)) {
        cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
      }

      setTimeout(function () {
        cell.getRow().normalizeHeight();
      }, 300);
    } else {
      cancel();
    }
  } //submit new value on blur or change


  input.addEventListener("change", onChange);
  input.addEventListener("blur", onChange);
  input.addEventListener("keyup", function () {
    input.style.height = "";
    var heightNow = input.scrollHeight;
    input.style.height = heightNow + "px";

    if (heightNow != scrollHeight) {
      scrollHeight = heightNow;
      cell.getRow().normalizeHeight();
    }
  });
  input.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      case 13:
        if (e.shiftKey && editorParams.shiftEnterSubmit) {
          onChange();
        }

        break;

      case 27:
        cancel();
        break;

      case 38:
        //up arrow
        if (vertNav == "editor" || vertNav == "hybrid" && input.selectionStart) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }

        break;

      case 40:
        //down arrow
        if (vertNav == "editor" || vertNav == "hybrid" && input.selectionStart !== input.value.length) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }

        break;

      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });

  if (editorParams.mask) {
    maskInput(input, editorParams);
  }

  return input;
} //input element with type of number


function number(cell, onRendered, success, cancel, editorParams) {
  var cellValue = cell.getValue(),
      vertNav = editorParams.verticalNavigation || "editor",
      input = document.createElement("input");
  input.setAttribute("type", "number");

  if (typeof editorParams.max != "undefined") {
    input.setAttribute("max", editorParams.max);
  }

  if (typeof editorParams.min != "undefined") {
    input.setAttribute("min", editorParams.min);
  }

  if (typeof editorParams.step != "undefined") {
    input.setAttribute("step", editorParams.step);
  } //create and style input


  input.style.padding = "4px";
  input.style.width = "100%";
  input.style.boxSizing = "border-box";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }

  input.value = cellValue;

  var blurFunc = function (e) {
    onChange();
  };

  onRendered(function () {
    //submit new value on blur
    input.removeEventListener("blur", blurFunc);
    input.focus({
      preventScroll: true
    });
    input.style.height = "100%"; //submit new value on blur

    input.addEventListener("blur", blurFunc);

    if (editorParams.selectContents) {
      input.select();
    }
  });

  function onChange() {
    var value = input.value;

    if (!isNaN(value) && value !== "") {
      value = Number(value);
    }

    if (value !== cellValue) {
      if (success(value)) {
        cellValue = value; //persist value if successfully validated incase editor is used as header filter
      }
    } else {
      cancel();
    }
  } //submit new value on enter


  input.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      case 13:
        // case 9:
        onChange();
        break;

      case 27:
        cancel();
        break;

      case 38: //up arrow

      case 40:
        //down arrow
        if (vertNav == "editor") {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }

        break;

      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });

  if (editorParams.mask) {
    maskInput(input, editorParams);
  }

  return input;
} //input element with type of number


function range(cell, onRendered, success, cancel, editorParams) {
  var cellValue = cell.getValue(),
      input = document.createElement("input");
  input.setAttribute("type", "range");

  if (typeof editorParams.max != "undefined") {
    input.setAttribute("max", editorParams.max);
  }

  if (typeof editorParams.min != "undefined") {
    input.setAttribute("min", editorParams.min);
  }

  if (typeof editorParams.step != "undefined") {
    input.setAttribute("step", editorParams.step);
  } //create and style input


  input.style.padding = "4px";
  input.style.width = "100%";
  input.style.boxSizing = "border-box";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }

  input.value = cellValue;
  onRendered(function () {
    input.focus({
      preventScroll: true
    });
    input.style.height = "100%";
  });

  function onChange() {
    var value = input.value;

    if (!isNaN(value) && value !== "") {
      value = Number(value);
    }

    if (value != cellValue) {
      if (success(value)) {
        cellValue = value; //persist value if successfully validated incase editor is used as header filter
      }
    } else {
      cancel();
    }
  } //submit new value on blur


  input.addEventListener("blur", function (e) {
    onChange();
  }); //submit new value on enter

  input.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      case 13:
        // case 9:
        onChange();
        break;

      case 27:
        cancel();
        break;
    }
  });
  return input;
} //input element


function date(cell, onRendered, success, cancel, editorParams) {
  var inputFormat = editorParams.format,
      DT = inputFormat ? window.DateTime || luxon.DateTime : null; //create and style input

  var cellValue = cell.getValue(),
      input = document.createElement("input");

  function convertDate(value) {
    var newDatetime;

    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }

    return newDatetime.toFormat("yyyy-MM-dd");
  }

  input.type = "date";
  input.style.padding = "4px";
  input.style.width = "100%";
  input.style.boxSizing = "border-box";

  if (editorParams.max) {
    input.setAttribute("max", inputFormat ? convertDate(editorParams.max) : editorParams.max);
  }

  if (editorParams.min) {
    input.setAttribute("min", inputFormat ? convertDate(editorParams.min) : editorParams.min);
  }

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }

  cellValue = typeof cellValue !== "undefined" ? cellValue : "";

  if (inputFormat) {
    if (DT) {
      cellValue = convertDate(cellValue);
    } else {
      console.error("Editor Error - 'date' editor 'inputFormat' param is dependant on luxon.js");
    }
  }

  input.value = cellValue;
  onRendered(function () {
    input.focus({
      preventScroll: true
    });
    input.style.height = "100%";

    if (editorParams.selectContents) {
      input.select();
    }
  });

  function onChange(e) {
    var value = input.value;

    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        value = DT.fromFormat(String(value), "yyyy-MM-dd").toFormat(inputFormat);
      }

      if (success(value)) {
        cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
      }
    } else {
      cancel();
    }
  } //submit new value on blur or change


  input.addEventListener("change", onChange);
  input.addEventListener("blur", onChange); //submit new value on enter

  input.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      // case 9:
      case 13:
        onChange();
        break;

      case 27:
        cancel();
        break;

      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  return input;
} //input element


function time(cell, onRendered, success, cancel, editorParams) {
  var inputFormat = editorParams.format,
      DT = inputFormat ? window.DateTime || luxon.DateTime : null,
      newDatetime; //create and style input

  var cellValue = cell.getValue(),
      input = document.createElement("input");
  input.type = "time";
  input.style.padding = "4px";
  input.style.width = "100%";
  input.style.boxSizing = "border-box";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }

  cellValue = typeof cellValue !== "undefined" ? cellValue : "";

  if (inputFormat) {
    if (DT) {
      if (DT.isDateTime(cellValue)) {
        newDatetime = cellValue;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(cellValue));
      } else {
        newDatetime = DT.fromFormat(String(cellValue), inputFormat);
      }

      cellValue = newDatetime.toFormat("hh:mm");
    } else {
      console.error("Editor Error - 'date' editor 'inputFormat' param is dependant on luxon.js");
    }
  }

  input.value = cellValue;
  onRendered(function () {
    input.focus({
      preventScroll: true
    });
    input.style.height = "100%";

    if (editorParams.selectContents) {
      input.select();
    }
  });

  function onChange(e) {
    var value = input.value;

    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        value = DT.fromFormat(String(value), "hh:mm").toFormat(inputFormat);
      }

      if (success(value)) {
        cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
      }
    } else {
      cancel();
    }
  } //submit new value on blur or change


  input.addEventListener("change", onChange);
  input.addEventListener("blur", onChange); //submit new value on enter

  input.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      // case 9:
      case 13:
        onChange();
        break;

      case 27:
        cancel();
        break;

      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  return input;
} //input element


function datetime(cell, onRendered, success, cancel, editorParams) {
  var inputFormat = editorParams.format,
      DT = inputFormat ? window.DateTime || luxon.DateTime : null,
      newDatetime; //create and style input

  var cellValue = cell.getValue(),
      input = document.createElement("input");
  input.type = "datetime-local";
  input.style.padding = "4px";
  input.style.width = "100%";
  input.style.boxSizing = "border-box";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }

  cellValue = typeof cellValue !== "undefined" ? cellValue : "";

  if (inputFormat) {
    if (DT) {
      if (DT.isDateTime(cellValue)) {
        newDatetime = cellValue;
      } else if (inputFormat === "iso") {
        newDatetime = DT.fromISO(String(cellValue));
      } else {
        newDatetime = DT.fromFormat(String(cellValue), inputFormat);
      }

      cellValue = newDatetime.toFormat("yyyy-MM-dd") + "T" + newDatetime.toFormat("hh:mm");
    } else {
      console.error("Editor Error - 'date' editor 'inputFormat' param is dependant on luxon.js");
    }
  }

  input.value = cellValue;
  onRendered(function () {
    input.focus({
      preventScroll: true
    });
    input.style.height = "100%";

    if (editorParams.selectContents) {
      input.select();
    }
  });

  function onChange(e) {
    var value = input.value;

    if ((cellValue === null || typeof cellValue === "undefined") && value !== "" || value !== cellValue) {
      if (value && inputFormat) {
        value = DT.fromISO(String(value)).toFormat(inputFormat);
      }

      if (success(value)) {
        cellValue = input.value; //persist value if successfully validated incase editor is used as header filter
      }
    } else {
      cancel();
    }
  } //submit new value on blur or change


  input.addEventListener("change", onChange);
  input.addEventListener("blur", onChange); //submit new value on enter

  input.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      // case 9:
      case 13:
        onChange();
        break;

      case 27:
        cancel();
        break;

      case 35:
      case 36:
        e.stopPropagation();
        break;
    }
  });
  return input;
}

class Edit {
  constructor(editor, cell, onRendered, success, cancel, editorParams) {
    this.edit = editor;
    this.table = editor.table;
    this.cell = cell;
    this.params = this._initializeParams(editorParams);
    this.data = [];
    this.displayItems = [];
    this.currentItems = [];
    this.focusedItem = null;
    this.input = this._createInputElement();
    this.listEl = this._createListElement();
    this.initialValues = null;
    this.isFilter = !cell._getSelf;
    this.filterTimeout = null;
    this.filtered = false;
    this.typing = false;
    this.values = [];
    this.popup = null;
    this.listIteration = 0;
    this.lastAction = "";
    this.blurable = true;
    this.actions = {
      success: success,
      cancel: cancel
    };

    this._deprecatedOptionsCheck();

    this._initializeValue();

    onRendered(this._onRendered.bind(this));
  }

  _deprecatedOptionsCheck() {
    if (this.params.listItemFormatter) {
      this.cell.getTable().deprecationAdvisor.msg("The listItemFormatter editor param has been deprecated, please see the latest editor documentation for updated options");
    }

    if (this.params.sortValuesList) {
      this.cell.getTable().deprecationAdvisor.msg("The sortValuesList editor param has been deprecated, please see the latest editor documentation for updated options");
    }

    if (this.params.searchFunc) {
      this.cell.getTable().deprecationAdvisor.msg("The searchFunc editor param has been deprecated, please see the latest editor documentation for updated options");
    }

    if (this.params.searchingPlaceholder) {
      this.cell.getTable().deprecationAdvisor.msg("The searchingPlaceholder editor param has been deprecated, please see the latest editor documentation for updated options");
    }
  }

  _initializeValue() {
    var initialValue = this.cell.getValue();

    if (typeof initialValue === "undefined" && typeof this.params.defaultValue !== "undefined") {
      initialValue = this.params.defaultValue;
    }

    this.initialValues = this.params.multiselect ? initialValue : [initialValue];

    if (this.isFilter) {
      this.input.value = this.initialValues ? this.initialValues.join(",") : "";
      this.headerFilterInitialListGen();
    }
  }

  _onRendered() {
    var cellEl = this.cell.getElement();

    function clickStop(e) {
      e.stopPropagation();
    }

    this.input.style.height = "100%";
    this.input.focus({
      preventScroll: true
    });
    cellEl.addEventListener("click", clickStop);
    setTimeout(() => {
      cellEl.removeEventListener("click", clickStop);
    }, 1000);
    this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
  }

  _createListElement() {
    var listEl = document.createElement("div");
    listEl.classList.add("tabulator-edit-list");
    listEl.addEventListener("mousedown", this._preventBlur.bind(this));
    listEl.addEventListener("keydown", this._inputKeyDown.bind(this));
    return listEl;
  }

  _setListWidth() {
    var element = this.isFilter ? this.input : this.cell.getElement();
    this.listEl.style.minWidth = element.offsetWidth + "px";

    if (this.params.maxWidth) {
      if (this.params.maxWidth === true) {
        this.listEl.style.maxWidth = element.offsetWidth + "px";
      } else if (typeof this.params.maxWidth === "number") {
        this.listEl.style.maxWidth = this.params.maxWidth + "px";
      } else {
        this.listEl.style.maxWidth = this.params.maxWidth;
      }
    }
  }

  _createInputElement() {
    var attribs = this.params.elementAttributes;
    var input = document.createElement("input");
    input.setAttribute("type", this.params.clearable ? "search" : "text");
    input.style.padding = "4px";
    input.style.width = "100%";
    input.style.boxSizing = "border-box";

    if (!this.params.autocomplete) {
      input.style.cursor = "default";
      input.style.caretColor = "transparent"; // input.readOnly = (this.edit.currentCell != false);
    }

    if (attribs && typeof attribs == "object") {
      for (let key in attribs) {
        if (key.charAt(0) == "+") {
          key = key.slice(1);
          input.setAttribute(key, input.getAttribute(key) + attribs["+" + key]);
        } else {
          input.setAttribute(key, attribs[key]);
        }
      }
    }

    if (this.params.mask) {
      maskInput(input, this.params);
    }

    this._bindInputEvents(input);

    return input;
  }

  _initializeParams(params) {
    var valueKeys = ["values", "valuesURL", "valuesLookup"],
        valueCheck;
    params = Object.assign({}, params);
    params.verticalNavigation = params.verticalNavigation || "editor";
    params.placeholderLoading = typeof params.placeholderLoading === "undefined" ? "Searching ..." : params.placeholderLoading;
    params.placeholderEmpty = typeof params.placeholderEmpty === "undefined" ? "No Results Found" : params.placeholderEmpty;
    params.filterDelay = typeof params.filterDelay === "undefined" ? 300 : params.filterDelay;
    params.emptyValue = Object.keys(params).includes("emptyValue") ? params.emptyValue : "";
    valueCheck = Object.keys(params).filter(key => valueKeys.includes(key)).length;

    if (!valueCheck) {
      console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set");
    } else if (valueCheck > 1) {
      console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor");
    }

    if (params.autocomplete) {
      if (params.multiselect) {
        params.multiselect = false;
        console.warn("list editor config error - multiselect option is not available when autocomplete is enabled");
      }
    } else {
      if (params.freetext) {
        params.freetext = false;
        console.warn("list editor config error - freetext option is only available when autocomplete is enabled");
      }

      if (params.filterFunc) {
        params.filterFunc = false;
        console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled");
      }

      if (params.filterRemote) {
        params.filterRemote = false;
        console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled");
      }

      if (params.mask) {
        params.mask = false;
        console.warn("list editor config error - mask option is only available when autocomplete is enabled");
      }

      if (params.allowEmpty) {
        params.allowEmpty = false;
        console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled");
      }

      if (params.listOnEmpty) {
        params.listOnEmpty = false;
        console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled");
      }
    }

    if (params.filterRemote && !(typeof params.valuesLookup === "function" || params.valuesURL)) {
      params.filterRemote = false;
      console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source");
    }

    return params;
  } //////////////////////////////////////
  ////////// Event Handling ////////////
  //////////////////////////////////////


  _bindInputEvents(input) {
    input.addEventListener("focus", this._inputFocus.bind(this));
    input.addEventListener("click", this._inputClick.bind(this));
    input.addEventListener("blur", this._inputBlur.bind(this));
    input.addEventListener("keydown", this._inputKeyDown.bind(this));
    input.addEventListener("search", this._inputSearch.bind(this));

    if (this.params.autocomplete) {
      input.addEventListener("keyup", this._inputKeyUp.bind(this));
    }
  }

  _inputFocus(e) {
    this.rebuildOptionsList();
  }

  _filter() {
    if (this.params.filterRemote) {
      clearTimeout(this.filterTimeout);
      this.filterTimeout = setTimeout(() => {
        this.rebuildOptionsList();
      }, this.params.filterDelay);
    } else {
      this._filterList();
    }
  }

  _inputClick(e) {
    e.stopPropagation();
  }

  _inputBlur(e) {
    if (this.blurable) {
      if (this.popup) {
        this.popup.hide();
      } else {
        this._resolveValue(true);
      }
    }
  }

  _inputSearch() {
    this._clearChoices();
  }

  _inputKeyDown(e) {
    switch (e.keyCode) {
      case 38:
        //up arrow
        this._keyUp(e);

        break;

      case 40:
        //down arrow
        this._keyDown(e);

        break;

      case 37: //left arrow

      case 39:
        //right arrow
        this._keySide(e);

        break;

      case 13:
        //enter
        this._keyEnter();

        break;

      case 27:
        //escape
        this._keyEsc();

        break;

      case 36: //home

      case 35:
        //end
        this._keyHomeEnd(e);

        break;

      case 9:
        //tab
        break;

      default:
        this._keySelectLetter(e);

    }
  }

  _inputKeyUp(e) {
    switch (e.keyCode) {
      case 38: //up arrow

      case 37: //left arrow

      case 39: //up arrow

      case 40: //right arrow

      case 13: //enter

      case 27:
        //escape
        break;

      default:
        this._keyAutoCompLetter(e);

    }
  }

  _preventPopupBlur() {
    if (this.popup) {
      this.popup.blockHide();
    }

    setTimeout(() => {
      if (this.popup) {
        this.popup.restoreHide();
      }
    }, 10);
  }

  _preventBlur() {
    this.blurable = false;
    setTimeout(() => {
      this.blurable = true;
    }, 10);
  } //////////////////////////////////////
  //////// Keyboard Navigation /////////
  //////////////////////////////////////


  _keyUp(e) {
    var index = this.displayItems.indexOf(this.focusedItem);

    if (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && index) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();

      if (index > 0) {
        this._focusItem(this.displayItems[index - 1]);
      }
    }
  }

  _keyDown(e) {
    var index = this.displayItems.indexOf(this.focusedItem);

    if (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && index < this.displayItems.length - 1) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();

      if (index < this.displayItems.length - 1) {
        if (index == -1) {
          this._focusItem(this.displayItems[0]);
        } else {
          this._focusItem(this.displayItems[index + 1]);
        }
      }
    }
  }

  _keySide(e) {
    e.stopImmediatePropagation();
    e.stopPropagation();
    e.preventDefault();
  }

  _keyEnter(e) {
    if (this.params.autocomplete && this.lastAction === "typing") {
      this._resolveValue(true);
    } else {
      if (this.focusedItem) {
        this._chooseItem(this.focusedItem);
      }
    }
  }

  _keyEsc(e) {
    this._cancel();
  }

  _keyHomeEnd(e) {
    if (this.params.autocomplete) {
      //prevent table navigation while using input element
      e.stopImmediatePropagation();
    }
  }

  _keySelectLetter(e) {
    if (!this.params.autocomplete) {
      // if(this.edit.currentCell === false){
      e.preventDefault(); // }

      if (e.keyCode >= 38 && e.keyCode <= 90) {
        this._scrollToValue(e.keyCode);
      }
    }
  }

  _keyAutoCompLetter(e) {
    this._filter();

    this.lastAction = "typing";
    this.typing = true;
  }

  _scrollToValue(char) {
    clearTimeout(this.filterTimeout);
    var character = String.fromCharCode(char).toLowerCase();
    this.filterTerm += character.toLowerCase();
    var match = this.displayItems.find(item => {
      return typeof item.label !== "undefined" && item.label.toLowerCase().startsWith(this.filterTerm);
    });

    if (match) {
      this._focusItem(match);
    }

    this.filterTimeout = setTimeout(() => {
      this.filterTerm = "";
    }, 800);
  }

  _focusItem(item) {
    this.lastAction = "focus";

    if (this.focusedItem && this.focusedItem.element) {
      this.focusedItem.element.classList.remove("focused");
    }

    this.focusedItem = item;

    if (item && item.element) {
      item.element.classList.add("focused");
      item.element.scrollIntoView({
        behavior: 'smooth',
        block: 'nearest',
        inline: 'start'
      });
    }
  } //////////////////////////////////////
  /////// Data List Generation /////////
  //////////////////////////////////////


  headerFilterInitialListGen() {
    this._generateOptions(true);
  }

  rebuildOptionsList() {
    this._generateOptions().then(this._sortOptions.bind(this)).then(this._buildList.bind(this)).then(this._showList.bind(this)).catch(e => {
      if (!Number.isInteger(e)) {
        console.error("List generation error", e);
      }
    });
  }

  _filterList() {
    this._buildList(this._filterOptions());

    this._showList();
  }

  _generateOptions(silent) {
    var values = [];
    var iteration = ++this.listIteration;
    this.filtered = false;

    if (this.params.values) {
      values = this.params.values;
    } else if (this.params.valuesURL) {
      values = this._ajaxRequest(this.params.valuesURL, this.input.value);
    } else {
      if (typeof this.params.valuesLookup === "function") {
        values = this.params.valuesLookup(this.cell, this.input.value);
      } else if (this.params.valuesLookup) {
        values = this._uniqueColumnValues(this.params.valuesLookupField);
      }
    }

    if (values instanceof Promise) {
      if (!silent) {
        this._addPlaceholder(this.params.placeholderLoading);
      }

      return values.then().then(responseValues => {
        if (this.listIteration === iteration) {
          return this._parseList(responseValues);
        } else {
          return Promise.reject(iteration);
        }
      });
    } else {
      return Promise.resolve(this._parseList(values));
    }
  }

  _addPlaceholder(contents) {
    var placeholder = document.createElement("div");

    if (typeof contents === "function") {
      contents = contents(this.cell.getComponent(), this.listEl);
    }

    if (contents) {
      this._clearList();

      if (contents instanceof HTMLElement) {
        placeholder = contents;
      } else {
        placeholder.classList.add("tabulator-edit-list-placeholder");
        placeholder.innerHTML = contents;
      }

      this.listEl.appendChild(placeholder);

      this._showList();
    }
  }

  _ajaxRequest(url, term) {
    var params = this.params.filterRemote ? {
      term: term
    } : {};
    url = urlBuilder(url, {}, params);
    return fetch(url).then(response => {
      if (response.ok) {
        return response.json().catch(error => {
          console.warn("List Ajax Load Error - Invalid JSON returned", error);
          return Promise.reject(error);
        });
      } else {
        console.error("List Ajax Load Error - Connection Error: " + response.status, response.statusText);
        return Promise.reject(response);
      }
    }).catch(error => {
      console.error("List Ajax Load Error - Connection Error: ", error);
      return Promise.reject(error);
    });
  }

  _uniqueColumnValues(field) {
    var output = {},
        data = this.table.getData(this.params.valuesLookup),
        column;

    if (field) {
      column = this.table.columnManager.getColumnByField(field);
    } else {
      column = this.cell.getColumn()._getSelf();
    }

    if (column) {
      data.forEach(row => {
        var val = column.getFieldValue(row);

        if (val !== null && typeof val !== "undefined" && val !== "") {
          output[val] = true;
        }
      });
    } else {
      console.warn("unable to find matching column to create select lookup list:", field);
      output = [];
    }

    return Object.keys(output);
  }

  _parseList(inputValues) {
    var data = [];

    if (!Array.isArray(inputValues)) {
      inputValues = Object.entries(inputValues).map(([key, value]) => {
        return {
          label: value,
          value: key
        };
      });
    }

    inputValues.forEach(value => {
      if (typeof value !== "object") {
        value = {
          label: value,
          value: value
        };
      }

      this._parseListItem(value, data, 0);
    });

    if (!this.currentItems.length && this.params.freetext) {
      this.input.value = this.initialValues;
      this.typing = true;
      this.lastAction = "typing";
    }

    this.data = data;
    return data;
  }

  _parseListItem(option, data, level) {
    var item = {};

    if (option.options) {
      item = this._parseListGroup(option, level + 1);
    } else {
      item = {
        label: option.label,
        value: option.value,
        itemParams: option.itemParams,
        elementAttributes: option.elementAttributes,
        element: false,
        selected: false,
        visible: true,
        level: level,
        original: option
      };

      if (this.initialValues && this.initialValues.indexOf(option.value) > -1) {
        this._chooseItem(item, true);
      }
    }

    data.push(item);
  }

  _parseListGroup(option, level) {
    var item = {
      label: option.label,
      group: true,
      itemParams: option.itemParams,
      elementAttributes: option.elementAttributes,
      element: false,
      visible: true,
      level: level,
      options: [],
      original: option
    };
    option.options.forEach(child => {
      this._parseListItem(child, item.options, level);
    });
    return item;
  }

  _sortOptions(options) {
    var sorter;

    if (this.params.sort) {
      sorter = typeof this.params.sort === "function" ? this.params.sort : this._defaultSortFunction.bind(this);

      this._sortGroup(sorter, options);
    }

    return options;
  }

  _sortGroup(sorter, options) {
    options.sort((a, b) => {
      return sorter(a.label, b.label, a.value, b.value, a.original, b.original);
    });
    options.forEach(option => {
      if (option.group) {
        this._sortGroup(sorter, option.options);
      }
    });
  }

  _defaultSortFunction(as, bs) {
    var a,
        b,
        a1,
        b1,
        i = 0,
        L,
        rx = /(\d+)|(\D+)/g,
        rd = /\d/;
    var emptyAlign = 0;

    if (this.params.sort === "desc") {
      [as, bs] = [bs, as];
    } //handle empty values


    if (!as && as !== 0) {
      emptyAlign = !bs && bs !== 0 ? 0 : -1;
    } else if (!bs && bs !== 0) {
      emptyAlign = 1;
    } else {
      if (isFinite(as) && isFinite(bs)) return as - bs;
      a = String(as).toLowerCase();
      b = String(bs).toLowerCase();
      if (a === b) return 0;
      if (!(rd.test(a) && rd.test(b))) return a > b ? 1 : -1;
      a = a.match(rx);
      b = b.match(rx);
      L = a.length > b.length ? b.length : a.length;

      while (i < L) {
        a1 = a[i];
        b1 = b[i++];

        if (a1 !== b1) {
          if (isFinite(a1) && isFinite(b1)) {
            if (a1.charAt(0) === "0") a1 = "." + a1;
            if (b1.charAt(0) === "0") b1 = "." + b1;
            return a1 - b1;
          } else return a1 > b1 ? 1 : -1;
        }
      }

      return a.length > b.length;
    }

    return emptyAlign;
  }

  _filterOptions() {
    var filterFunc = this.params.filterFunc || this._defaultFilterFunc,
        term = this.input.value;

    if (term) {
      this.filtered = true;
      this.data.forEach(item => {
        this._filterItem(filterFunc, term, item);
      });
    } else {
      this.filtered = false;
    }

    return this.data;
  }

  _filterItem(func, term, item) {
    var matches = false;

    if (!item.group) {
      item.visible = func(term, item.label, item.value, item.original);
    } else {
      item.options.forEach(option => {
        if (this._filterItem(func, term, option)) {
          matches = true;
        }
      });
      item.visible = matches;
    }

    return item.visible;
  }

  _defaultFilterFunc(term, label, value, item) {
    term = String(term).toLowerCase();

    if (label !== null && typeof label !== "undefined") {
      if (String(label).toLowerCase().indexOf(term) > -1 || String(value).toLowerCase().indexOf(term) > -1) {
        return true;
      }
    }

    return false;
  } //////////////////////////////////////
  /////////// Display List /////////////
  //////////////////////////////////////


  _clearList() {
    while (this.listEl.firstChild) this.listEl.removeChild(this.listEl.firstChild);

    this.displayItems = [];
  }

  _buildList(data) {
    this._clearList();

    data.forEach(option => {
      this._buildItem(option);
    });

    if (!this.displayItems.length) {
      this._addPlaceholder(this.params.placeholderEmpty);
    }
  }

  _buildItem(item) {
    var el = item.element,
        contents;

    if (!this.filtered || item.visible) {
      if (!el) {
        el = document.createElement("div");
        el.tabIndex = 0;
        contents = this.params.itemFormatter ? this.params.itemFormatter(item.label, item.value, item.original, el) : item.label;

        if (contents instanceof HTMLElement) {
          el.appendChild(contents);
        } else {
          el.innerHTML = contents;
        }

        if (item.group) {
          el.classList.add("tabulator-edit-list-group");
        } else {
          el.classList.add("tabulator-edit-list-item");
        }

        el.classList.add("tabulator-edit-list-group-level-" + item.level);

        if (item.elementAttributes && typeof item.elementAttributes == "object") {
          for (let key in item.elementAttributes) {
            if (key.charAt(0) == "+") {
              key = key.slice(1);
              el.setAttribute(key, this.input.getAttribute(key) + item.elementAttributes["+" + key]);
            } else {
              el.setAttribute(key, item.elementAttributes[key]);
            }
          }
        }

        if (item.group) {
          el.addEventListener("click", this._groupClick.bind(this, item));
        } else {
          el.addEventListener("click", this._itemClick.bind(this, item));
        }

        el.addEventListener("mousedown", this._preventBlur.bind(this));
        item.element = el;
      }

      this._styleItem(item);

      this.listEl.appendChild(el);

      if (item.group) {
        item.options.forEach(option => {
          this._buildItem(option);
        });
      } else {
        this.displayItems.push(item);
      }
    }
  }

  _showList() {
    var startVis = this.popup && this.popup.isVisible();

    if (this.input.parentNode) {
      if (this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty) {
        if (this.popup) {
          this.popup.hide(true);
        }

        return;
      }

      this._setListWidth();

      if (!this.popup) {
        this.popup = this.edit.popup(this.listEl);
      }

      this.popup.show(this.cell.getElement(), "bottom");

      if (!startVis) {
        setTimeout(() => {
          this.popup.hideOnBlur(this._resolveValue.bind(this, true));
        }, 10);
      }
    }
  }

  _styleItem(item) {
    if (item && item.element) {
      if (item.selected) {
        item.element.classList.add("active");
      } else {
        item.element.classList.remove("active");
      }
    }
  } //////////////////////////////////////
  ///////// User Interaction ///////////
  //////////////////////////////////////


  _itemClick(item, e) {
    e.stopPropagation();

    this._chooseItem(item);
  }

  _groupClick(item, e) {
    e.stopPropagation();
  } //////////////////////////////////////
  ////// Current Item Management ///////
  //////////////////////////////////////


  _cancel() {
    this.popup.hide(true);
    this.actions.cancel();
  }

  _clearChoices() {
    this.typing = true;
    this.currentItems.forEach(item => {
      item.selected = false;

      this._styleItem(item);
    });
    this.currentItems = [];
    this.focusedItem = null;
  }

  _chooseItem(item, silent) {
    var index;
    this.typing = false;

    if (this.params.multiselect) {
      index = this.currentItems.indexOf(item);

      if (index > -1) {
        this.currentItems.splice(index, 1);
        item.selected = false;
      } else {
        this.currentItems.push(item);
        item.selected = true;
      }

      this.input.value = this.currentItems.map(item => item.label).join(",");

      this._styleItem(item);
    } else {
      this.currentItems = [item];
      item.selected = true;
      this.input.value = item.label;

      this._styleItem(item);

      if (!silent) {
        this._resolveValue();
      }
    }

    this._focusItem(item);
  }

  _resolveValue(blur) {
    var output, initialValue;

    if (this.popup) {
      this.popup.hide(true);
    }

    if (this.params.multiselect) {
      output = this.currentItems.map(item => item.value);
    } else {
      if (blur && this.params.autocomplete && this.typing) {
        if (this.params.freetext || this.params.allowEmpty && this.input.value === "") {
          output = this.input.value;
        } else {
          this.actions.cancel();
          return;
        }
      } else {
        if (this.currentItems[0]) {
          output = this.currentItems[0].value;
        } else {
          initialValue = this.initialValues[0];

          if (initialValue === null || typeof initialValue === "undefined" || initialValue === "") {
            output = initialValue;
          } else {
            output = this.params.emptyValue;
          }
        }
      }
    }

    if (output === "") {
      output = this.params.emptyValue;
    }

    this.actions.success(output);

    if (this.isFilter) {
      this.initialValues = output && !Array.isArray(output) ? [output] : output;
      this.currentItems = [];
    }
  }

}

function select(cell, onRendered, success, cancel, editorParams) {
  this.deprecationMsg("The select editor has been deprecated, please use the new list editor");
  var list = new Edit(this, cell, onRendered, success, cancel, editorParams);
  return list.input;
}

function list(cell, onRendered, success, cancel, editorParams) {
  var list = new Edit(this, cell, onRendered, success, cancel, editorParams);
  return list.input;
}

function autocomplete(cell, onRendered, success, cancel, editorParams) {
  this.deprecationMsg("The autocomplete editor has been deprecated, please use the new list editor with the 'autocomplete' editorParam");
  editorParams.autocomplete = true;
  var list = new Edit(this, cell, onRendered, success, cancel, editorParams);
  return list.input;
} //star rating


function star(cell, onRendered, success, cancel, editorParams) {
  var self = this,
      element = cell.getElement(),
      value = cell.getValue(),
      maxStars = element.getElementsByTagName("svg").length || 5,
      size = element.getElementsByTagName("svg")[0] ? element.getElementsByTagName("svg")[0].getAttribute("width") : 14,
      stars = [],
      starsHolder = document.createElement("div"),
      star = document.createElementNS('http://www.w3.org/2000/svg', "svg"); //change star type

  function starChange(val) {
    stars.forEach(function (star, i) {
      if (i < val) {
        if (self.table.browser == "ie") {
          star.setAttribute("class", "tabulator-star-active");
        } else {
          star.classList.replace("tabulator-star-inactive", "tabulator-star-active");
        }

        star.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
      } else {
        if (self.table.browser == "ie") {
          star.setAttribute("class", "tabulator-star-inactive");
        } else {
          star.classList.replace("tabulator-star-active", "tabulator-star-inactive");
        }

        star.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
      }
    });
  } //build stars


  function buildStar(i) {
    var starHolder = document.createElement("span");
    var nextStar = star.cloneNode(true);
    stars.push(nextStar);
    starHolder.addEventListener("mouseenter", function (e) {
      e.stopPropagation();
      e.stopImmediatePropagation();
      starChange(i);
    });
    starHolder.addEventListener("mousemove", function (e) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    });
    starHolder.addEventListener("click", function (e) {
      e.stopPropagation();
      e.stopImmediatePropagation();
      success(i);
      element.blur();
    });
    starHolder.appendChild(nextStar);
    starsHolder.appendChild(starHolder);
  } //handle keyboard navigation value change


  function changeValue(val) {
    value = val;
    starChange(val);
  } //style cell


  element.style.whiteSpace = "nowrap";
  element.style.overflow = "hidden";
  element.style.textOverflow = "ellipsis"; //style holding element

  starsHolder.style.verticalAlign = "middle";
  starsHolder.style.display = "inline-block";
  starsHolder.style.padding = "4px"; //style star

  star.setAttribute("width", size);
  star.setAttribute("height", size);
  star.setAttribute("viewBox", "0 0 512 512");
  star.setAttribute("xml:space", "preserve");
  star.style.padding = "0 1px";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        starsHolder.setAttribute(key, starsHolder.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        starsHolder.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  } //create correct number of stars


  for (var i = 1; i <= maxStars; i++) {
    buildStar(i);
  } //ensure value does not exceed number of stars


  value = Math.min(parseInt(value), maxStars); // set initial styling of stars

  starChange(value);
  starsHolder.addEventListener("mousemove", function (e) {
    starChange(0);
  });
  starsHolder.addEventListener("click", function (e) {
    success(0);
  });
  element.addEventListener("blur", function (e) {
    cancel();
  }); //allow key based navigation

  element.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      case 39:
        //right arrow
        changeValue(value + 1);
        break;

      case 37:
        //left arrow
        changeValue(value - 1);
        break;

      case 13:
        //enter
        success(value);
        break;

      case 27:
        //escape
        cancel();
        break;
    }
  });
  return starsHolder;
} //draggable progress bar


function progress(cell, onRendered, success, cancel, editorParams) {
  var element = cell.getElement(),
      max = typeof editorParams.max === "undefined" ? element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("max") || 100 : editorParams.max,
      min = typeof editorParams.min === "undefined" ? element.getElementsByTagName("div")[0] && element.getElementsByTagName("div")[0].getAttribute("min") || 0 : editorParams.min,
      percent = (max - min) / 100,
      value = cell.getValue() || 0,
      handle = document.createElement("div"),
      bar = document.createElement("div"),
      mouseDrag,
      mouseDragWidth; //set new value

  function updateValue() {
    var style = window.getComputedStyle(element, null);
    var calcVal = percent * Math.round(bar.offsetWidth / ((element.clientWidth - parseInt(style.getPropertyValue("padding-left")) - parseInt(style.getPropertyValue("padding-right"))) / 100)) + min;
    success(calcVal);
    element.setAttribute("aria-valuenow", calcVal);
    element.setAttribute("aria-label", value);
  } //style handle


  handle.style.position = "absolute";
  handle.style.right = "0";
  handle.style.top = "0";
  handle.style.bottom = "0";
  handle.style.width = "5px";
  handle.classList.add("tabulator-progress-handle"); //style bar

  bar.style.display = "inline-block";
  bar.style.position = "relative"; // bar.style.top = "8px";
  // bar.style.bottom = "8px";
  // bar.style.left = "4px";
  // bar.style.marginRight = "4px";

  bar.style.height = "100%";
  bar.style.backgroundColor = "#488CE9";
  bar.style.maxWidth = "100%";
  bar.style.minWidth = "0%";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        bar.setAttribute(key, bar.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        bar.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  } //style cell


  element.style.padding = "4px 4px"; //make sure value is in range

  value = Math.min(parseFloat(value), max);
  value = Math.max(parseFloat(value), min); //workout percentage

  value = Math.round((value - min) / percent); // bar.style.right = value + "%";

  bar.style.width = value + "%";
  element.setAttribute("aria-valuemin", min);
  element.setAttribute("aria-valuemax", max);
  bar.appendChild(handle);
  handle.addEventListener("mousedown", function (e) {
    mouseDrag = e.screenX;
    mouseDragWidth = bar.offsetWidth;
  });
  handle.addEventListener("mouseover", function () {
    handle.style.cursor = "ew-resize";
  });
  element.addEventListener("mousemove", function (e) {
    if (mouseDrag) {
      bar.style.width = mouseDragWidth + e.screenX - mouseDrag + "px";
    }
  });
  element.addEventListener("mouseup", function (e) {
    if (mouseDrag) {
      e.stopPropagation();
      e.stopImmediatePropagation();
      mouseDrag = false;
      mouseDragWidth = false;
      updateValue();
    }
  }); //allow key based navigation

  element.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      case 39:
        //right arrow
        e.preventDefault();
        bar.style.width = bar.clientWidth + element.clientWidth / 100 + "px";
        break;

      case 37:
        //left arrow
        e.preventDefault();
        bar.style.width = bar.clientWidth - element.clientWidth / 100 + "px";
        break;

      case 9: //tab

      case 13:
        //enter
        updateValue();
        break;

      case 27:
        //escape
        cancel();
        break;
    }
  });
  element.addEventListener("blur", function () {
    cancel();
  });
  return bar;
} //checkbox


function tickCross(cell, onRendered, success, cancel, editorParams) {
  var value = cell.getValue(),
      input = document.createElement("input"),
      tristate = editorParams.tristate,
      indetermValue = typeof editorParams.indeterminateValue === "undefined" ? null : editorParams.indeterminateValue,
      indetermState = false,
      trueValueSet = Object.keys(editorParams).includes("trueValue"),
      falseValueSet = Object.keys(editorParams).includes("falseValue");
  input.setAttribute("type", "checkbox");
  input.style.marginTop = "5px";
  input.style.boxSizing = "border-box";

  if (editorParams.elementAttributes && typeof editorParams.elementAttributes == "object") {
    for (let key in editorParams.elementAttributes) {
      if (key.charAt(0) == "+") {
        key = key.slice(1);
        input.setAttribute(key, input.getAttribute(key) + editorParams.elementAttributes["+" + key]);
      } else {
        input.setAttribute(key, editorParams.elementAttributes[key]);
      }
    }
  }

  input.value = value;

  if (tristate && (typeof value === "undefined" || value === indetermValue || value === "")) {
    indetermState = true;
    input.indeterminate = true;
  }

  if (this.table.browser != "firefox") {
    //prevent blur issue on mac firefox
    onRendered(function () {
      input.focus({
        preventScroll: true
      });
    });
  }

  input.checked = trueValueSet ? value === editorParams.trueValue : value === true || value === "true" || value === "True" || value === 1;
  onRendered(function () {
    input.focus();
  });

  function setValue(blur) {
    var checkedValue = input.checked;

    if (trueValueSet && checkedValue) {
      checkedValue = editorParams.trueValue;
    } else if (falseValueSet && !checkedValue) {
      checkedValue = editorParams.falseValue;
    }

    if (tristate) {
      if (!blur) {
        if (input.checked && !indetermState) {
          input.checked = false;
          input.indeterminate = true;
          indetermState = true;
          return indetermValue;
        } else {
          indetermState = false;
          return checkedValue;
        }
      } else {
        if (indetermState) {
          return indetermValue;
        } else {
          return checkedValue;
        }
      }
    } else {
      return checkedValue;
    }
  } //submit new value on blur


  input.addEventListener("change", function (e) {
    success(setValue());
  });
  input.addEventListener("blur", function (e) {
    success(setValue(true));
  }); //submit new value on enter

  input.addEventListener("keydown", function (e) {
    if (e.keyCode == 13) {
      success(setValue());
    }

    if (e.keyCode == 27) {
      cancel();
    }
  });
  return input;
}

var defaultEditors = {
  input: input,
  textarea: textarea,
  number: number,
  range: range,
  date: date,
  time: time,
  datetime: datetime,
  select: select,
  list: list,
  autocomplete: autocomplete,
  star: star,
  progress: progress,
  tickCross: tickCross
};

class Edit$1 extends Module {
  constructor(table) {
    super(table);
    this.currentCell = false; //hold currently editing cell

    this.mouseClick = false; //hold mousedown state to prevent click binding being overridden by editor opening

    this.recursionBlock = false; //prevent focus recursion

    this.invalidEdit = false;
    this.editedCells = [];
    this.editors = Edit$1.editors;
    this.registerColumnOption("editable");
    this.registerColumnOption("editor");
    this.registerColumnOption("editorParams");
    this.registerColumnOption("cellEditing");
    this.registerColumnOption("cellEdited");
    this.registerColumnOption("cellEditCancelled");
    this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this));
    this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this));
    this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this));
    this.registerTableFunction("navigateNext", this.navigateNext.bind(this));
    this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this));
    this.registerTableFunction("navigateRight", this.navigateRight.bind(this));
    this.registerTableFunction("navigateUp", this.navigateUp.bind(this));
    this.registerTableFunction("navigateDown", this.navigateDown.bind(this));
    this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this));
    this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this));
    this.registerComponentFunction("cell", "edit", this.editCell.bind(this));
    this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this));
    this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this));
    this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this));
    this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this));
    this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this));
    this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this));
    this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
  }

  initialize() {
    this.subscribe("cell-init", this.bindEditor.bind(this));
    this.subscribe("cell-delete", this.clearEdited.bind(this));
    this.subscribe("cell-value-changed", this.updateCellClass.bind(this));
    this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
    this.subscribe("column-delete", this.columnDeleteCheck.bind(this));
    this.subscribe("row-deleting", this.rowDeleteCheck.bind(this));
    this.subscribe("data-refreshing", this.cancelEdit.bind(this));
    this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, undefined));
    this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this));
    this.subscribe("keybinding-nav-left", this.navigateLeft.bind(this, undefined));
    this.subscribe("keybinding-nav-right", this.navigateRight.bind(this, undefined));
    this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, undefined));
    this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, undefined));
  } ///////////////////////////////////
  ////// Keybinding Functions ///////
  ///////////////////////////////////


  keybindingNavigateNext(e) {
    var cell = this.currentCell,
        newRow = this.options("tabEndNewRow");

    if (cell) {
      if (!this.navigateNext(cell, e)) {
        if (newRow) {
          cell.getElement().firstChild.blur();

          if (newRow === true) {
            newRow = this.table.addRow({});
          } else {
            if (typeof newRow == "function") {
              newRow = this.table.addRow(newRow(cell.row.getComponent()));
            } else {
              newRow = this.table.addRow(Object.assign({}, newRow));
            }
          }

          newRow.then(() => {
            setTimeout(() => {
              cell.getComponent().navigateNext();
            });
          });
        }
      }
    }
  } ///////////////////////////////////
  ///////// Cell Functions //////////
  ///////////////////////////////////


  cellIsEdited(cell) {
    return !!cell.modules.edit && cell.modules.edit.edited;
  }

  cellCancelEdit(cell) {
    if (cell === this.currentCell) {
      this.table.modules.edit.cancelEdit();
    } else {
      console.warn("Cancel Editor Error - This cell is not currently being edited ");
    }
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////


  updateCellClass(cell) {
    if (this.allowEdit(cell)) {
      cell.getElement().classList.add("tabulator-editable");
    } else {
      cell.getElement().classList.remove("tabulator-editable");
    }
  }

  clearCellEdited(cells) {
    if (!cells) {
      cells = this.table.modules.edit.getEditedCells();
    }

    if (!Array.isArray(cells)) {
      cells = [cells];
    }

    cells.forEach(cell => {
      this.table.modules.edit.clearEdited(cell._getSelf());
    });
  }

  navigatePrev(cell = this.currentCell, e) {
    var nextCell, prevRow;

    if (cell) {
      if (e) {
        e.preventDefault();
      }

      nextCell = this.navigateLeft();

      if (nextCell) {
        return true;
      } else {
        prevRow = this.table.rowManager.prevDisplayRow(cell.row, true);

        if (prevRow) {
          nextCell = this.findNextEditableCell(prevRow, prevRow.cells.length);

          if (nextCell) {
            nextCell.getComponent().edit();
            return true;
          }
        }
      }
    }

    return false;
  }

  navigateNext(cell = this.currentCell, e) {
    var nextCell, nextRow;

    if (cell) {
      if (e) {
        e.preventDefault();
      }

      nextCell = this.navigateRight();

      if (nextCell) {
        return true;
      } else {
        nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);

        if (nextRow) {
          nextCell = this.findNextEditableCell(nextRow, -1);

          if (nextCell) {
            nextCell.getComponent().edit();
            return true;
          }
        }
      }
    }

    return false;
  }

  navigateLeft(cell = this.currentCell, e) {
    var index, nextCell;

    if (cell) {
      if (e) {
        e.preventDefault();
      }

      index = cell.getIndex();
      nextCell = this.findPrevEditableCell(cell.row, index);

      if (nextCell) {
        nextCell.getComponent().edit();
        return true;
      }
    }

    return false;
  }

  navigateRight(cell = this.currentCell, e) {
    var index, nextCell;

    if (cell) {
      if (e) {
        e.preventDefault();
      }

      index = cell.getIndex();
      nextCell = this.findNextEditableCell(cell.row, index);

      if (nextCell) {
        nextCell.getComponent().edit();
        return true;
      }
    }

    return false;
  }

  navigateUp(cell = this.currentCell, e) {
    var index, nextRow;

    if (cell) {
      if (e) {
        e.preventDefault();
      }

      index = cell.getIndex();
      nextRow = this.table.rowManager.prevDisplayRow(cell.row, true);

      if (nextRow) {
        nextRow.cells[index].getComponent().edit();
        return true;
      }
    }

    return false;
  }

  navigateDown(cell = this.currentCell, e) {
    var index, nextRow;

    if (cell) {
      if (e) {
        e.preventDefault();
      }

      index = cell.getIndex();
      nextRow = this.table.rowManager.nextDisplayRow(cell.row, true);

      if (nextRow) {
        nextRow.cells[index].getComponent().edit();
        return true;
      }
    }

    return false;
  }

  findNextEditableCell(row, index) {
    var nextCell = false;

    if (index < row.cells.length - 1) {
      for (var i = index + 1; i < row.cells.length; i++) {
        let cell = row.cells[i];

        if (cell.column.modules.edit && Helpers.elVisible(cell.getElement())) {
          let allowEdit = this.allowEdit(cell);

          if (allowEdit) {
            nextCell = cell;
            break;
          }
        }
      }
    }

    return nextCell;
  }

  findPrevEditableCell(row, index) {
    var prevCell = false;

    if (index > 0) {
      for (var i = index - 1; i >= 0; i--) {
        let cell = row.cells[i];

        if (cell.column.modules.edit && Helpers.elVisible(cell.getElement())) {
          let allowEdit = this.allowEdit(cell);

          if (allowEdit) {
            prevCell = cell;
            break;
          }
        }
      }
    }

    return prevCell;
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  initializeColumnCheck(column) {
    if (typeof column.definition.editor !== "undefined") {
      this.initializeColumn(column);
    }
  }

  columnDeleteCheck(column) {
    if (this.currentCell && this.currentCell.column === column) {
      this.cancelEdit();
    }
  }

  rowDeleteCheck(row) {
    if (this.currentCell && this.currentCell.row === row) {
      this.cancelEdit();
    }
  } //initialize column editor


  initializeColumn(column) {
    var config = {
      editor: false,
      blocked: false,
      check: column.definition.editable,
      params: column.definition.editorParams || {}
    }; //set column editor

    switch (typeof column.definition.editor) {
      case "string":
        if (this.editors[column.definition.editor]) {
          config.editor = this.editors[column.definition.editor];
        } else {
          console.warn("Editor Error - No such editor found: ", column.definition.editor);
        }

        break;

      case "function":
        config.editor = column.definition.editor;
        break;

      case "boolean":
        if (column.definition.editor === true) {
          if (typeof column.definition.formatter !== "function") {
            if (this.editors[column.definition.formatter]) {
              config.editor = this.editors[column.definition.formatter];
            } else {
              config.editor = this.editors["input"];
            }
          } else {
            console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", column.definition.formatter);
          }
        }

        break;
    }

    if (config.editor) {
      column.modules.edit = config;
    }
  }

  getCurrentCell() {
    return this.currentCell ? this.currentCell.getComponent() : false;
  }

  clearEditor(cancel) {
    var cell = this.currentCell,
        cellEl;
    this.invalidEdit = false;

    if (cell) {
      this.currentCell = false;
      cellEl = cell.getElement();
      this.dispatch("edit-editor-clear", cell, cancel);
      cellEl.classList.remove("tabulator-editing");

      while (cellEl.firstChild) cellEl.removeChild(cellEl.firstChild);

      cell.row.getElement().classList.remove("tabulator-editing");
      cell.table.element.classList.remove("tabulator-editing");
    }
  }

  cancelEdit() {
    if (this.currentCell) {
      var cell = this.currentCell;
      var component = this.currentCell.getComponent();
      this.clearEditor(true);
      cell.setValueActual(cell.getValue());
      cell.cellRendered();

      if (cell.column.definition.editor == "textarea" || cell.column.definition.variableHeight) {
        cell.row.normalizeHeight(true);
      }

      if (cell.column.definition.cellEditCancelled) {
        cell.column.definition.cellEditCancelled.call(this.table, component);
      }

      this.dispatch("edit-cancelled", cell);
      this.dispatchExternal("cellEditCancelled", component);
    }
  } //return a formatted value for a cell


  bindEditor(cell) {
    if (cell.column.modules.edit) {
      var self = this,
          element = cell.getElement(true);
      this.updateCellClass(cell);
      element.setAttribute("tabindex", 0);
      element.addEventListener("click", function (e) {
        if (!element.classList.contains("tabulator-editing")) {
          element.focus({
            preventScroll: true
          });
        }
      });
      element.addEventListener("mousedown", function (e) {
        if (e.button === 2) {
          e.preventDefault();
        } else {
          self.mouseClick = true;
        }
      });
      element.addEventListener("focus", function (e) {
        if (!self.recursionBlock) {
          self.edit(cell, e, false);
        }
      });
    }
  }

  focusCellNoEvent(cell, block) {
    this.recursionBlock = true;

    if (!(block && this.table.browser === "ie")) {
      cell.getElement().focus({
        preventScroll: true
      });
    }

    this.recursionBlock = false;
  }

  editCell(cell, forceEdit) {
    this.focusCellNoEvent(cell);
    this.edit(cell, false, forceEdit);
  }

  focusScrollAdjust(cell) {
    if (this.table.rowManager.getRenderMode() == "virtual") {
      var topEdge = this.table.rowManager.element.scrollTop,
          bottomEdge = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop,
          rowEl = cell.row.getElement();

      if (rowEl.offsetTop < topEdge) {
        this.table.rowManager.element.scrollTop -= topEdge - rowEl.offsetTop;
      } else {
        if (rowEl.offsetTop + rowEl.offsetHeight > bottomEdge) {
          this.table.rowManager.element.scrollTop += rowEl.offsetTop + rowEl.offsetHeight - bottomEdge;
        }
      }

      var leftEdge = this.table.rowManager.element.scrollLeft,
          rightEdge = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft,
          cellEl = cell.getElement();

      if (this.table.modExists("frozenColumns")) {
        leftEdge += parseInt(this.table.modules.frozenColumns.leftMargin);
        rightEdge -= parseInt(this.table.modules.frozenColumns.rightMargin);
      }

      if (this.table.options.renderHorizontal === "virtual") {
        leftEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
        rightEdge -= parseInt(this.table.columnManager.renderer.vDomPadLeft);
      }

      if (cellEl.offsetLeft < leftEdge) {
        this.table.rowManager.element.scrollLeft -= leftEdge - cellEl.offsetLeft;
      } else {
        if (cellEl.offsetLeft + cellEl.offsetWidth > rightEdge) {
          this.table.rowManager.element.scrollLeft += cellEl.offsetLeft + cellEl.offsetWidth - rightEdge;
        }
      }
    }
  }

  allowEdit(cell) {
    var check = cell.column.modules.edit ? true : false;

    if (cell.column.modules.edit) {
      switch (typeof cell.column.modules.edit.check) {
        case "function":
          check = cell.column.modules.edit.check(cell.getComponent());
          break;

        case "string":
          check = !!cell.row.data[cell.column.modules.edit.check];
          break;

        case "boolean":
          check = cell.column.modules.edit.check;
          break;
      }
    }

    return check;
  }

  edit(cell, e, forceEdit) {
    var self = this,
        allowEdit = true,
        rendered = function () {},
        element = cell.getElement(),
        cellEditor,
        component,
        params; //prevent editing if another cell is refusing to leave focus (eg. validation fail)


    if (this.currentCell) {
      if (!this.invalidEdit) {
        this.cancelEdit();
      }

      return;
    } //handle successful value change


    function success(value) {
      if (self.currentCell === cell) {
        var valid = self.chain("edit-success", [cell, value], true, true);

        if (valid === true || self.table.options.validationMode === "highlight") {
          self.clearEditor();

          if (!cell.modules.edit) {
            cell.modules.edit = {};
          }

          cell.modules.edit.edited = true;

          if (self.editedCells.indexOf(cell) == -1) {
            self.editedCells.push(cell);
          }

          cell.setValue(value, true);
          return valid === true;
        } else {
          self.invalidEdit = true;
          self.focusCellNoEvent(cell, true);
          rendered();
          return false;
        }
      }
    } //handle aborted edit


    function cancel() {
      if (self.currentCell === cell) {
        self.cancelEdit();
      }
    }

    function onRendered(callback) {
      rendered = callback;
    }

    if (!cell.column.modules.edit.blocked) {
      if (e) {
        e.stopPropagation();
      }

      allowEdit = this.allowEdit(cell);

      if (allowEdit || forceEdit) {
        self.cancelEdit();
        self.currentCell = cell;
        this.focusScrollAdjust(cell);
        component = cell.getComponent();

        if (this.mouseClick) {
          this.mouseClick = false;

          if (cell.column.definition.cellClick) {
            cell.column.definition.cellClick.call(this.table, e, component);
          }
        }

        if (cell.column.definition.cellEditing) {
          cell.column.definition.cellEditing.call(this.table, component);
        }

        this.dispatch("cell-editing", cell);
        this.dispatchExternal("cellEditing", component);
        params = typeof cell.column.modules.edit.params === "function" ? cell.column.modules.edit.params(component) : cell.column.modules.edit.params;
        cellEditor = cell.column.modules.edit.editor.call(self, component, onRendered, success, cancel, params); //if editor returned, add to DOM, if false, abort edit

        if (cellEditor !== false) {
          if (cellEditor instanceof Node) {
            element.classList.add("tabulator-editing");
            cell.row.getElement().classList.add("tabulator-editing");
            cell.table.element.classList.add("tabulator-editing");

            while (element.firstChild) element.removeChild(element.firstChild);

            element.appendChild(cellEditor); //trigger onRendered Callback

            rendered(); //prevent editing from triggering rowClick event

            var children = element.children;

            for (var i = 0; i < children.length; i++) {
              children[i].addEventListener("click", function (e) {
                e.stopPropagation();
              });
            }
          } else {
            console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", cellEditor);
            element.blur();
            return false;
          }
        } else {
          element.blur();
          return false;
        }

        return true;
      } else {
        this.mouseClick = false;
        element.blur();
        return false;
      }
    } else {
      this.mouseClick = false;
      element.blur();
      return false;
    }
  }

  getEditedCells() {
    var output = [];
    this.editedCells.forEach(cell => {
      output.push(cell.getComponent());
    });
    return output;
  }

  clearEdited(cell) {
    var editIndex;

    if (cell.modules.edit && cell.modules.edit.edited) {
      cell.modules.edit.edited = false;
      this.dispatch("edit-edited-clear", cell);
    }

    editIndex = this.editedCells.indexOf(cell);

    if (editIndex > -1) {
      this.editedCells.splice(editIndex, 1);
    }
  }

}

exports.EditModule = Edit$1;
Edit$1.moduleName = "edit"; //load defaults

Edit$1.editors = defaultEditors;

class ExportRow {
  constructor(type, columns, component, indent) {
    this.type = type;
    this.columns = columns;
    this.component = component || false;
    this.indent = indent || 0;
  }

}

class ExportColumn {
  constructor(value, component, width, height, depth) {
    this.value = value;
    this.component = component || false;
    this.width = width;
    this.height = height;
    this.depth = depth;
  }

}

class Export extends Module {
  constructor(table) {
    super(table);
    this.config = {};
    this.cloneTableStyle = true;
    this.colVisProp = "";
    this.registerTableOption("htmlOutputConfig", false); //html output config

    this.registerColumnOption("htmlOutput");
    this.registerColumnOption("titleHtmlOutput");
  }

  initialize() {
    this.registerTableFunction("getHtml", this.getHtml.bind(this));
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  generateExportList(config, style, range, colVisProp) {
    this.cloneTableStyle = style;
    this.config = config || {};
    this.colVisProp = colVisProp;
    var headers = this.config.columnHeaders !== false ? this.headersToExportRows(this.generateColumnGroupHeaders()) : [];
    var body = this.bodyToExportRows(this.rowLookup(range));
    return headers.concat(body);
  }

  generateTable(config, style, range, colVisProp) {
    var list = this.generateExportList(config, style, range, colVisProp);
    return this.generateTableElement(list);
  }

  rowLookup(range) {
    var rows = [];

    if (typeof range == "function") {
      range.call(this.table).forEach(row => {
        row = this.table.rowManager.findRow(row);

        if (row) {
          rows.push(row);
        }
      });
    } else {
      switch (range) {
        case true:
        case "visible":
          rows = this.table.rowManager.getVisibleRows(false, true);
          break;

        case "all":
          rows = this.table.rowManager.rows;
          break;

        case "selected":
          rows = this.table.modules.selectRow.selectedRows;
          break;

        case "active":
        default:
          if (this.table.options.pagination) {
            rows = this.table.rowManager.getDisplayRows(this.table.rowManager.displayRows.length - 2);
          } else {
            rows = this.table.rowManager.getDisplayRows();
          }

      }
    }

    return Object.assign([], rows);
  }

  generateColumnGroupHeaders() {
    var output = [];
    var columns = this.config.columnGroups !== false ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
    columns.forEach(column => {
      var colData = this.processColumnGroup(column);

      if (colData) {
        output.push(colData);
      }
    });
    return output;
  }

  processColumnGroup(column) {
    var subGroups = column.columns,
        maxDepth = 0,
        title = column.definition["title" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))] || column.definition.title;
    var groupData = {
      title: title,
      column: column,
      depth: 1
    };

    if (subGroups.length) {
      groupData.subGroups = [];
      groupData.width = 0;
      subGroups.forEach(subGroup => {
        var subGroupData = this.processColumnGroup(subGroup);

        if (subGroupData) {
          groupData.width += subGroupData.width;
          groupData.subGroups.push(subGroupData);

          if (subGroupData.depth > maxDepth) {
            maxDepth = subGroupData.depth;
          }
        }
      });
      groupData.depth += maxDepth;

      if (!groupData.width) {
        return false;
      }
    } else {
      if (this.columnVisCheck(column)) {
        groupData.width = 1;
      } else {
        return false;
      }
    }

    return groupData;
  }

  columnVisCheck(column) {
    var visProp = column.definition[this.colVisProp];

    if (typeof visProp === "function") {
      visProp = visProp.call(this.table, column.getComponent());
    }

    return visProp !== false && (column.visible || !column.visible && visProp);
  }

  headersToExportRows(columns) {
    var headers = [],
        headerDepth = 0,
        exportRows = [];

    function parseColumnGroup(column, level) {
      var depth = headerDepth - level;

      if (typeof headers[level] === "undefined") {
        headers[level] = [];
      }

      column.height = column.subGroups ? 1 : depth - column.depth + 1;
      headers[level].push(column);

      if (column.height > 1) {
        for (let i = 1; i < column.height; i++) {
          if (typeof headers[level + i] === "undefined") {
            headers[level + i] = [];
          }

          headers[level + i].push(false);
        }
      }

      if (column.width > 1) {
        for (let i = 1; i < column.width; i++) {
          headers[level].push(false);
        }
      }

      if (column.subGroups) {
        column.subGroups.forEach(function (subGroup) {
          parseColumnGroup(subGroup, level + 1);
        });
      }
    } //calculate maximum header depth


    columns.forEach(function (column) {
      if (column.depth > headerDepth) {
        headerDepth = column.depth;
      }
    });
    columns.forEach(function (column) {
      parseColumnGroup(column, 0);
    });
    headers.forEach(header => {
      var columns = [];
      header.forEach(col => {
        if (col) {
          let title = typeof col.title === "undefined" ? "" : col.title;
          columns.push(new ExportColumn(title, col.column.getComponent(), col.width, col.height, col.depth));
        } else {
          columns.push(null);
        }
      });
      exportRows.push(new ExportRow("header", columns));
    });
    return exportRows;
  }

  bodyToExportRows(rows) {
    var columns = [];
    var exportRows = [];
    this.table.columnManager.columnsByIndex.forEach(column => {
      if (this.columnVisCheck(column)) {
        columns.push(column.getComponent());
      }
    });

    if (this.config.columnCalcs !== false && this.table.modExists("columnCalcs")) {
      if (this.table.modules.columnCalcs.topInitialized) {
        rows.unshift(this.table.modules.columnCalcs.topRow);
      }

      if (this.table.modules.columnCalcs.botInitialized) {
        rows.push(this.table.modules.columnCalcs.botRow);
      }
    }

    rows = rows.filter(row => {
      switch (row.type) {
        case "group":
          return this.config.rowGroups !== false;

        case "calc":
          return this.config.columnCalcs !== false;

        case "row":
          return !(this.table.options.dataTree && this.config.dataTree === false && row.modules.dataTree.parent);
      }

      return true;
    });
    rows.forEach((row, i) => {
      var rowData = row.getData(this.colVisProp);
      var exportCols = [];
      var indent = 0;

      switch (row.type) {
        case "group":
          indent = row.level;
          exportCols.push(new ExportColumn(row.key, row.getComponent(), columns.length, 1));
          break;

        case "calc":
        case "row":
          columns.forEach(col => {
            exportCols.push(new ExportColumn(col._column.getFieldValue(rowData), col, 1, 1));
          });

          if (this.table.options.dataTree && this.config.dataTree !== false) {
            indent = row.modules.dataTree.index;
          }

          break;
      }

      exportRows.push(new ExportRow(row.type, exportCols, row.getComponent(), indent));
    });
    return exportRows;
  }

  generateTableElement(list) {
    var table = document.createElement("table"),
        headerEl = document.createElement("thead"),
        bodyEl = document.createElement("tbody"),
        styles = this.lookupTableStyles(),
        rowFormatter = this.table.options["rowFormatter" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))],
        setup = {};
    setup.rowFormatter = rowFormatter !== null ? rowFormatter : this.table.options.rowFormatter;

    if (this.table.options.dataTree && this.config.dataTree !== false && this.table.modExists("columnCalcs")) {
      setup.treeElementField = this.table.modules.dataTree.elementField;
    } //assign group header formatter


    setup.groupHeader = this.table.options["groupHeader" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))];

    if (setup.groupHeader && !Array.isArray(setup.groupHeader)) {
      setup.groupHeader = [setup.groupHeader];
    }

    table.classList.add("tabulator-print-table");
    this.mapElementStyles(this.table.columnManager.getHeadersElement(), headerEl, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);

    if (list.length > 1000) {
      console.warn("It may take a long time to render an HTML table with more than 1000 rows");
    }

    list.forEach((row, i) => {
      let rowEl;

      switch (row.type) {
        case "header":
          headerEl.appendChild(this.generateHeaderElement(row, setup, styles));
          break;

        case "group":
          bodyEl.appendChild(this.generateGroupElement(row, setup, styles));
          break;

        case "calc":
          bodyEl.appendChild(this.generateCalcElement(row, setup, styles));
          break;

        case "row":
          rowEl = this.generateRowElement(row, setup, styles);
          this.mapElementStyles(i % 2 && styles.evenRow ? styles.evenRow : styles.oddRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
          bodyEl.appendChild(rowEl);
          break;
      }
    });

    if (headerEl.innerHTML) {
      table.appendChild(headerEl);
    }

    table.appendChild(bodyEl);
    this.mapElementStyles(this.table.element, table, ["border-top", "border-left", "border-right", "border-bottom"]);
    return table;
  }

  lookupTableStyles() {
    var styles = {}; //lookup row styles

    if (this.cloneTableStyle && window.getComputedStyle) {
      styles.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)");
      styles.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)");
      styles.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs");
      styles.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)");
      styles.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0];

      if (styles.firstRow) {
        styles.styleCells = styles.firstRow.getElementsByClassName("tabulator-cell");
        styles.firstCell = styles.styleCells[0];
        styles.lastCell = styles.styleCells[styles.styleCells.length - 1];
      }
    }

    return styles;
  }

  generateHeaderElement(row, setup, styles) {
    var rowEl = document.createElement("tr");
    row.columns.forEach(column => {
      if (column) {
        var cellEl = document.createElement("th");
        var classNames = column.component._column.definition.cssClass ? column.component._column.definition.cssClass.split(" ") : [];
        cellEl.colSpan = column.width;
        cellEl.rowSpan = column.height;
        cellEl.innerHTML = column.value;

        if (this.cloneTableStyle) {
          cellEl.style.boxSizing = "border-box";
        }

        classNames.forEach(function (className) {
          cellEl.classList.add(className);
        });
        this.mapElementStyles(column.component.getElement(), cellEl, ["text-align", "border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]);
        this.mapElementStyles(column.component._column.contentElement, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);

        if (column.component._column.visible) {
          this.mapElementStyles(column.component.getElement(), cellEl, ["width"]);
        } else {
          if (column.component._column.definition.width) {
            cellEl.style.width = column.component._column.definition.width + "px";
          }
        }

        if (column.component._column.parent) {
          this.mapElementStyles(column.component._column.parent.groupElement, cellEl, ["border-top"]);
        }

        rowEl.appendChild(cellEl);
      }
    });
    return rowEl;
  }

  generateGroupElement(row, setup, styles) {
    var rowEl = document.createElement("tr"),
        cellEl = document.createElement("td"),
        group = row.columns[0];
    rowEl.classList.add("tabulator-print-table-row");

    if (setup.groupHeader && setup.groupHeader[row.indent]) {
      group.value = setup.groupHeader[row.indent](group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
    } else {
      if (setup.groupHeader !== false) {
        group.value = row.component._group.generator(group.value, row.component._group.getRowCount(), row.component._group.getData(), row.component);
      }
    }

    cellEl.colSpan = group.width;
    cellEl.innerHTML = group.value;
    rowEl.classList.add("tabulator-print-table-group");
    rowEl.classList.add("tabulator-group-level-" + row.indent);

    if (group.component.isVisible()) {
      rowEl.classList.add("tabulator-group-visible");
    }

    this.mapElementStyles(styles.firstGroup, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
    this.mapElementStyles(styles.firstGroup, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom"]);
    rowEl.appendChild(cellEl);
    return rowEl;
  }

  generateCalcElement(row, setup, styles) {
    var rowEl = this.generateRowElement(row, setup, styles);
    rowEl.classList.add("tabulator-print-table-calcs");
    this.mapElementStyles(styles.calcRow, rowEl, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]);
    return rowEl;
  }

  generateRowElement(row, setup, styles) {
    var rowEl = document.createElement("tr");
    rowEl.classList.add("tabulator-print-table-row");
    row.columns.forEach((col, i) => {
      if (col) {
        var cellEl = document.createElement("td"),
            column = col.component._column,
            index = this.table.columnManager.findColumnIndex(column),
            value = col.value,
            cellStyle;
        var cellWrapper = {
          modules: {},
          getValue: function () {
            return value;
          },
          getField: function () {
            return column.definition.field;
          },
          getElement: function () {
            return cellEl;
          },
          getColumn: function () {
            return column.getComponent();
          },
          getData: function () {
            return row.component.getData();
          },
          getRow: function () {
            return row.component;
          },
          getComponent: function () {
            return cellWrapper;
          },
          column: column
        };
        var classNames = column.definition.cssClass ? column.definition.cssClass.split(" ") : [];
        classNames.forEach(function (className) {
          cellEl.classList.add(className);
        });

        if (this.table.modExists("format") && this.config.formatCells !== false) {
          value = this.table.modules.format.formatExportValue(cellWrapper, this.colVisProp);
        } else {
          switch (typeof value) {
            case "object":
              value = value !== null ? JSON.stringify(value) : "";
              break;

            case "undefined":
              value = "";
              break;
          }
        }

        if (value instanceof Node) {
          cellEl.appendChild(value);
        } else {
          cellEl.innerHTML = value;
        }

        cellStyle = styles.styleCells && styles.styleCells[index] ? styles.styleCells[index] : styles.firstCell;

        if (cellStyle) {
          this.mapElementStyles(cellStyle, cellEl, ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"]);

          if (column.definition.align) {
            cellEl.style.textAlign = column.definition.align;
          }
        }

        if (this.table.options.dataTree && this.config.dataTree !== false) {
          if (setup.treeElementField && setup.treeElementField == column.field || !setup.treeElementField && i == 0) {
            if (row.component._row.modules.dataTree.controlEl) {
              cellEl.insertBefore(row.component._row.modules.dataTree.controlEl.cloneNode(true), cellEl.firstChild);
            }

            if (row.component._row.modules.dataTree.branchEl) {
              cellEl.insertBefore(row.component._row.modules.dataTree.branchEl.cloneNode(true), cellEl.firstChild);
            }
          }
        }

        rowEl.appendChild(cellEl);

        if (cellWrapper.modules.format && cellWrapper.modules.format.renderedCallback) {
          cellWrapper.modules.format.renderedCallback();
        }

        if (setup.rowFormatter && this.config.formatCells !== false) {
          setup.rowFormatter(row.component);
        }
      }
    });
    return rowEl;
  }

  generateHTMLTable(list) {
    var holder = document.createElement("div");
    holder.appendChild(this.generateTableElement(list));
    return holder.innerHTML;
  }

  getHtml(visible, style, config, colVisProp) {
    var list = this.generateExportList(config || this.table.options.htmlOutputConfig, style, visible, colVisProp || "htmlOutput");
    return this.generateHTMLTable(list);
  }

  mapElementStyles(from, to, props) {
    if (this.cloneTableStyle && from && to) {
      var lookup = {
        "background-color": "backgroundColor",
        "color": "fontColor",
        "width": "width",
        "font-weight": "fontWeight",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "text-align": "textAlign",
        "border-top": "borderTop",
        "border-left": "borderLeft",
        "border-right": "borderRight",
        "border-bottom": "borderBottom",
        "padding-top": "paddingTop",
        "padding-left": "paddingLeft",
        "padding-right": "paddingRight",
        "padding-bottom": "paddingBottom"
      };

      if (window.getComputedStyle) {
        var fromStyle = window.getComputedStyle(from);
        props.forEach(function (prop) {
          to.style[lookup[prop]] = fromStyle.getPropertyValue(prop);
        });
      }
    }
  }

}

exports.ExportModule = Export;
Export.moduleName = "export";
var defaultFilters = {
  //equal to
  "=": function (filterVal, rowVal, rowData, filterParams) {
    return rowVal == filterVal ? true : false;
  },
  //less than
  "<": function (filterVal, rowVal, rowData, filterParams) {
    return rowVal < filterVal ? true : false;
  },
  //less than or equal to
  "<=": function (filterVal, rowVal, rowData, filterParams) {
    return rowVal <= filterVal ? true : false;
  },
  //greater than
  ">": function (filterVal, rowVal, rowData, filterParams) {
    return rowVal > filterVal ? true : false;
  },
  //greater than or equal to
  ">=": function (filterVal, rowVal, rowData, filterParams) {
    return rowVal >= filterVal ? true : false;
  },
  //not equal to
  "!=": function (filterVal, rowVal, rowData, filterParams) {
    return rowVal != filterVal ? true : false;
  },
  "regex": function (filterVal, rowVal, rowData, filterParams) {
    if (typeof filterVal == "string") {
      filterVal = new RegExp(filterVal);
    }

    return filterVal.test(rowVal);
  },
  //contains the string
  "like": function (filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== 'undefined' && rowVal !== null) {
        return String(rowVal).toLowerCase().indexOf(filterVal.toLowerCase()) > -1;
      } else {
        return false;
      }
    }
  },
  //contains the keywords
  "keywords": function (filterVal, rowVal, rowData, filterParams) {
    var keywords = filterVal.toLowerCase().split(typeof filterParams.separator === "undefined" ? " " : filterParams.separator),
        value = String(rowVal === null || typeof rowVal === "undefined" ? "" : rowVal).toLowerCase(),
        matches = [];
    keywords.forEach(keyword => {
      if (value.includes(keyword)) {
        matches.push(true);
      }
    });
    return filterParams.matchAll ? matches.length === keywords.length : !!matches.length;
  },
  //starts with the string
  "starts": function (filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== 'undefined' && rowVal !== null) {
        return String(rowVal).toLowerCase().startsWith(filterVal.toLowerCase());
      } else {
        return false;
      }
    }
  },
  //ends with the string
  "ends": function (filterVal, rowVal, rowData, filterParams) {
    if (filterVal === null || typeof filterVal === "undefined") {
      return rowVal === filterVal ? true : false;
    } else {
      if (typeof rowVal !== 'undefined' && rowVal !== null) {
        return String(rowVal).toLowerCase().endsWith(filterVal.toLowerCase());
      } else {
        return false;
      }
    }
  },
  //in array
  "in": function (filterVal, rowVal, rowData, filterParams) {
    if (Array.isArray(filterVal)) {
      return filterVal.length ? filterVal.indexOf(rowVal) > -1 : true;
    } else {
      console.warn("Filter Error - filter value is not an array:", filterVal);
      return false;
    }
  }
};

class Filter extends Module {
  constructor(table) {
    super(table);
    this.filterList = []; //hold filter list

    this.headerFilters = {}; //hold column filters

    this.headerFilterColumns = []; //hold columns that use header filters

    this.prevHeaderFilterChangeCheck = "";
    this.prevHeaderFilterChangeCheck = "{}";
    this.changed = false; //has filtering changed since last render

    this.tableInitialized = false;
    this.registerTableOption("filterMode", "local"); //local or remote filtering

    this.registerTableOption("initialFilter", false); //initial filtering criteria

    this.registerTableOption("initialHeaderFilter", false); //initial header filtering criteria

    this.registerTableOption("headerFilterLiveFilterDelay", 300); //delay before updating column after user types in header filter

    this.registerColumnOption("headerFilter");
    this.registerColumnOption("headerFilterPlaceholder");
    this.registerColumnOption("headerFilterParams");
    this.registerColumnOption("headerFilterEmptyCheck");
    this.registerColumnOption("headerFilterFunc");
    this.registerColumnOption("headerFilterFuncParams");
    this.registerColumnOption("headerFilterLiveFilter");
    this.registerTableFunction("searchRows", this.searchRows.bind(this));
    this.registerTableFunction("searchData", this.searchData.bind(this));
    this.registerTableFunction("setFilter", this.userSetFilter.bind(this));
    this.registerTableFunction("refreshFilter", this.userRefreshFilter.bind(this));
    this.registerTableFunction("addFilter", this.userAddFilter.bind(this));
    this.registerTableFunction("getFilters", this.getFilters.bind(this));
    this.registerTableFunction("setHeaderFilterFocus", this.userSetHeaderFilterFocus.bind(this));
    this.registerTableFunction("getHeaderFilterValue", this.userGetHeaderFilterValue.bind(this));
    this.registerTableFunction("setHeaderFilterValue", this.userSetHeaderFilterValue.bind(this));
    this.registerTableFunction("getHeaderFilters", this.getHeaderFilters.bind(this));
    this.registerTableFunction("removeFilter", this.userRemoveFilter.bind(this));
    this.registerTableFunction("clearFilter", this.userClearFilter.bind(this));
    this.registerTableFunction("clearHeaderFilter", this.userClearHeaderFilter.bind(this));
    this.registerComponentFunction("column", "headerFilterFocus", this.setHeaderFilterFocus.bind(this));
    this.registerComponentFunction("column", "reloadHeaderFilter", this.reloadHeaderFilter.bind(this));
    this.registerComponentFunction("column", "getHeaderFilterValue", this.getHeaderFilterValue.bind(this));
    this.registerComponentFunction("column", "setHeaderFilterValue", this.setHeaderFilterValue.bind(this));
  }

  initialize() {
    this.subscribe("column-init", this.initializeColumnHeaderFilter.bind(this));
    this.subscribe("column-width-fit-before", this.hideHeaderFilterElements.bind(this));
    this.subscribe("column-width-fit-after", this.showHeaderFilterElements.bind(this));
    this.subscribe("table-built", this.tableBuilt.bind(this));

    if (this.table.options.filterMode === "remote") {
      this.subscribe("data-params", this.remoteFilterParams.bind(this));
    }

    this.registerDataHandler(this.filter.bind(this), 10);
  }

  tableBuilt() {
    if (this.table.options.initialFilter) {
      this.setFilter(this.table.options.initialFilter);
    }

    if (this.table.options.initialHeaderFilter) {
      this.table.options.initialHeaderFilter.forEach(item => {
        var column = this.table.columnManager.findColumn(item.field);

        if (column) {
          this.setHeaderFilterValue(column, item.value);
        } else {
          console.warn("Column Filter Error - No matching column found:", item.field);
          return false;
        }
      });
    }

    this.tableInitialized = true;
  }

  remoteFilterParams(data, config, silent, params) {
    params.filter = this.getFilters(true, true);
    return params;
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  //set standard filters


  userSetFilter(field, type, value, params) {
    this.setFilter(field, type, value, params);
    this.refreshFilter();
  } //set standard filters


  userRefreshFilter() {
    this.refreshFilter();
  } //add filter to array


  userAddFilter(field, type, value, params) {
    this.addFilter(field, type, value, params);
    this.refreshFilter();
  }

  userSetHeaderFilterFocus(field) {
    var column = this.table.columnManager.findColumn(field);

    if (column) {
      this.setHeaderFilterFocus(column);
    } else {
      console.warn("Column Filter Focus Error - No matching column found:", field);
      return false;
    }
  }

  userGetHeaderFilterValue(field) {
    var column = this.table.columnManager.findColumn(field);

    if (column) {
      return this.getHeaderFilterValue(column);
    } else {
      console.warn("Column Filter Error - No matching column found:", field);
    }
  }

  userSetHeaderFilterValue(field, value) {
    var column = this.table.columnManager.findColumn(field);

    if (column) {
      this.setHeaderFilterValue(column, value);
    } else {
      console.warn("Column Filter Error - No matching column found:", field);
      return false;
    }
  } //remove filter from array


  userRemoveFilter(field, type, value) {
    this.removeFilter(field, type, value);
    this.refreshFilter();
  } //clear filters


  userClearFilter(all) {
    this.clearFilter(all);
    this.refreshFilter();
  } //clear header filters


  userClearHeaderFilter() {
    this.clearHeaderFilter();
    this.refreshFilter();
  } //search for specific row components


  searchRows(field, type, value) {
    return this.search("rows", field, type, value);
  } //search for specific data


  searchData(field, type, value) {
    return this.search("data", field, type, value);
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  initializeColumnHeaderFilter(column) {
    var def = column.definition;

    if (def.headerFilter) {
      if (typeof def.headerFilterPlaceholder !== "undefined" && def.field) {
        this.module("localize").setHeaderFilterColumnPlaceholder(def.field, def.headerFilterPlaceholder);
      }

      this.initializeColumn(column);
    }
  } //initialize column header filter


  initializeColumn(column, value) {
    var self = this,
        field = column.getField(); //handle successfully value change

    function success(value) {
      var filterType = column.modules.filter.tagType == "input" && column.modules.filter.attrType == "text" || column.modules.filter.tagType == "textarea" ? "partial" : "match",
          type = "",
          filterChangeCheck = "",
          filterFunc;

      if (typeof column.modules.filter.prevSuccess === "undefined" || column.modules.filter.prevSuccess !== value) {
        column.modules.filter.prevSuccess = value;

        if (!column.modules.filter.emptyFunc(value)) {
          column.modules.filter.value = value;

          switch (typeof column.definition.headerFilterFunc) {
            case "string":
              if (Filter.filters[column.definition.headerFilterFunc]) {
                type = column.definition.headerFilterFunc;

                filterFunc = function (data) {
                  var params = column.definition.headerFilterFuncParams || {};
                  var fieldVal = column.getFieldValue(data);
                  params = typeof params === "function" ? params(value, fieldVal, data) : params;
                  return Filter.filters[column.definition.headerFilterFunc](value, fieldVal, data, params);
                };
              } else {
                console.warn("Header Filter Error - Matching filter function not found: ", column.definition.headerFilterFunc);
              }

              break;

            case "function":
              filterFunc = function (data) {
                var params = column.definition.headerFilterFuncParams || {};
                var fieldVal = column.getFieldValue(data);
                params = typeof params === "function" ? params(value, fieldVal, data) : params;
                return column.definition.headerFilterFunc(value, fieldVal, data, params);
              };

              type = filterFunc;
              break;
          }

          if (!filterFunc) {
            switch (filterType) {
              case "partial":
                filterFunc = function (data) {
                  var colVal = column.getFieldValue(data);

                  if (typeof colVal !== 'undefined' && colVal !== null) {
                    return String(colVal).toLowerCase().indexOf(String(value).toLowerCase()) > -1;
                  } else {
                    return false;
                  }
                };

                type = "like";
                break;

              default:
                filterFunc = function (data) {
                  return column.getFieldValue(data) == value;
                };

                type = "=";
            }
          }

          self.headerFilters[field] = {
            value: value,
            func: filterFunc,
            type: type
          };
        } else {
          delete self.headerFilters[field];
        }

        column.modules.filter.value = value;
        filterChangeCheck = JSON.stringify(self.headerFilters);

        if (self.prevHeaderFilterChangeCheck !== filterChangeCheck) {
          self.prevHeaderFilterChangeCheck = filterChangeCheck;
          self.trackChanges();
          self.refreshFilter();
        }
      }

      return true;
    }

    column.modules.filter = {
      success: success,
      attrType: false,
      tagType: false,
      emptyFunc: false
    };
    this.generateHeaderFilterElement(column);
  }

  generateHeaderFilterElement(column, initialValue, reinitialize) {
    var self = this,
        success = column.modules.filter.success,
        field = column.getField(),
        filterElement,
        editor,
        editorElement,
        cellWrapper,
        typingTimer,
        searchTrigger,
        params;
    column.modules.filter.value = initialValue; //handle aborted edit

    function cancel() {}

    if (column.modules.filter.headerElement && column.modules.filter.headerElement.parentNode) {
      column.contentElement.removeChild(column.modules.filter.headerElement.parentNode);
    }

    if (field) {
      //set empty value function
      column.modules.filter.emptyFunc = column.definition.headerFilterEmptyCheck || function (value) {
        return !value && value !== 0;
      };

      filterElement = document.createElement("div");
      filterElement.classList.add("tabulator-header-filter"); //set column editor

      switch (typeof column.definition.headerFilter) {
        case "string":
          if (self.table.modules.edit.editors[column.definition.headerFilter]) {
            editor = self.table.modules.edit.editors[column.definition.headerFilter];

            if ((column.definition.headerFilter === "tick" || column.definition.headerFilter === "tickCross") && !column.definition.headerFilterEmptyCheck) {
              column.modules.filter.emptyFunc = function (value) {
                return value !== true && value !== false;
              };
            }
          } else {
            console.warn("Filter Error - Cannot build header filter, No such editor found: ", column.definition.editor);
          }

          break;

        case "function":
          editor = column.definition.headerFilter;
          break;

        case "boolean":
          if (column.modules.edit && column.modules.edit.editor) {
            editor = column.modules.edit.editor;
          } else {
            if (column.definition.formatter && self.table.modules.edit.editors[column.definition.formatter]) {
              editor = self.table.modules.edit.editors[column.definition.formatter];

              if ((column.definition.formatter === "tick" || column.definition.formatter === "tickCross") && !column.definition.headerFilterEmptyCheck) {
                column.modules.filter.emptyFunc = function (value) {
                  return value !== true && value !== false;
                };
              }
            } else {
              editor = self.table.modules.edit.editors["input"];
            }
          }

          break;
      }

      if (editor) {
        cellWrapper = {
          getValue: function () {
            return typeof initialValue !== "undefined" ? initialValue : "";
          },
          getField: function () {
            return column.definition.field;
          },
          getElement: function () {
            return filterElement;
          },
          getColumn: function () {
            return column.getComponent();
          },
          getTable: () => {
            return this.table;
          },
          getRow: function () {
            return {
              normalizeHeight: function () {}
            };
          }
        };
        params = column.definition.headerFilterParams || {};
        params = typeof params === "function" ? params.call(self.table, cellWrapper) : params;
        editorElement = editor.call(this.table.modules.edit, cellWrapper, function () {}, success, cancel, params);

        if (!editorElement) {
          console.warn("Filter Error - Cannot add filter to " + field + " column, editor returned a value of false");
          return;
        }

        if (!(editorElement instanceof Node)) {
          console.warn("Filter Error - Cannot add filter to " + field + " column, editor should return an instance of Node, the editor returned:", editorElement);
          return;
        } //set Placeholder Text


        self.langBind("headerFilters|columns|" + column.definition.field, function (value) {
          editorElement.setAttribute("placeholder", typeof value !== "undefined" && value ? value : self.langText("headerFilters|default"));
        }); //focus on element on click

        editorElement.addEventListener("click", function (e) {
          e.stopPropagation();
          editorElement.focus();
        });
        editorElement.addEventListener("focus", e => {
          var left = this.table.columnManager.element.scrollLeft;
          var headerPos = this.table.rowManager.element.scrollLeft + parseInt(this.table.columnManager.element.style.marginLeft);

          if (left !== headerPos) {
            this.table.rowManager.scrollHorizontal(left);
            this.table.columnManager.scrollHorizontal(left);
          }
        }); //live update filters as user types

        typingTimer = false;

        searchTrigger = function (e) {
          if (typingTimer) {
            clearTimeout(typingTimer);
          }

          typingTimer = setTimeout(function () {
            success(editorElement.value);
          }, self.table.options.headerFilterLiveFilterDelay);
        };

        column.modules.filter.headerElement = editorElement;
        column.modules.filter.attrType = editorElement.hasAttribute("type") ? editorElement.getAttribute("type").toLowerCase() : "";
        column.modules.filter.tagType = editorElement.tagName.toLowerCase();

        if (column.definition.headerFilterLiveFilter !== false) {
          if (!(column.definition.headerFilter === 'autocomplete' || column.definition.headerFilter === 'tickCross' || (column.definition.editor === 'autocomplete' || column.definition.editor === 'tickCross') && column.definition.headerFilter === true)) {
            editorElement.addEventListener("keyup", searchTrigger);
            editorElement.addEventListener("search", searchTrigger); //update number filtered columns on change

            if (column.modules.filter.attrType == "number") {
              editorElement.addEventListener("change", function (e) {
                success(editorElement.value);
              });
            } //change text inputs to search inputs to allow for clearing of field


            if (column.modules.filter.attrType == "text" && this.table.browser !== "ie") {
              editorElement.setAttribute("type", "search"); // editorElement.off("change blur"); //prevent blur from triggering filter and preventing selection click
            }
          } //prevent input and select elements from propagating click to column sorters etc


          if (column.modules.filter.tagType == "input" || column.modules.filter.tagType == "select" || column.modules.filter.tagType == "textarea") {
            editorElement.addEventListener("mousedown", function (e) {
              e.stopPropagation();
            });
          }
        }

        filterElement.appendChild(editorElement);
        column.contentElement.appendChild(filterElement);

        if (!reinitialize) {
          self.headerFilterColumns.push(column);
        }
      }
    } else {
      console.warn("Filter Error - Cannot add header filter, column has no field set:", column.definition.title);
    }
  } //hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)


  hideHeaderFilterElements() {
    this.headerFilterColumns.forEach(function (column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        column.modules.filter.headerElement.style.display = 'none';
      }
    });
  } //show all header filter elements (used to ensure correct column widths in "fitData" layout mode)


  showHeaderFilterElements() {
    this.headerFilterColumns.forEach(function (column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        column.modules.filter.headerElement.style.display = '';
      }
    });
  } //programmatically set focus of header filter


  setHeaderFilterFocus(column) {
    if (column.modules.filter && column.modules.filter.headerElement) {
      column.modules.filter.headerElement.focus();
    } else {
      console.warn("Column Filter Focus Error - No header filter set on column:", column.getField());
    }
  } //programmatically get value of header filter


  getHeaderFilterValue(column) {
    if (column.modules.filter && column.modules.filter.headerElement) {
      return column.modules.filter.value;
    } else {
      console.warn("Column Filter Error - No header filter set on column:", column.getField());
    }
  } //programmatically set value of header filter


  setHeaderFilterValue(column, value) {
    if (column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        this.generateHeaderFilterElement(column, value, true);
        column.modules.filter.success(value);
      } else {
        console.warn("Column Filter Error - No header filter set on column:", column.getField());
      }
    }
  }

  reloadHeaderFilter(column) {
    if (column) {
      if (column.modules.filter && column.modules.filter.headerElement) {
        this.generateHeaderFilterElement(column, column.modules.filter.value, true);
      } else {
        console.warn("Column Filter Error - No header filter set on column:", column.getField());
      }
    }
  }

  refreshFilter() {
    if (this.tableInitialized) {
      if (this.table.options.filterMode === "remote") {
        this.reloadData(null, false, false);
      } else {
        this.refreshData(true);
      }
    } //TODO - Persist left position of row manager
    // left = this.scrollLeft;
    // this.scrollHorizontal(left);

  } //check if the filters has changed since last use


  trackChanges() {
    this.changed = true;
    this.dispatch("filter-changed");
  } //check if the filters has changed since last use


  hasChanged() {
    var changed = this.changed;
    this.changed = false;
    return changed;
  } //set standard filters


  setFilter(field, type, value, params) {
    this.filterList = [];

    if (!Array.isArray(field)) {
      field = [{
        field: field,
        type: type,
        value: value,
        params: params
      }];
    }

    this.addFilter(field);
  } //add filter to array


  addFilter(field, type, value, params) {
    var changed = false;

    if (!Array.isArray(field)) {
      field = [{
        field: field,
        type: type,
        value: value,
        params: params
      }];
    }

    field.forEach(filter => {
      filter = this.findFilter(filter);

      if (filter) {
        this.filterList.push(filter);
        changed = true;
      }
    });

    if (changed) {
      this.trackChanges();
    }
  }

  findFilter(filter) {
    var column;

    if (Array.isArray(filter)) {
      return this.findSubFilters(filter);
    }

    var filterFunc = false;

    if (typeof filter.field == "function") {
      filterFunc = function (data) {
        return filter.field(data, filter.type || {}); // pass params to custom filter function
      };
    } else {
      if (Filter.filters[filter.type]) {
        column = this.table.columnManager.getColumnByField(filter.field);

        if (column) {
          filterFunc = function (data) {
            return Filter.filters[filter.type](filter.value, column.getFieldValue(data), data, filter.params || {});
          };
        } else {
          filterFunc = function (data) {
            return Filter.filters[filter.type](filter.value, data[filter.field], data, filter.params || {});
          };
        }
      } else {
        console.warn("Filter Error - No such filter type found, ignoring: ", filter.type);
      }
    }

    filter.func = filterFunc;
    return filter.func ? filter : false;
  }

  findSubFilters(filters) {
    var output = [];
    filters.forEach(filter => {
      filter = this.findFilter(filter);

      if (filter) {
        output.push(filter);
      }
    });
    return output.length ? output : false;
  } //get all filters


  getFilters(all, ajax) {
    var output = [];

    if (all) {
      output = this.getHeaderFilters();
    }

    if (ajax) {
      output.forEach(function (item) {
        if (typeof item.type == "function") {
          item.type = "function";
        }
      });
    }

    output = output.concat(this.filtersToArray(this.filterList, ajax));
    return output;
  } //filter to Object


  filtersToArray(filterList, ajax) {
    var output = [];
    filterList.forEach(filter => {
      var item;

      if (Array.isArray(filter)) {
        output.push(this.filtersToArray(filter, ajax));
      } else {
        item = {
          field: filter.field,
          type: filter.type,
          value: filter.value
        };

        if (ajax) {
          if (typeof item.type == "function") {
            item.type = "function";
          }
        }

        output.push(item);
      }
    });
    return output;
  } //get all filters


  getHeaderFilters() {
    var output = [];

    for (var key in this.headerFilters) {
      output.push({
        field: key,
        type: this.headerFilters[key].type,
        value: this.headerFilters[key].value
      });
    }

    return output;
  } //remove filter from array


  removeFilter(field, type, value) {
    if (!Array.isArray(field)) {
      field = [{
        field: field,
        type: type,
        value: value
      }];
    }

    field.forEach(filter => {
      var index = -1;

      if (typeof filter.field == "object") {
        index = this.filterList.findIndex(element => {
          return filter === element;
        });
      } else {
        index = this.filterList.findIndex(element => {
          return filter.field === element.field && filter.type === element.type && filter.value === element.value;
        });
      }

      if (index > -1) {
        this.filterList.splice(index, 1);
      } else {
        console.warn("Filter Error - No matching filter type found, ignoring: ", filter.type);
      }
    });
    this.trackChanges();
  } //clear filters


  clearFilter(all) {
    this.filterList = [];

    if (all) {
      this.clearHeaderFilter();
    }

    this.trackChanges();
  } //clear header filters


  clearHeaderFilter() {
    this.headerFilters = {};
    this.prevHeaderFilterChangeCheck = "{}";
    this.headerFilterColumns.forEach(column => {
      if (typeof column.modules.filter.value !== "undefined") {
        delete column.modules.filter.value;
      }

      column.modules.filter.prevSuccess = undefined;
      this.reloadHeaderFilter(column);
    });
    this.trackChanges();
  } //search data and return matching rows


  search(searchType, field, type, value) {
    var activeRows = [],
        filterList = [];

    if (!Array.isArray(field)) {
      field = [{
        field: field,
        type: type,
        value: value
      }];
    }

    field.forEach(filter => {
      filter = this.findFilter(filter);

      if (filter) {
        filterList.push(filter);
      }
    });
    this.table.rowManager.rows.forEach(row => {
      var match = true;
      filterList.forEach(filter => {
        if (!this.filterRecurse(filter, row.getData())) {
          match = false;
        }
      });

      if (match) {
        activeRows.push(searchType === "data" ? row.getData("data") : row.getComponent());
      }
    });
    return activeRows;
  } //filter row array


  filter(rowList, filters) {
    var activeRows = [],
        activeRowComponents = [];

    if (this.subscribedExternal("dataFiltering")) {
      this.dispatchExternal("dataFiltering", this.getFilters(true));
    }

    if (this.table.options.filterMode !== "remote" && (this.filterList.length || Object.keys(this.headerFilters).length)) {
      rowList.forEach(row => {
        if (this.filterRow(row)) {
          activeRows.push(row);
        }
      });
    } else {
      activeRows = rowList.slice(0);
    }

    if (this.subscribedExternal("dataFiltered")) {
      activeRows.forEach(row => {
        activeRowComponents.push(row.getComponent());
      });
      this.dispatchExternal("dataFiltered", this.getFilters(true), activeRowComponents);
    }

    return activeRows;
  } //filter individual row


  filterRow(row, filters) {
    var match = true,
        data = row.getData();
    this.filterList.forEach(filter => {
      if (!this.filterRecurse(filter, data)) {
        match = false;
      }
    });

    for (var field in this.headerFilters) {
      if (!this.headerFilters[field].func(data)) {
        match = false;
      }
    }

    return match;
  }

  filterRecurse(filter, data) {
    var match = false;

    if (Array.isArray(filter)) {
      filter.forEach(subFilter => {
        if (this.filterRecurse(subFilter, data)) {
          match = true;
        }
      });
    } else {
      match = filter.func(data);
    }

    return match;
  }

}

exports.FilterModule = Filter;
Filter.moduleName = "filter"; //load defaults

Filter.filters = defaultFilters;

function plaintext(cell, formatterParams, onRendered) {
  return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
}

function html$1(cell, formatterParams, onRendered) {
  return cell.getValue();
}

function textarea$1(cell, formatterParams, onRendered) {
  cell.getElement().style.whiteSpace = "pre-wrap";
  return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
}

function money(cell, formatterParams, onRendered) {
  var floatVal = parseFloat(cell.getValue()),
      sign = "",
      number,
      integer,
      decimal,
      rgx;
  var decimalSym = formatterParams.decimal || ".";
  var thousandSym = formatterParams.thousand || ",";
  var negativeSign = formatterParams.negativeSign || "-";
  var symbol = formatterParams.symbol || "";
  var after = !!formatterParams.symbolAfter;
  var precision = typeof formatterParams.precision !== "undefined" ? formatterParams.precision : 2;

  if (isNaN(floatVal)) {
    return this.emptyToSpace(this.sanitizeHTML(cell.getValue()));
  }

  if (floatVal < 0) {
    floatVal = Math.abs(floatVal);
    sign = negativeSign;
  }

  number = precision !== false ? floatVal.toFixed(precision) : floatVal;
  number = String(number).split(".");
  integer = number[0];
  decimal = number.length > 1 ? decimalSym + number[1] : "";

  if (formatterParams.thousand !== false) {
    rgx = /(\d+)(\d{3})/;

    while (rgx.test(integer)) {
      integer = integer.replace(rgx, "$1" + thousandSym + "$2");
    }
  }

  return after ? sign + integer + decimal + symbol : sign + symbol + integer + decimal;
}

function link(cell, formatterParams, onRendered) {
  var value = cell.getValue(),
      urlPrefix = formatterParams.urlPrefix || "",
      download = formatterParams.download,
      label = value,
      el = document.createElement("a"),
      data;

  function labelTraverse(path, data) {
    var item = path.shift(),
        value = data[item];

    if (path.length && typeof value === "object") {
      return labelTraverse(path, value);
    }

    return value;
  }

  if (formatterParams.labelField) {
    data = cell.getData();
    label = labelTraverse(formatterParams.labelField.split(this.table.options.nestedFieldSeparator), data);
  }

  if (formatterParams.label) {
    switch (typeof formatterParams.label) {
      case "string":
        label = formatterParams.label;
        break;

      case "function":
        label = formatterParams.label(cell);
        break;
    }
  }

  if (label) {
    if (formatterParams.urlField) {
      data = cell.getData();
      value = data[formatterParams.urlField];
    }

    if (formatterParams.url) {
      switch (typeof formatterParams.url) {
        case "string":
          value = formatterParams.url;
          break;

        case "function":
          value = formatterParams.url(cell);
          break;
      }
    }

    el.setAttribute("href", urlPrefix + value);

    if (formatterParams.target) {
      el.setAttribute("target", formatterParams.target);
    }

    if (formatterParams.download) {
      if (typeof download == "function") {
        download = download(cell);
      } else {
        download = download === true ? "" : download;
      }

      el.setAttribute("download", download);
    }

    el.innerHTML = this.emptyToSpace(this.sanitizeHTML(label));
    return el;
  } else {
    return "&nbsp;";
  }
}

function image(cell, formatterParams, onRendered) {
  var el = document.createElement("img"),
      src = cell.getValue();

  if (formatterParams.urlPrefix) {
    src = formatterParams.urlPrefix + cell.getValue();
  }

  if (formatterParams.urlSuffix) {
    src = src + formatterParams.urlSuffix;
  }

  el.setAttribute("src", src);

  switch (typeof formatterParams.height) {
    case "number":
      el.style.height = formatterParams.height + "px";
      break;

    case "string":
      el.style.height = formatterParams.height;
      break;
  }

  switch (typeof formatterParams.width) {
    case "number":
      el.style.width = formatterParams.width + "px";
      break;

    case "string":
      el.style.width = formatterParams.width;
      break;
  }

  el.addEventListener("load", function () {
    cell.getRow().normalizeHeight();
  });
  return el;
}

function tickCross$1(cell, formatterParams, onRendered) {
  var value = cell.getValue(),
      element = cell.getElement(),
      empty = formatterParams.allowEmpty,
      truthy = formatterParams.allowTruthy,
      trueValueSet = Object.keys(formatterParams).includes("trueValue"),
      tick = typeof formatterParams.tickElement !== "undefined" ? formatterParams.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>',
      cross = typeof formatterParams.crossElement !== "undefined" ? formatterParams.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';

  if (trueValueSet && value === formatterParams.trueValue || !trueValueSet && (truthy && value || value === true || value === "true" || value === "True" || value === 1 || value === "1")) {
    element.setAttribute("aria-checked", true);
    return tick || "";
  } else {
    if (empty && (value === "null" || value === "" || value === null || typeof value === "undefined")) {
      element.setAttribute("aria-checked", "mixed");
      return "";
    } else {
      element.setAttribute("aria-checked", false);
      return cross || "";
    }
  }
}

function datetime$1(cell, formatterParams, onRendered) {
  var DT = window.DateTime || luxon.DateTime;
  var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
  var outputFormat = formatterParams.outputFormat || "dd/MM/yyyy HH:mm:ss";
  var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
  var value = cell.getValue();

  if (typeof DT != "undefined") {
    var newDatetime;

    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }

    if (newDatetime.isValid) {
      if (formatterParams.timezone) {
        newDatetime = newDatetime.setZone(formatterParams.timezone);
      }

      return newDatetime.toFormat(outputFormat);
    } else {
      if (invalid === true || !value) {
        return value;
      } else if (typeof invalid === "function") {
        return invalid(value);
      } else {
        return invalid;
      }
    }
  } else {
    console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
  }
}

function datetimediff(cell, formatterParams, onRendered) {
  var DT = window.DateTime || luxon.DateTime;
  var inputFormat = formatterParams.inputFormat || "yyyy-MM-dd HH:mm:ss";
  var invalid = typeof formatterParams.invalidPlaceholder !== "undefined" ? formatterParams.invalidPlaceholder : "";
  var suffix = typeof formatterParams.suffix !== "undefined" ? formatterParams.suffix : false;
  var unit = typeof formatterParams.unit !== "undefined" ? formatterParams.unit : "days";
  var humanize = typeof formatterParams.humanize !== "undefined" ? formatterParams.humanize : false;
  var date = typeof formatterParams.date !== "undefined" ? formatterParams.date : DT.now();
  var value = cell.getValue();

  if (typeof DT != "undefined") {
    var newDatetime;

    if (DT.isDateTime(value)) {
      newDatetime = value;
    } else if (inputFormat === "iso") {
      newDatetime = DT.fromISO(String(value));
    } else {
      newDatetime = DT.fromFormat(String(value), inputFormat);
    }

    if (newDatetime.isValid) {
      if (humanize) {
        return newDatetime.diff(date, unit).toHuman() + (suffix ? " " + suffix : "");
      } else {
        return parseInt(newDatetime.diff(date, unit)[unit]) + (suffix ? " " + suffix : "");
      }
    } else {
      if (invalid === true) {
        return value;
      } else if (typeof invalid === "function") {
        return invalid(value);
      } else {
        return invalid;
      }
    }
  } else {
    console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
  }
}

function lookup(cell, formatterParams, onRendered) {
  var value = cell.getValue();

  if (typeof formatterParams[value] === "undefined") {
    console.warn('Missing display value for ' + value);
    return value;
  }

  return formatterParams[value];
}

function star$1(cell, formatterParams, onRendered) {
  var value = cell.getValue(),
      element = cell.getElement(),
      maxStars = formatterParams && formatterParams.stars ? formatterParams.stars : 5,
      stars = document.createElement("span"),
      star = document.createElementNS('http://www.w3.org/2000/svg', "svg"),
      starActive = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>',
      starInactive = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>'; //style stars holder

  stars.style.verticalAlign = "middle"; //style star

  star.setAttribute("width", "14");
  star.setAttribute("height", "14");
  star.setAttribute("viewBox", "0 0 512 512");
  star.setAttribute("xml:space", "preserve");
  star.style.padding = "0 1px";
  value = value && !isNaN(value) ? parseInt(value) : 0;
  value = Math.max(0, Math.min(value, maxStars));

  for (var i = 1; i <= maxStars; i++) {
    var nextStar = star.cloneNode(true);
    nextStar.innerHTML = i <= value ? starActive : starInactive;
    stars.appendChild(nextStar);
  }

  element.style.whiteSpace = "nowrap";
  element.style.overflow = "hidden";
  element.style.textOverflow = "ellipsis";
  element.setAttribute("aria-label", value);
  return stars;
}

function traffic(cell, formatterParams, onRendered) {
  var value = this.sanitizeHTML(cell.getValue()) || 0,
      el = document.createElement("span"),
      max = formatterParams && formatterParams.max ? formatterParams.max : 100,
      min = formatterParams && formatterParams.min ? formatterParams.min : 0,
      colors = formatterParams && typeof formatterParams.color !== "undefined" ? formatterParams.color : ["red", "orange", "green"],
      color = "#666666",
      percent,
      percentValue;

  if (isNaN(value) || typeof cell.getValue() === "undefined") {
    return;
  }

  el.classList.add("tabulator-traffic-light"); //make sure value is in range

  percentValue = parseFloat(value) <= max ? parseFloat(value) : max;
  percentValue = parseFloat(percentValue) >= min ? parseFloat(percentValue) : min; //workout percentage

  percent = (max - min) / 100;
  percentValue = Math.round((percentValue - min) / percent); //set color

  switch (typeof colors) {
    case "string":
      color = colors;
      break;

    case "function":
      color = colors(value);
      break;

    case "object":
      if (Array.isArray(colors)) {
        var unit = 100 / colors.length;
        var index = Math.floor(percentValue / unit);
        index = Math.min(index, colors.length - 1);
        index = Math.max(index, 0);
        color = colors[index];
        break;
      }

  }

  el.style.backgroundColor = color;
  return el;
}

function progress$1(cell, formatterParams = {}, onRendered) {
  //progress bar
  var value = this.sanitizeHTML(cell.getValue()) || 0,
      element = cell.getElement(),
      max = formatterParams.max ? formatterParams.max : 100,
      min = formatterParams.min ? formatterParams.min : 0,
      legendAlign = formatterParams.legendAlign ? formatterParams.legendAlign : "center",
      percent,
      percentValue,
      color,
      legend,
      legendColor; //make sure value is in range

  percentValue = parseFloat(value) <= max ? parseFloat(value) : max;
  percentValue = parseFloat(percentValue) >= min ? parseFloat(percentValue) : min; //workout percentage

  percent = (max - min) / 100;
  percentValue = Math.round((percentValue - min) / percent); //set bar color

  switch (typeof formatterParams.color) {
    case "string":
      color = formatterParams.color;
      break;

    case "function":
      color = formatterParams.color(value);
      break;

    case "object":
      if (Array.isArray(formatterParams.color)) {
        let unit = 100 / formatterParams.color.length;
        let index = Math.floor(percentValue / unit);
        index = Math.min(index, formatterParams.color.length - 1);
        index = Math.max(index, 0);
        color = formatterParams.color[index];
        break;
      }

    default:
      color = "#2DC214";
  } //generate legend


  switch (typeof formatterParams.legend) {
    case "string":
      legend = formatterParams.legend;
      break;

    case "function":
      legend = formatterParams.legend(value);
      break;

    case "boolean":
      legend = value;
      break;

    default:
      legend = false;
  } //set legend color


  switch (typeof formatterParams.legendColor) {
    case "string":
      legendColor = formatterParams.legendColor;
      break;

    case "function":
      legendColor = formatterParams.legendColor(value);
      break;

    case "object":
      if (Array.isArray(formatterParams.legendColor)) {
        let unit = 100 / formatterParams.legendColor.length;
        let index = Math.floor(percentValue / unit);
        index = Math.min(index, formatterParams.legendColor.length - 1);
        index = Math.max(index, 0);
        legendColor = formatterParams.legendColor[index];
      }

      break;

    default:
      legendColor = "#000";
  }

  element.style.minWidth = "30px";
  element.style.position = "relative";
  element.setAttribute("aria-label", percentValue);
  var barEl = document.createElement("div");
  barEl.style.display = "inline-block";
  barEl.style.width = percentValue + "%";
  barEl.style.backgroundColor = color;
  barEl.style.height = "100%";
  barEl.setAttribute('data-max', max);
  barEl.setAttribute('data-min', min);
  var barContainer = document.createElement("div");
  barContainer.style.position = "relative";
  barContainer.style.width = "100%";
  barContainer.style.height = "100%";

  if (legend) {
    var legendEl = document.createElement("div");
    legendEl.style.position = "absolute";
    legendEl.style.top = 0;
    legendEl.style.left = 0;
    legendEl.style.textAlign = legendAlign;
    legendEl.style.width = "100%";
    legendEl.style.color = legendColor;
    legendEl.innerHTML = legend;
  }

  onRendered(function () {
    //handle custom element needed if formatter is to be included in printed/downloaded output
    if (!(cell instanceof CellComponent)) {
      var holderEl = document.createElement("div");
      holderEl.style.position = "absolute";
      holderEl.style.top = "4px";
      holderEl.style.bottom = "4px";
      holderEl.style.left = "4px";
      holderEl.style.right = "4px";
      element.appendChild(holderEl);
      element = holderEl;
    }

    element.appendChild(barContainer);
    barContainer.appendChild(barEl);

    if (legend) {
      barContainer.appendChild(legendEl);
    }
  });
  return "";
}

function color(cell, formatterParams, onRendered) {
  cell.getElement().style.backgroundColor = this.sanitizeHTML(cell.getValue());
  return "";
}

function buttonTick(cell, formatterParams, onRendered) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
}

function buttonCross(cell, formatterParams, onRendered) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
}

function rownum(cell, formatterParams, onRendered) {
  var content = document.createElement("span");
  var row = cell.getRow();
  row.watchPosition(position => {
    content.innerText = position;
  });
  return content;
}

function handle(cell, formatterParams, onRendered) {
  cell.getElement().classList.add("tabulator-row-handle");
  return "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
}

function responsiveCollapse(cell, formatterParams, onRendered) {
  var el = document.createElement("div"),
      config = cell.getRow()._row.modules.responsiveLayout;

  el.classList.add("tabulator-responsive-collapse-toggle");
  el.innerHTML = "<span class='tabulator-responsive-collapse-toggle-open'>+</span><span class='tabulator-responsive-collapse-toggle-close'>-</span>";
  cell.getElement().classList.add("tabulator-row-handle");

  function toggleList(isOpen) {
    var collapseEl = config.element;
    config.open = isOpen;

    if (collapseEl) {
      if (config.open) {
        el.classList.add("open");
        collapseEl.style.display = '';
      } else {
        el.classList.remove("open");
        collapseEl.style.display = 'none';
      }
    }
  }

  el.addEventListener("click", function (e) {
    e.stopImmediatePropagation();
    toggleList(!config.open);
    cell.getTable().rowManager.adjustTableSize();
  });
  toggleList(config.open);
  return el;
}

function rowSelection(cell, formatterParams, onRendered) {
  var checkbox = document.createElement("input");
  var blocked = false;
  checkbox.type = 'checkbox';
  checkbox.setAttribute("aria-label", "Select Row");

  if (this.table.modExists("selectRow", true)) {
    checkbox.addEventListener("click", e => {
      e.stopPropagation();
    });

    if (typeof cell.getRow == 'function') {
      var row = cell.getRow();

      if (row instanceof RowComponent) {
        checkbox.addEventListener("change", e => {
          if (this.table.options.selectableRangeMode === "click") {
            if (!blocked) {
              row.toggleSelect();
            } else {
              blocked = false;
            }
          } else {
            row.toggleSelect();
          }
        });

        if (this.table.options.selectableRangeMode === "click") {
          checkbox.addEventListener("click", e => {
            blocked = true;
            this.table.modules.selectRow.handleComplexRowClick(row._row, e);
          });
        }

        checkbox.checked = row.isSelected && row.isSelected();
        this.table.modules.selectRow.registerRowSelectCheckbox(row, checkbox);
      } else {
        checkbox = "";
      }
    } else {
      checkbox.addEventListener("change", e => {
        if (this.table.modules.selectRow.selectedRows.length) {
          this.table.deselectRow();
        } else {
          this.table.selectRow(formatterParams.rowRange);
        }
      });
      this.table.modules.selectRow.registerHeaderSelectCheckbox(checkbox);
    }
  }

  return checkbox;
}

var defaultFormatters = {
  plaintext: plaintext,
  html: html$1,
  textarea: textarea$1,
  money: money,
  link: link,
  image: image,
  tickCross: tickCross$1,
  datetime: datetime$1,
  datetimediff: datetimediff,
  lookup: lookup,
  star: star$1,
  traffic: traffic,
  progress: progress$1,
  color: color,
  buttonTick: buttonTick,
  buttonCross: buttonCross,
  rownum: rownum,
  handle: handle,
  responsiveCollapse: responsiveCollapse,
  rowSelection: rowSelection
};

class Format extends Module {
  constructor(table) {
    super(table);
    this.registerColumnOption("formatter");
    this.registerColumnOption("formatterParams");
    this.registerColumnOption("formatterPrint");
    this.registerColumnOption("formatterPrintParams");
    this.registerColumnOption("formatterClipboard");
    this.registerColumnOption("formatterClipboardParams");
    this.registerColumnOption("formatterHtmlOutput");
    this.registerColumnOption("formatterHtmlOutputParams");
    this.registerColumnOption("titleFormatter");
    this.registerColumnOption("titleFormatterParams");
  }

  initialize() {
    this.subscribe("cell-format", this.formatValue.bind(this));
    this.subscribe("cell-rendered", this.cellRendered.bind(this));
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("column-format", this.formatHeader.bind(this));
  } //initialize column formatter


  initializeColumn(column) {
    column.modules.format = this.lookupFormatter(column, "");

    if (typeof column.definition.formatterPrint !== "undefined") {
      column.modules.format.print = this.lookupFormatter(column, "Print");
    }

    if (typeof column.definition.formatterClipboard !== "undefined") {
      column.modules.format.clipboard = this.lookupFormatter(column, "Clipboard");
    }

    if (typeof column.definition.formatterHtmlOutput !== "undefined") {
      column.modules.format.htmlOutput = this.lookupFormatter(column, "HtmlOutput");
    }
  }

  lookupFormatter(column, type) {
    var config = {
      params: column.definition["formatter" + type + "Params"] || {}
    },
        formatter = column.definition["formatter" + type]; //set column formatter

    switch (typeof formatter) {
      case "string":
        if (Format.formatters[formatter]) {
          config.formatter = Format.formatters[formatter];
        } else {
          console.warn("Formatter Error - No such formatter found: ", formatter);
          config.formatter = Format.formatters.plaintext;
        }

        break;

      case "function":
        config.formatter = formatter;
        break;

      default:
        config.formatter = Format.formatters.plaintext;
        break;
    }

    return config;
  }

  cellRendered(cell) {
    if (cell.modules.format && cell.modules.format.renderedCallback && !cell.modules.format.rendered) {
      cell.modules.format.renderedCallback();
      cell.modules.format.rendered = true;
    }
  } //return a formatted value for a column header


  formatHeader(column, title, el) {
    var formatter, params, onRendered, mockCell;

    if (column.definition.titleFormatter) {
      formatter = this.getFormatter(column.definition.titleFormatter);

      onRendered = callback => {
        column.titleFormatterRendered = callback;
      };

      mockCell = {
        getValue: function () {
          return title;
        },
        getElement: function () {
          return el;
        }
      };
      params = column.definition.titleFormatterParams || {};
      params = typeof params === "function" ? params() : params;
      return formatter.call(this, mockCell, params, onRendered);
    } else {
      return title;
    }
  } //return a formatted value for a cell


  formatValue(cell) {
    var component = cell.getComponent(),
        params = typeof cell.column.modules.format.params === "function" ? cell.column.modules.format.params(component) : cell.column.modules.format.params;

    function onRendered(callback) {
      if (!cell.modules.format) {
        cell.modules.format = {};
      }

      cell.modules.format.renderedCallback = callback;
      cell.modules.format.rendered = false;
    }

    return cell.column.modules.format.formatter.call(this, component, params, onRendered);
  }

  formatExportValue(cell, type) {
    var formatter = cell.column.modules.format[type],
        params;

    if (formatter) {
      params = typeof formatter.params === "function" ? formatter.params(cell.getComponent()) : formatter.params;

      function onRendered(callback) {
        if (!cell.modules.format) {
          cell.modules.format = {};
        }

        cell.modules.format.renderedCallback = callback;
        cell.modules.format.rendered = false;
      }

      return formatter.formatter.call(this, cell.getComponent(), params, onRendered);
    } else {
      return this.formatValue(cell);
    }
  }

  sanitizeHTML(value) {
    if (value) {
      var entityMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '/': '&#x2F;',
        '`': '&#x60;',
        '=': '&#x3D;'
      };
      return String(value).replace(/[&<>"'`=/]/g, function (s) {
        return entityMap[s];
      });
    } else {
      return value;
    }
  }

  emptyToSpace(value) {
    return value === null || typeof value === "undefined" || value === "" ? "&nbsp;" : value;
  } //get formatter for cell


  getFormatter(formatter) {
    switch (typeof formatter) {
      case "string":
        if (Format.formatters[formatter]) {
          formatter = Format.formatters[formatter];
        } else {
          console.warn("Formatter Error - No such formatter found: ", formatter);
          formatter = Format.formatters.plaintext;
        }

        break;

      case "function":
        //Custom formatter Function, do nothing
        break;

      default:
        formatter = Format.formatters.plaintext;
        break;
    }

    return formatter;
  }

}

exports.FormatModule = Format;
Format.moduleName = "format"; //load defaults

Format.formatters = defaultFormatters;

class FrozenColumns extends Module {
  constructor(table) {
    super(table);
    this.leftColumns = [];
    this.rightColumns = [];
    this.leftMargin = 0;
    this.rightMargin = 0;
    this.rightPadding = 0;
    this.initializationMode = "left";
    this.active = false;
    this.blocked = true;
    this.registerColumnOption("frozen");
  } //reset initial state


  reset() {
    this.initializationMode = "left";
    this.leftColumns = [];
    this.rightColumns = [];
    this.leftMargin = 0;
    this.rightMargin = 0;
    this.rightMargin = 0;
    this.active = false;
    this.table.columnManager.headersElement.style.marginLeft = 0;
    this.table.columnManager.element.style.paddingRight = 0;
  }

  initialize() {
    this.subscribe("cell-layout", this.layoutCell.bind(this));
    this.subscribe("column-init", this.initializeColumn.bind(this));
    this.subscribe("column-width", this.layout.bind(this));
    this.subscribe("row-layout-after", this.layoutRow.bind(this));
    this.subscribe("table-layout", this.layout.bind(this));
    this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
    this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
    this.subscribe("columns-loading", this.reset.bind(this));
    this.subscribe("column-add", this.reinitializeColumns.bind(this));
    this.subscribe("column-delete", this.reinitializeColumns.bind(this));
    this.subscribe("table-redraw", this.layout.bind(this));
    this.subscribe("layout-refreshing", this.blockLayout.bind(this));
    this.subscribe("layout-refreshed", this.unblockLayout.bind(this));
  }

  blockLayout() {
    this.blocked = true;
  }

  unblockLayout() {
    this.blocked = false;
  }

  layoutCell(cell) {
    this.layoutElement(cell.element, cell.column);
  }

  reinitializeColumns() {
    this.reset();
    this.table.columnManager.columnsByIndex.forEach(column => {
      this.initializeColumn(column);
    });
  } //initialize specific column


  initializeColumn(column) {
    var config = {
      margin: 0,
      edge: false
    };

    if (!column.isGroup) {
      if (this.frozenCheck(column)) {
        config.position = this.initializationMode;

        if (this.initializationMode == "left") {
          this.leftColumns.push(column);
        } else {
          this.rightColumns.unshift(column);
        }

        this.active = true;
        column.modules.frozen = config;
      } else {
        this.initializationMode = "right";
      }
    }
  }

  frozenCheck(column) {
    if (column.parent.isGroup && column.definition.frozen) {
      console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups");
    }

    if (column.parent.isGroup) {
      return this.frozenCheck(column.parent);
    } else {
      return column.definition.frozen;
    }
  } //quick layout to smooth horizontal scrolling


  scrollHorizontal() {
    if (this.active) {
      this.calcMargins(true);
      this.layoutColumnPosition();
      this.layoutCalcRows();
      this.reinitializeRows();
    }
  } //calculate margins for rows


  calcMargins(scroll) {
    if (!scroll) {
      this.leftMargin = this._calcSpace(this.leftColumns, this.leftColumns.length) + "px";
      this.rightMargin = this._calcSpace(this.rightColumns, this.rightColumns.length) + "px";
      this.table.rowManager.tableElement.style.marginRight = this.rightMargin;
    } //calculate right frozen columns


    this.rightPadding = this.table.rowManager.element.clientWidth + this.table.columnManager.scrollLeft;
  } //layout calculation rows


  layoutCalcRows() {
    if (this.table.modExists("columnCalcs")) {
      if (this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow) {
        this.layoutRow(this.table.modules.columnCalcs.topRow);
      }

      if (this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow) {
        this.layoutRow(this.table.modules.columnCalcs.botRow);
      }

      if (this.table.modExists("groupRows")) {
        this.layoutGroupCalcs(this.table.modules.groupRows.getGroups());
      }
    }
  }

  layoutGroupCalcs(groups) {
    groups.forEach(group => {
      if (group.calcs.top) {
        this.layoutRow(group.calcs.top);
      }

      if (group.calcs.bottom) {
        this.layoutRow(group.calcs.bottom);
      }

      if (group.groupList && group.groupList.length) {
        this.layoutGroupCalcs(group.groupList);
      }
    });
  } //calculate column positions and layout headers


  layoutColumnPosition(allCells) {
    var leftParents = [];
    var leftMargin = 0;
    var rightMargin = 0;
    this.table.columnManager.headersElement.style.marginLeft = this.leftMargin;
    this.table.columnManager.element.style.paddingRight = this.rightMargin;
    this.leftColumns.forEach((column, i) => {
      column.modules.frozen.marginValue = leftMargin + this.table.columnManager.scrollLeft;
      column.modules.frozen.margin = column.modules.frozen.marginValue + "px";

      if (column.visible) {
        leftMargin += column.getWidth();
      }

      if (i == this.leftColumns.length - 1) {
        column.modules.frozen.edge = true;
      } else {
        column.modules.frozen.edge = false;
      }

      if (column.parent.isGroup) {
        var parentEl = this.getColGroupParentElement(column);

        if (!leftParents.includes(parentEl)) {
          this.layoutElement(parentEl, column);
          leftParents.push(parentEl);
        }

        if (column.modules.frozen.edge) {
          parentEl.classList.add("tabulator-frozen-" + column.modules.frozen.position);
        }
      } else {
        this.layoutElement(column.getElement(), column);
      }

      if (allCells) {
        column.cells.forEach(cell => {
          this.layoutElement(cell.getElement(true), column);
        });
      }
    });
    this.rightColumns.forEach((column, i) => {
      if (column.visible) {
        rightMargin += column.getWidth();
      }

      column.modules.frozen.marginValue = this.rightPadding - rightMargin;
      column.modules.frozen.margin = column.modules.frozen.marginValue + "px";

      if (i == this.rightColumns.length - 1) {
        column.modules.frozen.edge = true;
      } else {
        column.modules.frozen.edge = false;
      }

      if (column.parent.isGroup) {
        this.layoutElement(this.getColGroupParentElement(column), column);
      } else {
        this.layoutElement(column.getElement(), column);
      }

      if (allCells) {
        column.cells.forEach(cell => {
          this.layoutElement(cell.getElement(true), column);
        });
      }
    });
  }

  getColGroupParentElement(column) {
    return column.parent.isGroup ? this.getColGroupParentElement(column.parent) : column.getElement();
  } //layout columns appropriately


  layout() {
    if (this.active && !this.blocked) {
      //calculate row padding
      this.calcMargins(); //calculate left columns

      this.layoutColumnPosition();
      this.reinitializeRows();
      this.layoutCalcRows();
    }
  }

  reinitializeRows() {
    var visibleRows = this.table.rowManager.getVisibleRows(true);
    var otherRows = this.table.rowManager.getRows().filter(row => !visibleRows.includes(row));
    otherRows.forEach(row => {
      row.deinitialize();
    });
    visibleRows.forEach(row => {
      if (row.type === "row") {
        this.layoutRow(row);
      }
    });
  }

  layoutRow(row) {
    // console.trace("row")
    var rowEl = row.getElement();
    rowEl.style.paddingLeft = this.leftMargin;

    if (this.table.options.layout === "fitDataFill" && this.rightColumns.length) {
      this.table.rowManager.getTableElement().style.minWidth = "calc(100% - " + this.rightMargin + ")";
    }

    this.leftColumns.forEach(column => {
      var cell = row.getCell(column);

      if (cell) {
        this.layoutElement(cell.getElement(true), column);
      }
    });
    this.rightColumns.forEach(column => {
      var cell = row.getCell(column);

      if (cell) {
        this.layoutElement(cell.getElement(true), column);
      }
    });
  }

  layoutElement(element, column) {
    if (column.modules.frozen) {
      element.style.position = "absolute";
      element.style.left = column.modules.frozen.margin;
      element.classList.add("tabulator-frozen");

      if (column.modules.frozen.edge) {
        element.classList.add("tabulator-frozen-" + column.modules.frozen.position);
      }
    }
  }

  _calcSpace(columns, index) {
    var width = 0;

    for (let i = 0; i < index; i++) {
      if (columns[i].visible) {
        width += columns[i].getWidth();
      }
    }

    return width;
  }

}

exports.FrozenColumnsModule = FrozenColumns;
FrozenColumns.moduleName = "frozenColumns";

class FrozenRows extends Module {
  constructor(table) {
    super(table);
    this.topElement = document.createElement("div");
    this.rows = []; //register component functions

    this.registerComponentFunction("row", "freeze", this.freezeRow.bind(this));
    this.registerComponentFunction("row", "unfreeze", this.unfreezeRow.bind(this));
    this.registerComponentFunction("row", "isFrozen", this.isRowFrozen.bind(this)); //register table options

    this.registerTableOption("frozenRowsField", "id"); //field to choose frozen rows by

    this.registerTableOption("frozenRows", false); //holder for frozen row identifiers
  }

  initialize() {
    this.rows = [];
    this.topElement.classList.add("tabulator-frozen-rows-holder"); // this.table.columnManager.element.append(this.topElement);

    this.table.columnManager.getElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling);
    this.subscribe("row-deleting", this.detachRow.bind(this));
    this.subscribe("rows-visible", this.visibleRows.bind(this));
    this.registerDisplayHandler(this.getRows.bind(this), 10);

    if (this.table.options.frozenRows) {
      this.subscribe("data-processed", this.initializeRows.bind(this));
      this.subscribe("row-added", this.initializeRow.bind(this));
    }
  }

  initializeRows() {
    this.table.rowManager.getRows().forEach(row => {
      this.initializeRow(row);
    });
  }

  initializeRow(row) {
    var frozenRows = this.table.options.frozenRows,
        rowType = typeof frozenRows;

    if (rowType === "number") {
      if (row.getPosition() && row.getPosition() + this.rows.length <= frozenRows) {
        this.freezeRow(row);
      }
    } else if (rowType === "function") {
      if (frozenRows.call(this.table, row.getComponent())) {
        this.freezeRow(row);
      }
    } else if (Array.isArray(frozenRows)) {
      if (frozenRows.includes(row.data[this.options("frozenRowsField")])) {
        this.freezeRow(row);
      }
    }
  }

  isRowFrozen(row) {
    var index = this.rows.indexOf(row);
    return index > -1;
  }

  isFrozen() {
    return !!this.rows.length;
  }

  visibleRows(viewable, rows) {
    this.rows.forEach(row => {
      rows.push(row);
    });
    return rows;
  } //filter frozen rows out of display data


  getRows(rows) {
    var output = rows.slice(0);
    this.rows.forEach(function (row) {
      var index = output.indexOf(row);

      if (index > -1) {
        output.splice(index, 1);
      }
    });
    return output;
  }

  freezeRow(row) {
    if (!row.modules.frozen) {
      row.modules.frozen = true;
      this.topElement.appendChild(row.getElement());
      row.initialize();
      row.normalizeHeight();
      this.table.rowManager.adjustTableSize();
      this.rows.push(row);
      this.refreshData(false, "display");
      this.styleRows();
    } else {
      console.warn("Freeze Error - Row is already frozen");
    }
  }

  unfreezeRow(row) {
    if (row.modules.frozen) {
      row.modules.frozen = false;
      this.detachRow(row);
      this.table.rowManager.adjustTableSize();
      this.refreshData(false, "display");

      if (this.rows.length) {
        this.styleRows();
      }
    } else {
      console.warn("Freeze Error - Row is already unfrozen");
    }
  }

  detachRow(row) {
    var index = this.rows.indexOf(row);

    if (index > -1) {
      var rowEl = row.getElement();

      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }

      this.rows.splice(index, 1);
    }
  }

  styleRows(row) {
    this.rows.forEach((row, i) => {
      this.table.rowManager.styleRow(row, i);
    });
  }

}

exports.FrozenRowsModule = FrozenRows;
FrozenRows.moduleName = "frozenRows"; //public group object

class GroupComponent {
  constructor(group) {
    this._group = group;
    this.type = "GroupComponent";
    return new Proxy(this, {
      get: function (target, name, receiver) {
        if (typeof target[name] !== "undefined") {
          return target[name];
        } else {
          return target._group.groupManager.table.componentFunctionBinder.handle("row", target._group, name);
        }
      }
    });
  }

  getKey() {
    return this._group.key;
  }

  getField() {
    return this._group.field;
  }

  getElement() {
    return this._group.element;
  }

  getRows() {
    return this._group.getRows(true);
  }

  getSubGroups() {
    return this._group.getSubGroups(true);
  }

  getParentGroup() {
    return this._group.parent ? this._group.parent.getComponent() : false;
  }

  isVisible() {
    return this._group.visible;
  }

  show() {
    this._group.show();
  }

  hide() {
    this._group.hide();
  }

  toggle() {
    this._group.toggleVisibility();
  }

  _getSelf() {
    return this._group;
  }

  getTable() {
    return this._group.groupManager.table;
  }

} //Group functions


exports.GroupComponent = GroupComponent;

class Group {
  constructor(groupManager, parent, level, key, field, generator, oldGroup) {
    this.groupManager = groupManager;
    this.parent = parent;
    this.key = key;
    this.level = level;
    this.field = field;
    this.hasSubGroups = level < groupManager.groupIDLookups.length - 1;
    this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow;
    this.type = "group"; //type of element

    this.old = oldGroup;
    this.rows = [];
    this.groups = [];
    this.groupList = [];
    this.generator = generator;
    this.element = false;
    this.elementContents = false;
    this.height = 0;
    this.outerHeight = 0;
    this.initialized = false;
    this.calcs = {};
    this.initialized = false;
    this.modules = {};
    this.arrowElement = false;
    this.visible = oldGroup ? oldGroup.visible : typeof groupManager.startOpen[level] !== "undefined" ? groupManager.startOpen[level] : groupManager.startOpen[0];
    this.component = null;
    this.createElements();
    this.addBindings();
    this.createValueGroups();
  }

  wipe() {
    if (this.groupList.length) {
      this.groupList.forEach(function (group) {
        group.wipe();
      });
    } else {
      this.rows.forEach(row => {
        if (row.modules) {
          delete row.modules.group;
        }
      });
    }

    this.element = false;
    this.arrowElement = false;
    this.elementContents = false;
  }

  createElements() {
    var arrow = document.createElement("div");
    arrow.classList.add("tabulator-arrow");
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-row");
    this.element.classList.add("tabulator-group");
    this.element.classList.add("tabulator-group-level-" + this.level);
    this.element.setAttribute("role", "rowgroup");
    this.arrowElement = document.createElement("div");
    this.arrowElement.classList.add("tabulator-group-toggle");
    this.arrowElement.appendChild(arrow); //setup movable rows

    if (this.groupManager.table.options.movableRows !== false && this.groupManager.table.modExists("moveRow")) {
      this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
    }
  }

  createValueGroups() {
    var level = this.level + 1;

    if (this.groupManager.allowedValues && this.groupManager.allowedValues[level]) {
      this.groupManager.allowedValues[level].forEach(value => {
        this._createGroup(value, level);
      });
    }
  }

  addBindings() {
    var toggleElement;

    if (this.groupManager.table.options.groupToggleElement) {
      toggleElement = this.groupManager.table.options.groupToggleElement == "arrow" ? this.arrowElement : this.element;
      toggleElement.addEventListener("click", e => {
        e.stopPropagation();
        e.stopImmediatePropagation();
        this.toggleVisibility();
      });
    }
  }

  _createGroup(groupID, level) {
    var groupKey = level + "_" + groupID;
    var group = new Group(this.groupManager, this, level, groupID, this.groupManager.groupIDLookups[level].field, this.groupManager.headerGenerator[level] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[groupKey] : false);
    this.groups[groupKey] = group;
    this.groupList.push(group);
  }

  _addRowToGroup(row) {
    var level = this.level + 1;

    if (this.hasSubGroups) {
      var groupID = this.groupManager.groupIDLookups[level].func(row.getData()),
          groupKey = level + "_" + groupID;

      if (this.groupManager.allowedValues && this.groupManager.allowedValues[level]) {
        if (this.groups[groupKey]) {
          this.groups[groupKey].addRow(row);
        }
      } else {
        if (!this.groups[groupKey]) {
          this._createGroup(groupID, level);
        }

        this.groups[groupKey].addRow(row);
      }
    }
  }

  _addRow(row) {
    this.rows.push(row);
    row.modules.group = this;
  }

  insertRow(row, to, after) {
    var data = this.conformRowData({});
    row.updateData(data);
    var toIndex = this.rows.indexOf(to);

    if (toIndex > -1) {
      if (after) {
        this.rows.splice(toIndex + 1, 0, row);
      } else {
        this.rows.splice(toIndex, 0, row);
      }
    } else {
      if (after) {
        this.rows.push(row);
      } else {
        this.rows.unshift(row);
      }
    }

    row.modules.group = this;
    this.generateGroupHeaderContents();

    if (this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table") {
      this.groupManager.table.modules.columnCalcs.recalcGroup(this);
    }

    this.groupManager.updateGroupRows(true);
  }

  scrollHeader(left) {
    if (this.arrowElement) {
      this.arrowElement.style.marginLeft = left;
      this.groupList.forEach(function (child) {
        child.scrollHeader(left);
      });
    }
  }

  getRowIndex(row) {} //update row data to match grouping constraints


  conformRowData(data) {
    if (this.field) {
      data[this.field] = this.key;
    } else {
      console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function");
    }

    if (this.parent) {
      data = this.parent.conformRowData(data);
    }

    return data;
  }

  removeRow(row) {
    var index = this.rows.indexOf(row);
    var el = row.getElement();

    if (index > -1) {
      this.rows.splice(index, 1);
    }

    if (!this.groupManager.table.options.groupValues && !this.rows.length) {
      if (this.parent) {
        this.parent.removeGroup(this);
      } else {
        this.groupManager.removeGroup(this);
      }

      this.groupManager.updateGroupRows(true);
    } else {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }

      this.generateGroupHeaderContents();

      if (this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table") {
        this.groupManager.table.modules.columnCalcs.recalcGroup(this);
      }
    }
  }

  removeGroup(group) {
    var groupKey = group.level + "_" + group.key,
        index;

    if (this.groups[groupKey]) {
      delete this.groups[groupKey];
      index = this.groupList.indexOf(group);

      if (index > -1) {
        this.groupList.splice(index, 1);
      }

      if (!this.groupList.length) {
        if (this.parent) {
          this.parent.removeGroup(this);
        } else {
          this.groupManager.removeGroup(this);
        }
      }
    }
  }

  getHeadersAndRows(noCalc) {
    var output = [];
    output.push(this);

    this._visSet();

    if (this.visible) {
      if (this.groupList.length) {
        this.groupList.forEach(function (group) {
          output = output.concat(group.getHeadersAndRows(noCalc));
        });
      } else {
        if (!noCalc && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs()) {
          if (this.calcs.top) {
            this.calcs.top.detachElement();
            this.calcs.top.deleteCells();
          }

          this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
          output.push(this.calcs.top);
        }

        output = output.concat(this.rows);

        if (!noCalc && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs()) {
          if (this.calcs.bottom) {
            this.calcs.bottom.detachElement();
            this.calcs.bottom.deleteCells();
          }

          this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
          output.push(this.calcs.bottom);
        }
      }
    } else {
      if (!this.groupList.length && this.groupManager.table.options.columnCalcs != "table") {
        if (this.groupManager.table.modExists("columnCalcs")) {
          if (!noCalc && this.groupManager.table.modules.columnCalcs.hasTopCalcs()) {
            if (this.calcs.top) {
              this.calcs.top.detachElement();
              this.calcs.top.deleteCells();
            }

            if (this.groupManager.table.options.groupClosedShowCalcs) {
              this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows);
              output.push(this.calcs.top);
            }
          }

          if (!noCalc && this.groupManager.table.modules.columnCalcs.hasBottomCalcs()) {
            if (this.calcs.bottom) {
              this.calcs.bottom.detachElement();
              this.calcs.bottom.deleteCells();
            }

            if (this.groupManager.table.options.groupClosedShowCalcs) {
              this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows);
              output.push(this.calcs.bottom);
            }
          }
        }
      }
    }

    return output;
  }

  getData(visible, transform) {
    var output = [];

    this._visSet();

    if (!visible || visible && this.visible) {
      this.rows.forEach(row => {
        output.push(row.getData(transform || "data"));
      });
    }

    return output;
  }

  getRowCount() {
    var count = 0;

    if (this.groupList.length) {
      this.groupList.forEach(group => {
        count += group.getRowCount();
      });
    } else {
      count = this.rows.length;
    }

    return count;
  }

  toggleVisibility() {
    if (this.visible) {
      this.hide();
    } else {
      this.show();
    }
  }

  hide() {
    this.visible = false;

    if (this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.remove("tabulator-group-visible");

      if (this.groupList.length) {
        this.groupList.forEach(group => {
          var rows = group.getHeadersAndRows();
          rows.forEach(row => {
            row.detachElement();
          });
        });
      } else {
        this.rows.forEach(row => {
          var rowEl = row.getElement();
          rowEl.parentNode.removeChild(rowEl);
        });
      }

      this.groupManager.table.rowManager.setDisplayRows(this.groupManager.updateGroupRows(), this.groupManager.getDisplayIndex());
      this.groupManager.checkBasicModeGroupHeaderWidth();
    } else {
      this.groupManager.updateGroupRows(true);
    }

    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), false);
  }

  show() {
    this.visible = true;

    if (this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.add("tabulator-group-visible");
      var prev = this.generateElement();

      if (this.groupList.length) {
        this.groupList.forEach(group => {
          var rows = group.getHeadersAndRows();
          rows.forEach(row => {
            var rowEl = row.getElement();
            prev.parentNode.insertBefore(rowEl, prev.nextSibling);
            row.initialize();
            prev = rowEl;
          });
        });
      } else {
        this.rows.forEach(row => {
          var rowEl = row.getElement();
          prev.parentNode.insertBefore(rowEl, prev.nextSibling);
          row.initialize();
          prev = rowEl;
        });
      }

      this.groupManager.table.rowManager.setDisplayRows(this.groupManager.updateGroupRows(), this.groupManager.getDisplayIndex());
      this.groupManager.checkBasicModeGroupHeaderWidth();
    } else {
      this.groupManager.updateGroupRows(true);
    }

    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), true);
  }

  _visSet() {
    var data = [];

    if (typeof this.visible == "function") {
      this.rows.forEach(function (row) {
        data.push(row.getData());
      });
      this.visible = this.visible(this.key, this.getRowCount(), data, this.getComponent());
    }
  }

  getRowGroup(row) {
    var match = false;

    if (this.groupList.length) {
      this.groupList.forEach(function (group) {
        var result = group.getRowGroup(row);

        if (result) {
          match = result;
        }
      });
    } else {
      if (this.rows.find(function (item) {
        return item === row;
      })) {
        match = this;
      }
    }

    return match;
  }

  getSubGroups(component) {
    var output = [];
    this.groupList.forEach(function (child) {
      output.push(component ? child.getComponent() : child);
    });
    return output;
  }

  getRows(component) {
    var output = [];
    this.rows.forEach(function (row) {
      output.push(component ? row.getComponent() : row);
    });
    return output;
  }

  generateGroupHeaderContents() {
    var data = [];
    this.rows.forEach(function (row) {
      data.push(row.getData());
    });
    this.elementContents = this.generator(this.key, this.getRowCount(), data, this.getComponent());

    while (this.element.firstChild) this.element.removeChild(this.element.firstChild);

    if (typeof this.elementContents === "string") {
      this.element.innerHTML = this.elementContents;
    } else {
      this.element.appendChild(this.elementContents);
    }

    this.element.insertBefore(this.arrowElement, this.element.firstChild);
  }

  getPath(path = []) {
    path.unshift(this.key);

    if (this.parent) {
      this.parent.getPath(path);
    }

    return path;
  } ////////////// Standard Row Functions //////////////


  getElement() {
    return this.elementContents ? this.element : this.generateElement();
  }

  generateElement() {
    this.addBindings = false;

    this._visSet();

    if (this.visible) {
      this.element.classList.add("tabulator-group-visible");
    } else {
      this.element.classList.remove("tabulator-group-visible");
    }

    for (var i = 0; i < this.element.childNodes.length; ++i) {
      this.element.childNodes[i].parentNode.removeChild(this.element.childNodes[i]);
    }

    this.generateGroupHeaderContents(); // this.addBindings();

    return this.element;
  }

  detachElement() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  } //normalize the height of elements in the row


  normalizeHeight() {
    this.setHeight(this.element.clientHeight);
  }

  initialize(force) {
    if (!this.initialized || force) {
      this.normalizeHeight();
      this.initialized = true;
    }
  }

  reinitialize() {
    this.initialized = false;
    this.height = 0;

    if (Helpers.elVisible(this.element)) {
      this.initialize(true);
    }
  }

  setHeight(height) {
    if (this.height != height) {
      this.height = height;
      this.outerHeight = this.element.offsetHeight;
    }
  } //return rows outer height


  getHeight() {
    return this.outerHeight;
  }

  getGroup() {
    return this;
  }

  reinitializeHeight() {}

  calcHeight() {}

  setCellHeight() {}

  clearCellHeight() {}

  deinitializeHeight() {} //////////////// Object Generation /////////////////


  getComponent() {
    if (!this.component) {
      this.component = new GroupComponent(this);
    }

    return this.component;
  }

}

class GroupRows extends Module {
  constructor(table) {
    super(table);
    this.groupIDLookups = false; //enable table grouping and set field to group by

    this.startOpen = [function () {
      return false;
    }]; //starting state of group

    this.headerGenerator = [function () {
      return "";
    }];
    this.groupList = []; //ordered list of groups

    this.allowedValues = false;
    this.groups = {}; //hold row groups

    this.displayIndex = 0; //index in display pipeline

    this.displayHandler = this.getRows.bind(this); //register table options

    this.registerTableOption("groupBy", false); //enable table grouping and set field to group by

    this.registerTableOption("groupStartOpen", true); //starting state of group

    this.registerTableOption("groupValues", false);
    this.registerTableOption("groupUpdateOnCellEdit", false);
    this.registerTableOption("groupHeader", false); //header generation function

    this.registerTableOption("groupHeaderPrint", null);
    this.registerTableOption("groupHeaderClipboard", null);
    this.registerTableOption("groupHeaderHtmlOutput", null);
    this.registerTableOption("groupHeaderDownload", null);
    this.registerTableOption("groupToggleElement", "arrow");
    this.registerTableOption("groupClosedShowCalcs", false); //register table functions

    this.registerTableFunction("setGroupBy", this.setGroupBy.bind(this));
    this.registerTableFunction("setGroupValues", this.setGroupValues.bind(this));
    this.registerTableFunction("setGroupStartOpen", this.setGroupStartOpen.bind(this));
    this.registerTableFunction("setGroupHeader", this.setGroupHeader.bind(this));
    this.registerTableFunction("getGroups", this.userGetGroups.bind(this));
    this.registerTableFunction("getGroupedData", this.userGetGroupedData.bind(this)); //register component functions

    this.registerComponentFunction("row", "getGroup", this.rowGetGroup.bind(this));
  } //initialize group configuration


  initialize() {
    if (this.table.options.groupBy) {
      if (this.table.options.groupUpdateOnCellEdit) {
        this.subscribe("cell-value-updated", this.cellUpdated.bind(this));
        this.subscribe("row-data-changed", this.reassignRowToGroup.bind(this), 0);
      }

      this.subscribe("table-built", this.configureGroupSetup.bind(this));
      this.subscribe("row-deleting", this.rowDeleting.bind(this));
      this.subscribe("row-deleted", this.rowsUpdated.bind(this));
      this.subscribe("scroll-horizontal", this.scrollHeaders.bind(this));
      this.subscribe("rows-wipe", this.wipe.bind(this));
      this.subscribe("rows-added", this.rowsUpdated.bind(this));
      this.subscribe("row-moving", this.rowMoving.bind(this));
      this.subscribe("row-adding-index", this.rowAddingIndex.bind(this));
      this.subscribe("rows-sample", this.rowSample.bind(this));
      this.subscribe("render-virtual-fill", this.virtualRenderFill.bind(this));
      this.registerDisplayHandler(this.displayHandler, 20);
      this.initialized = true;
    }
  }

  configureGroupSetup() {
    if (this.table.options.groupBy) {
      var groupBy = this.table.options.groupBy,
          startOpen = this.table.options.groupStartOpen,
          groupHeader = this.table.options.groupHeader;
      this.allowedValues = this.table.options.groupValues;

      if (Array.isArray(groupBy) && Array.isArray(groupHeader) && groupBy.length > groupHeader.length) {
        console.warn("Error creating group headers, groupHeader array is shorter than groupBy array");
      }

      this.headerGenerator = [function () {
        return "";
      }];
      this.startOpen = [function () {
        return false;
      }]; //starting state of group

      this.langBind("groups|item", (langValue, lang) => {
        this.headerGenerator[0] = (value, count, data) => {
          //header layout function
          return (typeof value === "undefined" ? "" : value) + "<span>(" + count + " " + (count === 1 ? langValue : lang.groups.items) + ")</span>";
        };
      });
      this.groupIDLookups = [];

      if (Array.isArray(groupBy)) {
        if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both") {
          this.table.modules.columnCalcs.removeCalcs();
        }
      } else {
        if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group") {
          var cols = this.table.columnManager.getRealColumns();
          cols.forEach(col => {
            if (col.definition.topCalc) {
              this.table.modules.columnCalcs.initializeTopRow();
            }

            if (col.definition.bottomCalc) {
              this.table.modules.columnCalcs.initializeBottomRow();
            }
          });
        }
      }

      if (!Array.isArray(groupBy)) {
        groupBy = [groupBy];
      }

      groupBy.forEach((group, i) => {
        var lookupFunc, column;

        if (typeof group == "function") {
          lookupFunc = group;
        } else {
          column = this.table.columnManager.getColumnByField(group);

          if (column) {
            lookupFunc = function (data) {
              return column.getFieldValue(data);
            };
          } else {
            lookupFunc = function (data) {
              return data[group];
            };
          }
        }

        this.groupIDLookups.push({
          field: typeof group === "function" ? false : group,
          func: lookupFunc,
          values: this.allowedValues ? this.allowedValues[i] : false
        });
      });

      if (startOpen) {
        if (!Array.isArray(startOpen)) {
          startOpen = [startOpen];
        }

        startOpen.forEach(level => {});
        this.startOpen = startOpen;
      }

      if (groupHeader) {
        this.headerGenerator = Array.isArray(groupHeader) ? groupHeader : [groupHeader];
      }
    } else {
      this.groupList = [];
      this.groups = {};
    }
  }

  rowSample(rows, prevValue) {
    var group = this.getGroups(false)[0];
    prevValue.push(group.getRows(false)[0]);
    return prevValue;
  }

  virtualRenderFill() {
    var el = this.table.rowManager.tableElement;
    var rows = this.table.rowManager.getVisibleRows();
    rows = rows.filter(row => {
      return row.type !== "group";
    });
    el.style.minWidth = !rows.length ? this.table.columnManager.getWidth() + "px" : ""; // if(this.table.options.groupBy){
    // 	if(this.layoutMode() != "fitDataFill" && rowsCount == this.table.modules.groupRows.countGroups()){
    // 		el.style.minWidth = this.table.columnManager.getWidth() + "px";
    // 	}
    // }
  }

  rowAddingIndex(row, index, top) {
    this.assignRowToGroup(row);
    var groupRows = row.modules.group.rows;

    if (groupRows.length > 1) {
      if (!index || index && groupRows.indexOf(index) == -1) {
        if (top) {
          if (groupRows[0] !== row) {
            index = groupRows[0];
            this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top);
          }
        } else {
          if (groupRows[groupRows.length - 1] !== row) {
            index = groupRows[groupRows.length - 1];
            this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top);
          }
        }
      } else {
        this.table.rowManager.moveRowInArray(row.modules.group.rows, row, index, !top);
      }
    }

    return index;
  }

  trackChanges() {
    this.dispatch("group-changed");
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////


  setGroupBy(groups) {
    this.table.options.groupBy = groups;

    if (!this.initialized) {
      this.initialize();
    }

    this.configureGroupSetup();
    this.refreshData();
    this.trackChanges();
  }

  setGroupValues(groupValues) {
    this.table.options.groupValues = groupValues;
    this.configureGroupSetup();
    this.refreshData();
    this.trackChanges();
  }

  setGroupStartOpen(values) {
    this.table.options.groupStartOpen = values;
    this.configureGroupSetup();

    if (this.table.options.groupBy) {
      this.refreshData();
      this.trackChanges();
    } else {
      console.warn("Grouping Update - cant refresh view, no groups have been set");
    }
  }

  setGroupHeader(values) {
    this.table.options.groupHeader = values;
    this.configureGroupSetup();

    if (this.table.options.groupBy) {
      this.refreshData();
      this.trackChanges();
    } else {
      console.warn("Grouping Update - cant refresh view, no groups have been set");
    }
  }

  userGetGroups(values) {
    return this.getGroups(true);
  } // get grouped table data in the same format as getData()


  userGetGroupedData() {
    return this.table.options.groupBy ? this.getGroupedData() : this.getData();
  } ///////////////////////////////////////
  ///////// Component Functions /////////
  ///////////////////////////////////////


  rowGetGroup(row) {
    return row.modules.group ? row.modules.group.getComponent() : false;
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  rowMoving(from, to, after) {
    if (!after && to instanceof Group) {
      to = this.table.rowManager.prevDisplayRow(from) || to;
    }

    var toGroup = to instanceof Group ? to : to.modules.group;
    var fromGroup = from instanceof Group ? from : from.modules.group;

    if (toGroup === fromGroup) {
      this.table.rowManager.moveRowInArray(toGroup.rows, from, to, after);
    } else {
      if (fromGroup) {
        fromGroup.removeRow(from);
      }

      toGroup.insertRow(from, to, after);
    }
  }

  rowDeleting(row) {
    //remove from group
    if (row.modules.group) {
      row.modules.group.removeRow(row);
    }
  }

  rowsUpdated(row) {
    this.updateGroupRows(true);
  }

  cellUpdated(cell) {
    this.reassignRowToGroup(cell.row);
  }

  setDisplayIndex(index) {
    this.displayIndex = index;
  }

  getDisplayIndex() {
    return this.displayIndex;
  } //return appropriate rows with group headers


  getRows(rows) {
    if (this.table.options.groupBy && this.groupIDLookups.length) {
      this.dispatchExternal("dataGrouping");
      this.generateGroups(rows);

      if (this.subscribedExternal("dataGrouped")) {
        this.dispatchExternal("dataGrouped", this.getGroups(true));
      }

      return this.updateGroupRows();
    } else {
      return rows.slice(0);
    }
  }

  getGroups(component) {
    var groupComponents = [];
    this.groupList.forEach(function (group) {
      groupComponents.push(component ? group.getComponent() : group);
    });
    return groupComponents;
  }

  getChildGroups(group) {
    var groupComponents = [];

    if (!group) {
      group = this;
    }

    group.groupList.forEach(child => {
      if (child.groupList.length) {
        groupComponents = groupComponents.concat(this.getChildGroups(child));
      } else {
        groupComponents.push(child);
      }
    });
    return groupComponents;
  }

  wipe() {
    this.groupList.forEach(function (group) {
      group.wipe();
    });
  }

  pullGroupListData(groupList) {
    var groupListData = [];
    groupList.forEach(group => {
      var groupHeader = {};
      groupHeader.level = 0;
      groupHeader.rowCount = 0;
      groupHeader.headerContent = "";
      var childData = [];

      if (group.hasSubGroups) {
        childData = this.pullGroupListData(group.groupList);
        groupHeader.level = group.level;
        groupHeader.rowCount = childData.length - group.groupList.length; // data length minus number of sub-headers

        groupHeader.headerContent = group.generator(group.key, groupHeader.rowCount, group.rows, group);
        groupListData.push(groupHeader);
        groupListData = groupListData.concat(childData);
      } else {
        groupHeader.level = group.level;
        groupHeader.headerContent = group.generator(group.key, group.rows.length, group.rows, group);
        groupHeader.rowCount = group.getRows().length;
        groupListData.push(groupHeader);
        group.getRows().forEach(row => {
          groupListData.push(row.getData("data"));
        });
      }
    });
    return groupListData;
  }

  getGroupedData() {
    return this.pullGroupListData(this.groupList);
  }

  getRowGroup(row) {
    var match = false;

    if (this.options("dataTree")) {
      row = this.table.modules.dataTree.getTreeParentRoot(row);
    }

    this.groupList.forEach(group => {
      var result = group.getRowGroup(row);

      if (result) {
        match = result;
      }
    });
    return match;
  }

  countGroups() {
    return this.groupList.length;
  }

  generateGroups(rows) {
    var oldGroups = this.groups;
    this.groups = {};
    this.groupList = [];

    if (this.allowedValues && this.allowedValues[0]) {
      this.allowedValues[0].forEach(value => {
        this.createGroup(value, 0, oldGroups);
      });
      rows.forEach(row => {
        this.assignRowToExistingGroup(row, oldGroups);
      });
    } else {
      rows.forEach(row => {
        this.assignRowToGroup(row, oldGroups);
      });
    }
  }

  createGroup(groupID, level, oldGroups) {
    var groupKey = level + "_" + groupID,
        group;
    oldGroups = oldGroups || [];
    group = new Group(this, false, level, groupID, this.groupIDLookups[0].field, this.headerGenerator[0], oldGroups[groupKey]);
    this.groups[groupKey] = group;
    this.groupList.push(group);
  }

  assignRowToExistingGroup(row, oldGroups) {
    var groupID = this.groupIDLookups[0].func(row.getData()),
        groupKey = "0_" + groupID;

    if (this.groups[groupKey]) {
      this.groups[groupKey].addRow(row);
    }
  }

  assignRowToGroup(row, oldGroups) {
    var groupID = this.groupIDLookups[0].func(row.getData()),
        newGroupNeeded = !this.groups["0_" + groupID];

    if (newGroupNeeded) {
      this.createGroup(groupID, 0, oldGroups);
    }

    this.groups["0_" + groupID].addRow(row);
    return !newGroupNeeded;
  }

  reassignRowToGroup(row) {
    if (row.type === "row") {
      var oldRowGroup = row.modules.group,
          oldGroupPath = oldRowGroup.getPath(),
          newGroupPath = this.getExpectedPath(row),
          samePath; // figure out if new group path is the same as old group path

      samePath = oldGroupPath.length == newGroupPath.length && oldGroupPath.every((element, index) => {
        return element === newGroupPath[index];
      }); // refresh if they new path and old path aren't the same (aka the row's groupings have changed)

      if (!samePath) {
        oldRowGroup.removeRow(row);
        this.assignRowToGroup(row, this.groups);
        this.refreshData(true);
      }
    }
  }

  getExpectedPath(row) {
    var groupPath = [],
        rowData = row.getData();
    this.groupIDLookups.forEach(groupId => {
      groupPath.push(groupId.func(rowData));
    });
    return groupPath;
  }

  updateGroupRows(force) {
    var output = [];
    this.groupList.forEach(group => {
      output = output.concat(group.getHeadersAndRows());
    });

    if (force) {
      this.refreshData(true, this.displayHandler);
    }

    return output;
  }

  scrollHeaders(left) {
    if (this.table.options.renderHorizontal === "virtual") {
      left -= this.table.columnManager.renderer.vDomPadLeft;
    }

    left = left + "px";
    this.groupList.forEach(group => {
      group.scrollHeader(left);
    });
  }

  removeGroup(group) {
    var groupKey = group.level + "_" + group.key,
        index;

    if (this.groups[groupKey]) {
      delete this.groups[groupKey];
      index = this.groupList.indexOf(group);

      if (index > -1) {
        this.groupList.splice(index, 1);
      }
    }
  }

  checkBasicModeGroupHeaderWidth() {
    var element = this.table.rowManager.tableElement,
        onlyGroupHeaders = true;
    this.table.rowManager.getDisplayRows().forEach((row, index) => {
      this.table.rowManager.styleRow(row, index);
      element.appendChild(row.getElement());
      row.initialize(true);

      if (row.type !== "group") {
        onlyGroupHeaders = false;
      }
    });

    if (onlyGroupHeaders) {
      element.style.minWidth = this.table.columnManager.getWidth() + "px";
    } else {
      element.style.minWidth = "";
    }
  }

}

exports.GroupRowsModule = GroupRows;
GroupRows.moduleName = "groupRows";
var defaultUndoers = {
  cellEdit: function (action) {
    action.component.setValueProcessData(action.data.oldValue);
    action.component.cellRendered();
  },
  rowAdd: function (action) {
    action.component.deleteActual();
  },
  rowDelete: function (action) {
    var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);

    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      this.table.modules.groupRows.updateGroupRows(true);
    }

    this._rebindRow(action.component, newRow);
  },
  rowMove: function (action) {
    this.table.rowManager.moveRowActual(action.component, this.table.rowManager.rows[action.data.posFrom], !action.data.after);
    this.table.rowManager.redraw();
  }
};
var defaultRedoers = {
  cellEdit: function (action) {
    action.component.setValueProcessData(action.data.newValue);
    action.component.cellRendered();
  },
  rowAdd: function (action) {
    var newRow = this.table.rowManager.addRowActual(action.data.data, action.data.pos, action.data.index);

    if (this.table.options.groupBy && this.table.modExists("groupRows")) {
      this.table.modules.groupRows.updateGroupRows(true);
    }

    this._rebindRow(action.component, newRow);
  },
  rowDelete: function (action) {
    action.component.deleteActual();
  },
  rowMove: function (action) {
    this.table.rowManager.moveRowActual(action.component, this.table.rowManager.rows[action.data.posTo], action.data.after);
    this.table.rowManager.redraw();
  }
};

class History extends Module {
  constructor(table) {
    super(table);
    this.history = [];
    this.index = -1;
    this.registerTableOption("history", false); //enable edit history
  }

  initialize() {
    if (this.table.options.history) {
      this.subscribe("cell-value-updated", this.cellUpdated.bind(this));
      this.subscribe("cell-delete", this.clearComponentHistory.bind(this));
      this.subscribe("row-delete", this.rowDeleted.bind(this));
      this.subscribe("rows-wipe", this.clear.bind(this));
      this.subscribe("row-added", this.rowAdded.bind(this));
      this.subscribe("row-move", this.rowMoved.bind(this));
    }

    this.registerTableFunction("undo", this.undo.bind(this));
    this.registerTableFunction("redo", this.redo.bind(this));
    this.registerTableFunction("getHistoryUndoSize", this.getHistoryUndoSize.bind(this));
    this.registerTableFunction("getHistoryRedoSize", this.getHistoryRedoSize.bind(this));
    this.registerTableFunction("clearHistory", this.clear.bind(this));
  }

  rowMoved(from, to, after) {
    this.action("rowMove", from, {
      posFrom: from.getPosition(),
      posTo: to.getPosition(),
      to: to,
      after: after
    });
  }

  rowAdded(row, data, pos, index) {
    this.action("rowAdd", row, {
      data: data,
      pos: pos,
      index: index
    });
  }

  rowDeleted(row) {
    var index, rows;

    if (this.table.options.groupBy) {
      rows = row.getComponent().getGroup()._getSelf().rows;
      index = rows.indexOf(row);

      if (index) {
        index = rows[index - 1];
      }
    } else {
      index = row.table.rowManager.getRowIndex(row);

      if (index) {
        index = row.table.rowManager.rows[index - 1];
      }
    }

    this.action("rowDelete", row, {
      data: row.getData(),
      pos: !index,
      index: index
    });
  }

  cellUpdated(cell) {
    this.action("cellEdit", cell, {
      oldValue: cell.oldValue,
      newValue: cell.value
    });
  }

  clear() {
    this.history = [];
    this.index = -1;
  }

  action(type, component, data) {
    this.history = this.history.slice(0, this.index + 1);
    this.history.push({
      type: type,
      component: component,
      data: data
    });
    this.index++;
  }

  getHistoryUndoSize() {
    return this.index + 1;
  }

  getHistoryRedoSize() {
    return this.history.length - (this.index + 1);
  }

  clearComponentHistory(component) {
    var index = this.history.findIndex(function (item) {
      return item.component === component;
    });

    if (index > -1) {
      this.history.splice(index, 1);

      if (index <= this.index) {
        this.index--;
      }

      this.clearComponentHistory(component);
    }
  }

  undo() {
    if (this.index > -1) {
      let action = this.history[this.index];
      History.undoers[action.type].call(this, action);
      this.index--;
      this.dispatchExternal("historyUndo", action.type, action.component.getComponent(), action.data);
      return true;
    } else {
      console.warn("History Undo Error - No more history to undo");
      return false;
    }
  }

  redo() {
    if (this.history.length - 1 > this.index) {
      this.index++;
      let action = this.history[this.index];
      History.redoers[action.type].call(this, action);
      this.dispatchExternal("historyRedo", action.type, action.component.getComponent(), action.data);
      return true;
    } else {
      console.warn("History Redo Error - No more history to redo");
      return false;
    }
  } //rebind rows to new element after deletion


  _rebindRow(oldRow, newRow) {
    this.history.forEach(function (action) {
      if (action.component instanceof Row) {
        if (action.component === oldRow) {
          action.component = newRow;
        }
      } else if (action.component instanceof Cell) {
        if (action.component.row === oldRow) {
          var field = action.component.column.getField();

          if (field) {
            action.component = newRow.getCell(field);
          }
        }
      }
    });
  }

}

exports.HistoryModule = History;
History.moduleName = "history"; //load defaults

History.undoers = defaultUndoers;
History.redoers = defaultRedoers;

class HtmlTableImport extends Module {
  constructor(table) {
    super(table);
    this.fieldIndex = [];
    this.hasIndex = false;
  }

  initialize() {
    this.tableElementCheck();
  }

  tableElementCheck() {
    if (this.table.originalElement && this.table.originalElement.tagName === "TABLE") {
      if (this.table.originalElement.childNodes.length) {
        this.parseTable();
      } else {
        console.warn("Unable to parse data from empty table tag, Tabulator should be initialized on a div tag unless importing data from a table element.");
      }
    }
  }

  parseTable() {
    var element = this.table.originalElement,
        options = this.table.options,
        headers = element.getElementsByTagName("th"),
        rows = element.getElementsByTagName("tbody")[0],
        data = [];
    this.hasIndex = false;
    this.dispatchExternal("htmlImporting");
    rows = rows ? rows.getElementsByTagName("tr") : []; //check for Tabulator inline options

    this._extractOptions(element, options);

    if (headers.length) {
      this._extractHeaders(headers, rows);
    } else {
      this._generateBlankHeaders(headers, rows);
    } //iterate through table rows and build data set


    for (var index = 0; index < rows.length; index++) {
      var row = rows[index],
          cells = row.getElementsByTagName("td"),
          item = {}; //create index if the don't exist in table

      if (!this.hasIndex) {
        item[options.index] = index;
      }

      for (var i = 0; i < cells.length; i++) {
        var cell = cells[i];

        if (typeof this.fieldIndex[i] !== "undefined") {
          item[this.fieldIndex[i]] = cell.innerHTML;
        }
      } //add row data to item


      data.push(item);
    }

    options.data = data;
    this.dispatchExternal("htmlImported");
  } //extract tabulator attribute options


  _extractOptions(element, options, defaultOptions) {
    var attributes = element.attributes;
    var optionsArr = defaultOptions ? Object.keys(defaultOptions) : Object.keys(options);
    var optionsList = {};
    optionsArr.forEach(item => {
      optionsList[item.toLowerCase()] = item;
    });

    for (var index in attributes) {
      var attrib = attributes[index];
      var name;

      if (attrib && typeof attrib == "object" && attrib.name && attrib.name.indexOf("tabulator-") === 0) {
        name = attrib.name.replace("tabulator-", "");

        if (typeof optionsList[name] !== "undefined") {
          options[optionsList[name]] = this._attribValue(attrib.value);
        }
      }
    }
  } //get value of attribute


  _attribValue(value) {
    if (value === "true") {
      return true;
    }

    if (value === "false") {
      return false;
    }

    return value;
  } //find column if it has already been defined


  _findCol(title) {
    var match = this.table.options.columns.find(column => {
      return column.title === title;
    });
    return match || false;
  } //extract column from headers


  _extractHeaders(headers, rows) {
    for (var index = 0; index < headers.length; index++) {
      var header = headers[index],
          exists = false,
          col = this._findCol(header.textContent),
          width;

      if (col) {
        exists = true;
      } else {
        col = {
          title: header.textContent.trim()
        };
      }

      if (!col.field) {
        col.field = header.textContent.trim().toLowerCase().replace(" ", "_");
      }

      width = header.getAttribute("width");

      if (width && !col.width) {
        col.width = width;
      } //check for Tabulator inline options


      this._extractOptions(header, col, this.table.columnManager.optionsList.registeredDefaults);

      this.fieldIndex[index] = col.field;

      if (col.field == this.table.options.index) {
        this.hasIndex = true;
      }

      if (!exists) {
        this.table.options.columns.push(col);
      }
    }
  } //generate blank headers


  _generateBlankHeaders(headers, rows) {
    for (var index = 0; index < headers.length; index++) {
      var header = headers[index],
          col = {
        title: "",
        field: "col" + index
      };
      this.fieldIndex[index] = col.field;
      var width = header.getAttribute("width");

      if (width) {
        col.width = width;
      }

      this.table.options.columns.push(col);
    }
  }

}

exports.HtmlTableImportModule = HtmlTableImport;
HtmlTableImport.moduleName = "htmlTableImport";

function csvImporter(input) {
  var data = [],
      row = 0,
      col = 0,
      inQuote = false; //Iterate over each character

  for (let index = 0; index < input.length; index++) {
    let char = input[index],
        nextChar = input[index + 1]; //Initialize empty row

    if (!data[row]) {
      data[row] = [];
    } //Initialize empty column


    if (!data[row][col]) {
      data[row][col] = "";
    } //Handle quotation mark inside string


    if (char == '"' && inQuote && nextChar == '"') {
      data[row][col] += char;
      index++;
      continue;
    } //Begin / End Quote


    if (char == '"') {
      inQuote = !inQuote;
      continue;
    } //Next column (if not in quote)


    if (char == ',' && !inQuote) {
      col++;
      continue;
    } //New row if new line and not in quote (CRLF) 


    if (char == '\r' && nextChar == '\n' && !inQuote) {
      col = 0;
      row++;
      index++;
      continue;
    } //New row if new line and not in quote (CR or LF) 


    if ((char == '\r' || char == '\n') && !inQuote) {
      col = 0;
      row++;
      continue;
    } //Normal Character, append to column


    data[row][col] += char;
  }

  return data;
}

function json$1(input) {
  try {
    return JSON.parse(input);
  } catch (e) {
    console.warn("JSON Import Error - File contents is invalid JSON", e);
    return Promise.reject();
  }
}

function arrayImporter(input) {
  return input;
}

var defaultImporters = {
  csv: csvImporter,
  json: json$1,
  array: arrayImporter
};

class Import extends Module {
  constructor(table) {
    super(table);
    this.registerTableOption("importFormat");
    this.registerTableOption("importReader", "text");
  }

  initialize() {
    this.registerTableFunction("import", this.importFromFile.bind(this));

    if (this.table.options.importFormat) {
      this.subscribe("data-loading", this.loadDataCheck.bind(this), 10);
      this.subscribe("data-load", this.loadData.bind(this), 10);
    }
  }

  loadDataCheck(data) {
    return this.table.options.importFormat && (typeof data === "string" || Array.isArray(data) && data.length && Array.isArray(data));
  }

  loadData(data, params, config, silent, previousData) {
    return this.importData(this.lookupImporter(), data).then(this.structureData.bind(this)).catch(err => {
      console.error("Import Error:", err || "Unable to import data");
      return Promise.reject(err);
    });
  }

  lookupImporter(importFormat) {
    var importer;

    if (!importFormat) {
      importFormat = this.table.options.importFormat;
    }

    if (typeof importFormat === "string") {
      importer = Import.importers[importFormat];
    } else {
      importer = importFormat;
    }

    if (!importer) {
      console.error("Import Error - Importer not found:", importFormat);
    }

    return importer;
  }

  importFromFile(importFormat, extension) {
    var importer = this.lookupImporter(importFormat);

    if (importer) {
      return this.pickFile(extension).then(this.importData.bind(this, importer)).then(this.structureData.bind(this)).then(this.setData.bind(this)).catch(err => {
        console.error("Import Error:", err || "Unable to import file");
        return Promise.reject(err);
      });
    }
  }

  pickFile(extensions) {
    return new Promise((resolve, reject) => {
      var input = document.createElement("input");
      input.type = "file";
      input.accept = extensions;
      input.addEventListener("change", e => {
        var file = input.files[0],
            reader = new FileReader();

        switch (this.table.options.importReader) {
          case "buffer":
            reader.readAsArrayBuffer(file);
            break;

          case "binary":
            reader.readAsBinaryString(file);
            break;

          case "url":
            reader.readAsDataURL(file);
            break;

          case "text":
          default:
            reader.readAsText(file);
        }

        reader.onload = e => {
          resolve(reader.result);
        };

        reader.onerror = e => {
          console.warn("File Load Error - Unable to read file");
          reject();
        };
      });
      input.click();
    });
  }

  importData(importer, fileContents) {
    var data = importer.call(this.table, fileContents);

    if (data instanceof Promise) {
      return data;
    } else {
      return data ? Promise.resolve(data) : Promise.reject();
    }
  }

  structureData(parsedData) {
    var data = [];

    if (Array.isArray(parsedData) && parsedData.length && Array.isArray(parsedData[0])) {
      if (this.table.options.autoColumns) {
        data = this.structureArrayToObject(parsedData);
      } else {
        data = this.structureArrayToColumns(parsedData);
      }

      return data;
    } else {
      return parsedData;
    }
  }

  structureArrayToObject(parsedData) {
    var columns = parsedData.shift();
    var data = parsedData.map(values => {
      var row = {};
      columns.forEach((key, i) => {
        row[key] = values[i];
      });
      return row;
    });
    return data;
  }

  structureArrayToColumns(parsedData) {
    var data = [],
        columns = this.table.getColumns(); //remove first row if it is the column names

    if (columns[0] && parsedData[0][0]) {
      if (columns[0].getDefinition().title === parsedData[0][0]) {
        parsedData.shift();
      }
    } //convert row arrays to objects


    parsedData.forEach(rowData => {
      var row = {};
      rowData.forEach((value, index) => {
        var column = columns[index];

        if (column) {
          row[column.getField()] = value;
        }
      });
      data.push(row);
    });
    return data;
  }

  setData(data) {
    return this.table.setData(data);
  }

}

exports.ImportModule = Import;
Import.moduleName = "import"; //load defaults

Import.importers = defaultImporters;

class Interaction extends Module {
  constructor(table) {
    super(table);
    this.eventMap = {
      //row events
      rowClick: "row-click",
      rowDblClick: "row-dblclick",
      rowContext: "row-contextmenu",
      rowMouseEnter: "row-mouseenter",
      rowMouseLeave: "row-mouseleave",
      rowMouseOver: "row-mouseover",
      rowMouseOut: "row-mouseout",
      rowMouseMove: "row-mousemove",
      rowTap: "row",
      rowDblTap: "row",
      rowTapHold: "row",
      //cell events
      cellClick: "cell-click",
      cellDblClick: "cell-dblclick",
      cellContext: "cell-contextmenu",
      cellMouseEnter: "cell-mouseenter",
      cellMouseLeave: "cell-mouseleave",
      cellMouseOver: "cell-mouseover",
      cellMouseOut: "cell-mouseout",
      cellMouseMove: "cell-mousemove",
      cellTap: "cell",
      cellDblTap: "cell",
      cellTapHold: "cell",
      //column header events
      headerClick: "column-click",
      headerDblClick: "column-dblclick",
      headerContext: "column-contextmenu",
      headerMouseEnter: "column-mouseenter",
      headerMouseLeave: "column-mouseleave",
      headerMouseOver: "column-mouseover",
      headerMouseOut: "column-mouseout",
      headerMouseMove: "column-mousemove",
      headerTap: "column",
      headerDblTap: "column",
      headerTapHold: "column",
      //group header
      groupClick: "group-click",
      groupDblClick: "group-dblclick",
      groupContext: "group-contextmenu",
      groupMouseEnter: "group-mouseenter",
      groupMouseLeave: "group-mouseleave",
      groupMouseOver: "group-mouseover",
      groupMouseOut: "group-mouseout",
      groupMouseMove: "group-mousemove",
      groupTap: "group",
      groupDblTap: "group",
      groupTapHold: "group"
    };
    this.subscribers = {};
    this.touchSubscribers = {};
    this.columnSubscribers = {};
    this.touchWatchers = {
      row: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      cell: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      column: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      group: {
        tap: null,
        tapDbl: null,
        tapHold: null
      }
    };
    this.registerColumnOption("headerClick");
    this.registerColumnOption("headerDblClick");
    this.registerColumnOption("headerContext");
    this.registerColumnOption("headerMouseEnter");
    this.registerColumnOption("headerMouseLeave");
    this.registerColumnOption("headerMouseOver");
    this.registerColumnOption("headerMouseOut");
    this.registerColumnOption("headerMouseMove");
    this.registerColumnOption("headerTap");
    this.registerColumnOption("headerDblTap");
    this.registerColumnOption("headerTapHold");
    this.registerColumnOption("cellClick");
    this.registerColumnOption("cellDblClick");
    this.registerColumnOption("cellContext");
    this.registerColumnOption("cellMouseEnter");
    this.registerColumnOption("cellMouseLeave");
    this.registerColumnOption("cellMouseOver");
    this.registerColumnOption("cellMouseOut");
    this.registerColumnOption("cellMouseMove");
    this.registerColumnOption("cellTap");
    this.registerColumnOption("cellDblTap");
    this.registerColumnOption("cellTapHold");
  }

  initialize() {
    this.initializeExternalEvents();
    this.subscribe("column-init", this.initializeColumn.bind(this));
    this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this));
  }

  cellContentsSelectionFixer(e, cell) {
    var range;

    if (this.table.modExists("edit")) {
      if (this.table.modules.edit.currentCell === this) {
        return; //prevent instant selection of editor content
      }
    }

    e.preventDefault();

    try {
      if (document.selection) {
        // IE
        range = document.body.createTextRange();
        range.moveToElementText(cell.getElement());
        range.select();
      } else if (window.getSelection) {
        range = document.createRange();
        range.selectNode(cell.getElement());
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
      }
    } catch (e) {}
  }

  initializeExternalEvents() {
    for (let key in this.eventMap) {
      this.subscriptionChangeExternal(key, this.subscriptionChanged.bind(this, key));
    }
  }

  subscriptionChanged(key, added) {
    if (added) {
      if (!this.subscribers[key]) {
        if (this.eventMap[key].includes("-")) {
          this.subscribers[key] = this.handle.bind(this, key);
          this.subscribe(this.eventMap[key], this.subscribers[key]);
        } else {
          this.subscribeTouchEvents(key);
        }
      }
    } else {
      if (this.eventMap[key].includes("-")) {
        if (this.subscribers[key] && !this.columnSubscribers[key] && !this.subscribedExternal(key)) {
          this.unsubscribe(this.eventMap[key], this.subscribers[key]);
          delete this.subscribers[key];
        }
      } else {
        this.unsubscribeTouchEvents(key);
      }
    }
  }

  subscribeTouchEvents(key) {
    var type = this.eventMap[key];

    if (!this.touchSubscribers[type + "-touchstart"]) {
      this.touchSubscribers[type + "-touchstart"] = this.handleTouch.bind(this, type, "start");
      this.touchSubscribers[type + "-touchend"] = this.handleTouch.bind(this, type, "end");
      this.subscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
      this.subscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
    }

    this.subscribers[key] = true;
  }

  unsubscribeTouchEvents(key) {
    var noTouch = true,
        type = this.eventMap[key];

    if (this.subscribers[key] && !this.subscribedExternal(key)) {
      delete this.subscribers[key];

      for (let i in this.eventMap) {
        if (this.eventMap[i] === type) {
          if (this.subscribers[i]) {
            noTouch = false;
          }
        }
      }

      if (noTouch) {
        this.unsubscribe(type + "-touchstart", this.touchSubscribers[type + "-touchstart"]);
        this.unsubscribe(type + "-touchend", this.touchSubscribers[type + "-touchend"]);
        delete this.touchSubscribers[type + "-touchstart"];
        delete this.touchSubscribers[type + "-touchend"];
      }
    }
  }

  initializeColumn(column) {
    var def = column.definition;

    for (let key in this.eventMap) {
      if (def[key]) {
        this.subscriptionChanged(key, true);

        if (!this.columnSubscribers[key]) {
          this.columnSubscribers[key] = [];
        }

        this.columnSubscribers[key].push(column);
      }
    }
  }

  handle(action, e, component) {
    this.dispatchEvent(action, e, component);
  }

  handleTouch(type, action, e, component) {
    var watchers = this.touchWatchers[type];

    if (type === "column") {
      type = "header";
    }

    switch (action) {
      case "start":
        watchers.tap = true;
        clearTimeout(watchers.tapHold);
        watchers.tapHold = setTimeout(() => {
          clearTimeout(watchers.tapHold);
          watchers.tapHold = null;
          watchers.tap = null;
          clearTimeout(watchers.tapDbl);
          watchers.tapDbl = null;
          this.dispatchEvent(type + "TapHold", e, component);
        }, 1000);
        break;

      case "end":
        if (watchers.tap) {
          watchers.tap = null;
          this.dispatchEvent(type + "Tap", e, component);
        }

        if (watchers.tapDbl) {
          clearTimeout(watchers.tapDbl);
          watchers.tapDbl = null;
          this.dispatchEvent(type + "DblTap", e, component);
        } else {
          watchers.tapDbl = setTimeout(() => {
            clearTimeout(watchers.tapDbl);
            watchers.tapDbl = null;
          }, 300);
        }

        clearTimeout(watchers.tapHold);
        watchers.tapHold = null;
        break;
    }
  }

  dispatchEvent(action, e, component) {
    var componentObj = component.getComponent(),
        callback;

    if (this.columnSubscribers[action]) {
      if (component instanceof Cell) {
        callback = component.column.definition[action];
      } else if (component instanceof Column) {
        callback = component.definition[action];
      }

      if (callback) {
        callback(e, componentObj);
      }
    }

    this.dispatchExternal(action, e, componentObj);
  }

}

exports.InteractionModule = Interaction;
Interaction.moduleName = "interaction";
var defaultBindings = {
  navPrev: "shift + 9",
  navNext: 9,
  navUp: 38,
  navDown: 40,
  scrollPageUp: 33,
  scrollPageDown: 34,
  scrollToStart: 36,
  scrollToEnd: 35,
  undo: ["ctrl + 90", "meta + 90"],
  redo: ["ctrl + 89", "meta + 89"],
  copyToClipboard: ["ctrl + 67", "meta + 89"]
};
var defaultActions = {
  keyBlock: function (e) {
    e.stopPropagation();
    e.preventDefault();
  },
  scrollPageUp: function (e) {
    var rowManager = this.table.rowManager,
        newPos = rowManager.scrollTop - rowManager.element.clientHeight;
    e.preventDefault();

    if (rowManager.displayRowsCount) {
      if (newPos >= 0) {
        rowManager.element.scrollTop = newPos;
      } else {
        rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
      }
    }

    this.table.element.focus();
  },
  scrollPageDown: function (e) {
    var rowManager = this.table.rowManager,
        newPos = rowManager.scrollTop + rowManager.element.clientHeight,
        scrollMax = rowManager.element.scrollHeight;
    e.preventDefault();

    if (rowManager.displayRowsCount) {
      if (newPos <= scrollMax) {
        rowManager.element.scrollTop = newPos;
      } else {
        rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
      }
    }

    this.table.element.focus();
  },
  scrollToStart: function (e) {
    var rowManager = this.table.rowManager;
    e.preventDefault();

    if (rowManager.displayRowsCount) {
      rowManager.scrollToRow(rowManager.getDisplayRows()[0]);
    }

    this.table.element.focus();
  },
  scrollToEnd: function (e) {
    var rowManager = this.table.rowManager;
    e.preventDefault();

    if (rowManager.displayRowsCount) {
      rowManager.scrollToRow(rowManager.getDisplayRows()[rowManager.displayRowsCount - 1]);
    }

    this.table.element.focus();
  },
  navPrev: function (e) {
    this.dispatch("keybinding-nav-prev", e);
  },
  navNext: function (e) {
    this.dispatch("keybinding-nav-next", e);
  },
  navLeft: function (e) {
    this.dispatch("keybinding-nav-left", e);
  },
  navRight: function (e) {
    this.dispatch("keybinding-nav-right", e);
  },
  navUp: function (e) {
    this.dispatch("keybinding-nav-up", e);
  },
  navDown: function (e) {
    this.dispatch("keybinding-nav-down", e);
  },
  undo: function (e) {
    var cell = false;

    if (this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")) {
      cell = this.table.modules.edit.currentCell;

      if (!cell) {
        e.preventDefault();
        this.table.modules.history.undo();
      }
    }
  },
  redo: function (e) {
    var cell = false;

    if (this.table.options.history && this.table.modExists("history") && this.table.modExists("edit")) {
      cell = this.table.modules.edit.currentCell;

      if (!cell) {
        e.preventDefault();
        this.table.modules.history.redo();
      }
    }
  },
  copyToClipboard: function (e) {
    if (!this.table.modules.edit.currentCell) {
      if (this.table.modExists("clipboard", true)) {
        this.table.modules.clipboard.copy(false, true);
      }
    }
  }
};

class Keybindings extends Module {
  constructor(table) {
    super(table);
    this.watchKeys = null;
    this.pressedKeys = null;
    this.keyupBinding = false;
    this.keydownBinding = false;
    this.registerTableOption("keybindings", {}); //array for keybindings

    this.registerTableOption("tabEndNewRow", false); //create new row when tab to end of table
  }

  initialize() {
    var bindings = this.table.options.keybindings,
        mergedBindings = {};
    this.watchKeys = {};
    this.pressedKeys = [];

    if (bindings !== false) {
      Object.assign(mergedBindings, Keybindings.bindings);
      Object.assign(mergedBindings, bindings);
      this.mapBindings(mergedBindings);
      this.bindEvents();
    }

    this.subscribe("table-destroy", this.clearBindings.bind(this));
  }

  mapBindings(bindings) {
    for (let key in bindings) {
      if (Keybindings.actions[key]) {
        if (bindings[key]) {
          if (typeof bindings[key] !== "object") {
            bindings[key] = [bindings[key]];
          }

          bindings[key].forEach(binding => {
            var bindingList = Array.isArray(binding) ? binding : [binding];
            bindingList.forEach(item => {
              this.mapBinding(key, item);
            });
          });
        }
      } else {
        console.warn("Key Binding Error - no such action:", key);
      }
    }
  }

  mapBinding(action, symbolsList) {
    var binding = {
      action: Keybindings.actions[action],
      keys: [],
      ctrl: false,
      shift: false,
      meta: false
    };
    var symbols = symbolsList.toString().toLowerCase().split(" ").join("").split("+");
    symbols.forEach(symbol => {
      switch (symbol) {
        case "ctrl":
          binding.ctrl = true;
          break;

        case "shift":
          binding.shift = true;
          break;

        case "meta":
          binding.meta = true;
          break;

        default:
          symbol = isNaN(symbol) ? symbol.toUpperCase().charCodeAt(0) : parseInt(symbol);
          binding.keys.push(symbol);

          if (!this.watchKeys[symbol]) {
            this.watchKeys[symbol] = [];
          }

          this.watchKeys[symbol].push(binding);
      }
    });
  }

  bindEvents() {
    var self = this;

    this.keyupBinding = function (e) {
      var code = e.keyCode;
      var bindings = self.watchKeys[code];

      if (bindings) {
        self.pressedKeys.push(code);
        bindings.forEach(function (binding) {
          self.checkBinding(e, binding);
        });
      }
    };

    this.keydownBinding = function (e) {
      var code = e.keyCode;
      var bindings = self.watchKeys[code];

      if (bindings) {
        var index = self.pressedKeys.indexOf(code);

        if (index > -1) {
          self.pressedKeys.splice(index, 1);
        }
      }
    };

    this.table.element.addEventListener("keydown", this.keyupBinding);
    this.table.element.addEventListener("keyup", this.keydownBinding);
  }

  clearBindings() {
    if (this.keyupBinding) {
      this.table.element.removeEventListener("keydown", this.keyupBinding);
    }

    if (this.keydownBinding) {
      this.table.element.removeEventListener("keyup", this.keydownBinding);
    }
  }

  checkBinding(e, binding) {
    var match = true;

    if (e.ctrlKey == binding.ctrl && e.shiftKey == binding.shift && e.metaKey == binding.meta) {
      binding.keys.forEach(key => {
        var index = this.pressedKeys.indexOf(key);

        if (index == -1) {
          match = false;
        }
      });

      if (match) {
        binding.action.call(this, e);
      }

      return true;
    }

    return false;
  }

}

exports.KeybindingsModule = Keybindings;
Keybindings.moduleName = "keybindings"; //load defaults

Keybindings.bindings = defaultBindings;
Keybindings.actions = defaultActions;

class Menu extends Module {
  constructor(table) {
    super(table);
    this.menuContainer = null;
    this.nestedMenuBlock = false;
    this.currentComponent = null;
    this.rootPopup = null;
    this.columnSubscribers = {};
    this.registerTableOption("menuContainer", undefined); //deprecated

    this.registerTableOption("rowContextMenu", false);
    this.registerTableOption("rowClickMenu", false);
    this.registerTableOption("groupContextMenu", false);
    this.registerTableOption("groupClickMenu", false);
    this.registerColumnOption("headerContextMenu");
    this.registerColumnOption("headerClickMenu");
    this.registerColumnOption("headerMenu");
    this.registerColumnOption("headerMenuIcon");
    this.registerColumnOption("contextMenu");
    this.registerColumnOption("clickMenu");
  }

  initialize() {
    this.deprecatedOptionsCheck();
    this.initializeRowWatchers();
    this.initializeGroupWatchers();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }

  deprecatedOptionsCheck() {
    if (!this.deprecationCheck("menuContainer", "popupContainer")) {
      this.table.options.popupContainer = this.table.options.menuContainer;
    }
  }

  initializeRowWatchers() {
    if (this.table.options.rowContextMenu) {
      this.subscribe("row-contextmenu", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu));
      this.table.on("rowTapHold", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu));
    }

    if (this.table.options.rowClickMenu) {
      this.subscribe("row-click", this.loadMenuEvent.bind(this, this.table.options.rowClickMenu));
    }
  }

  initializeGroupWatchers() {
    if (this.table.options.groupContextMenu) {
      this.subscribe("group-contextmenu", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu));
      this.table.on("groupTapHold", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu));
    }

    if (this.table.options.groupClickMenu) {
      this.subscribe("group-click", this.loadMenuEvent.bind(this, this.table.options.groupClickMenu));
    }
  }

  initializeColumn(column) {
    var def = column.definition; //handle column events

    if (def.headerContextMenu && !this.columnSubscribers.headerContextMenu) {
      this.columnSubscribers.headerContextMenu = this.loadMenuTableColumnEvent.bind(this, "headerContextMenu");
      this.subscribe("column-contextmenu", this.columnSubscribers.headerContextMenu);
      this.table.on("headerTapHold", this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"));
    }

    if (def.headerClickMenu && !this.columnSubscribers.headerClickMenu) {
      this.columnSubscribers.headerClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerClickMenu");
      this.subscribe("column-click", this.columnSubscribers.headerClickMenu);
    }

    if (def.headerMenu) {
      this.initializeColumnHeaderMenu(column);
    } //handle cell events


    if (def.contextMenu && !this.columnSubscribers.contextMenu) {
      this.columnSubscribers.contextMenu = this.loadMenuTableCellEvent.bind(this, "contextMenu");
      this.subscribe("cell-contextmenu", this.columnSubscribers.contextMenu);
      this.table.on("cellTapHold", this.loadMenuTableCellEvent.bind(this, "contextMenu"));
    }

    if (def.clickMenu && !this.columnSubscribers.clickMenu) {
      this.columnSubscribers.clickMenu = this.loadMenuTableCellEvent.bind(this, "clickMenu");
      this.subscribe("cell-click", this.columnSubscribers.clickMenu);
    }
  }

  initializeColumnHeaderMenu(column) {
    var icon = column.definition.headerMenuIcon,
        headerMenuEl;
    headerMenuEl = document.createElement("span");
    headerMenuEl.classList.add("tabulator-header-popup-button");

    if (icon) {
      if (typeof icon === "function") {
        icon = icon(column.getComponent());
      }

      if (icon instanceof HTMLElement) {
        headerMenuEl.appendChild(icon);
      } else {
        headerMenuEl.innerHTML = icon;
      }
    } else {
      headerMenuEl.innerHTML = "&vellip;";
    }

    headerMenuEl.addEventListener("click", e => {
      e.stopPropagation();
      e.preventDefault();
      this.loadMenuEvent(column.definition.headerMenu, e, column);
    });
    column.titleElement.insertBefore(headerMenuEl, column.titleElement.firstChild);
  }

  loadMenuTableCellEvent(option, e, cell) {
    if (cell._cell) {
      cell = cell._cell;
    }

    if (cell.column.definition[option]) {
      this.loadMenuEvent(cell.column.definition[option], e, cell);
    }
  }

  loadMenuTableColumnEvent(option, e, column) {
    if (column._column) {
      column = column._column;
    }

    if (column.definition[option]) {
      this.loadMenuEvent(column.definition[option], e, column);
    }
  }

  loadMenuEvent(menu, e, component) {
    if (component._group) {
      component = component._group;
    } else if (component._row) {
      component = component._row;
    }

    menu = typeof menu == "function" ? menu.call(this.table, e, component.getComponent()) : menu;
    this.loadMenu(e, component, menu);
  }

  loadMenu(e, component, menu, parentEl, parentPopup) {
    var touch = !(e instanceof MouseEvent),
        menuEl = document.createElement("div"),
        popup;
    menuEl.classList.add("tabulator-menu");

    if (!touch) {
      e.preventDefault();
    } //abort if no menu set


    if (!menu || !menu.length) {
      return;
    }

    if (!parentEl) {
      if (this.nestedMenuBlock) {
        //abort if child menu already open
        if (this.rootPopup) {
          return;
        }
      } else {
        this.nestedMenuBlock = setTimeout(() => {
          this.nestedMenuBlock = false;
        }, 100);
      }

      if (this.rootPopup) {
        this.rootPopup.hide();
      }

      this.rootPopup = popup = this.popup(menuEl);
    } else {
      popup = parentPopup.child(menuEl);
    }

    menu.forEach(item => {
      var itemEl = document.createElement("div"),
          label = item.label,
          disabled = item.disabled;

      if (item.separator) {
        itemEl.classList.add("tabulator-menu-separator");
      } else {
        itemEl.classList.add("tabulator-menu-item");

        if (typeof label == "function") {
          label = label.call(this.table, component.getComponent());
        }

        if (label instanceof Node) {
          itemEl.appendChild(label);
        } else {
          itemEl.innerHTML = label;
        }

        if (typeof disabled == "function") {
          disabled = disabled.call(this.table, component.getComponent());
        }

        if (disabled) {
          itemEl.classList.add("tabulator-menu-item-disabled");
          itemEl.addEventListener("click", e => {
            e.stopPropagation();
          });
        } else {
          if (item.menu && item.menu.length) {
            itemEl.addEventListener("click", e => {
              e.stopPropagation();
              this.loadMenu(e, component, item.menu, itemEl, popup);
            });
          } else {
            if (item.action) {
              itemEl.addEventListener("click", e => {
                item.action(e, component.getComponent());
              });
            }
          }
        }

        if (item.menu && item.menu.length) {
          itemEl.classList.add("tabulator-menu-item-submenu");
        }
      }

      menuEl.appendChild(itemEl);
    });
    menuEl.addEventListener("click", e => {
      this.rootPopup.hide();
    });
    popup.show(parentEl || e);

    if (popup === this.rootPopup) {
      this.rootPopup.hideOnBlur(() => {
        this.rootPopup = null;

        if (this.currentComponent) {
          this.dispatchExternal("menuClosed", this.currentComponent.getComponent());
          this.currentComponent = null;
        }
      });
      this.currentComponent = component;
      this.dispatchExternal("menuOpened", component.getComponent());
    }
  }

}

exports.MenuModule = Menu;
Menu.moduleName = "menu";

class MoveColumns extends Module {
  constructor(table) {
    super(table);
    this.placeholderElement = this.createPlaceholderElement();
    this.hoverElement = false; //floating column header element

    this.checkTimeout = false; //click check timeout holder

    this.checkPeriod = 250; //period to wait on mousedown to consider this a move and not a click

    this.moving = false; //currently moving column

    this.toCol = false; //destination column

    this.toColAfter = false; //position of moving column relative to the destination column

    this.startX = 0; //starting position within header element

    this.autoScrollMargin = 40; //auto scroll on edge when within margin

    this.autoScrollStep = 5; //auto scroll distance in pixels

    this.autoScrollTimeout = false; //auto scroll timeout

    this.touchMove = false;
    this.moveHover = this.moveHover.bind(this);
    this.endMove = this.endMove.bind(this);
    this.registerTableOption("movableColumns", false); //enable movable columns
  }

  createPlaceholderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-col");
    el.classList.add("tabulator-col-placeholder");
    return el;
  }

  initialize() {
    if (this.table.options.movableColumns) {
      this.subscribe("column-init", this.initializeColumn.bind(this));
    }
  }

  initializeColumn(column) {
    var self = this,
        config = {},
        colEl;

    if (!column.modules.frozen && !column.isGroup) {
      colEl = column.getElement();

      config.mousemove = function (e) {
        if (column.parent === self.moving.parent) {
          if ((self.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(colEl).left + self.table.columnManager.element.scrollLeft > column.getWidth() / 2) {
            if (self.toCol !== column || !self.toColAfter) {
              colEl.parentNode.insertBefore(self.placeholderElement, colEl.nextSibling);
              self.moveColumn(column, true);
            }
          } else {
            if (self.toCol !== column || self.toColAfter) {
              colEl.parentNode.insertBefore(self.placeholderElement, colEl);
              self.moveColumn(column, false);
            }
          }
        }
      }.bind(self);

      colEl.addEventListener("mousedown", function (e) {
        self.touchMove = false;

        if (e.which === 1) {
          self.checkTimeout = setTimeout(function () {
            self.startMove(e, column);
          }, self.checkPeriod);
        }
      });
      colEl.addEventListener("mouseup", function (e) {
        if (e.which === 1) {
          if (self.checkTimeout) {
            clearTimeout(self.checkTimeout);
          }
        }
      });
      self.bindTouchEvents(column);
    }

    column.modules.moveColumn = config;
  }

  bindTouchEvents(column) {
    var colEl = column.getElement(),
        startXMove = false,
        //shifting center position of the cell
    nextCol,
        prevCol,
        nextColWidth,
        prevColWidth,
        nextColWidthLast,
        prevColWidthLast;
    colEl.addEventListener("touchstart", e => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = true;
        nextCol = column.nextColumn();
        nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
        prevCol = column.prevColumn();
        prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
        nextColWidthLast = 0;
        prevColWidthLast = 0;
        startXMove = false;
        this.startMove(e, column);
      }, this.checkPeriod);
    }, {
      passive: true
    });
    colEl.addEventListener("touchmove", e => {
      var diff, moveToCol;

      if (this.moving) {
        this.moveHover(e);

        if (!startXMove) {
          startXMove = e.touches[0].pageX;
        }

        diff = e.touches[0].pageX - startXMove;

        if (diff > 0) {
          if (nextCol && diff - nextColWidthLast > nextColWidth) {
            moveToCol = nextCol;

            if (moveToCol !== column) {
              startXMove = e.touches[0].pageX;
              moveToCol.getElement().parentNode.insertBefore(this.placeholderElement, moveToCol.getElement().nextSibling);
              this.moveColumn(moveToCol, true);
            }
          }
        } else {
          if (prevCol && -diff - prevColWidthLast > prevColWidth) {
            moveToCol = prevCol;

            if (moveToCol !== column) {
              startXMove = e.touches[0].pageX;
              moveToCol.getElement().parentNode.insertBefore(this.placeholderElement, moveToCol.getElement());
              this.moveColumn(moveToCol, false);
            }
          }
        }

        if (moveToCol) {
          nextCol = moveToCol.nextColumn();
          nextColWidthLast = nextColWidth;
          nextColWidth = nextCol ? nextCol.getWidth() / 2 : 0;
          prevCol = moveToCol.prevColumn();
          prevColWidthLast = prevColWidth;
          prevColWidth = prevCol ? prevCol.getWidth() / 2 : 0;
        }
      }
    }, {
      passive: true
    });
    colEl.addEventListener("touchend", e => {
      if (this.checkTimeout) {
        clearTimeout(this.checkTimeout);
      }

      if (this.moving) {
        this.endMove(e);
      }
    });
  }

  startMove(e, column) {
    var element = column.getElement(),
        headerElement = this.table.columnManager.getElement(),
        headersElement = this.table.columnManager.getHeadersElement();
    this.moving = column;
    this.startX = (this.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(element).left;
    this.table.element.classList.add("tabulator-block-select"); //create placeholder

    this.placeholderElement.style.width = column.getWidth() + "px";
    this.placeholderElement.style.height = column.getHeight() + "px";
    element.parentNode.insertBefore(this.placeholderElement, element);
    element.parentNode.removeChild(element); //create hover element

    this.hoverElement = element.cloneNode(true);
    this.hoverElement.classList.add("tabulator-moving");
    this.table.columnManager.getElement().appendChild(this.hoverElement);
    this.hoverElement.style.left = "0";
    this.hoverElement.style.bottom = headerElement.clientHeight - headersElement.offsetHeight + "px";

    if (!this.touchMove) {
      this._bindMouseMove();

      document.body.addEventListener("mousemove", this.moveHover);
      document.body.addEventListener("mouseup", this.endMove);
    }

    this.moveHover(e);
  }

  _bindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function (column) {
      if (column.modules.moveColumn.mousemove) {
        column.getElement().addEventListener("mousemove", column.modules.moveColumn.mousemove);
      }
    });
  }

  _unbindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function (column) {
      if (column.modules.moveColumn.mousemove) {
        column.getElement().removeEventListener("mousemove", column.modules.moveColumn.mousemove);
      }
    });
  }

  moveColumn(column, after) {
    var movingCells = this.moving.getCells();
    this.toCol = column;
    this.toColAfter = after;

    if (after) {
      column.getCells().forEach(function (cell, i) {
        var cellEl = cell.getElement(true);

        if (cellEl.parentNode && movingCells[i]) {
          cellEl.parentNode.insertBefore(movingCells[i].getElement(), cellEl.nextSibling);
        }
      });
    } else {
      column.getCells().forEach(function (cell, i) {
        var cellEl = cell.getElement(true);

        if (cellEl.parentNode && movingCells[i]) {
          cellEl.parentNode.insertBefore(movingCells[i].getElement(), cellEl);
        }
      });
    }
  }

  endMove(e) {
    if (e.which === 1 || this.touchMove) {
      this._unbindMouseMove();

      this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
      this.placeholderElement.parentNode.removeChild(this.placeholderElement);
      this.hoverElement.parentNode.removeChild(this.hoverElement);
      this.table.element.classList.remove("tabulator-block-select");

      if (this.toCol) {
        this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter);
      }

      this.moving = false;
      this.toCol = false;
      this.toColAfter = false;

      if (!this.touchMove) {
        document.body.removeEventListener("mousemove", this.moveHover);
        document.body.removeEventListener("mouseup", this.endMove);
      }
    }
  }

  moveHover(e) {
    var columnHolder = this.table.columnManager.getElement(),
        scrollLeft = columnHolder.scrollLeft,
        xPos = (this.touchMove ? e.touches[0].pageX : e.pageX) - Helpers.elOffset(columnHolder).left + scrollLeft,
        scrollPos;
    this.hoverElement.style.left = xPos - this.startX + "px";

    if (xPos - scrollLeft < this.autoScrollMargin) {
      if (!this.autoScrollTimeout) {
        this.autoScrollTimeout = setTimeout(() => {
          scrollPos = Math.max(0, scrollLeft - 5);
          this.table.rowManager.getElement().scrollLeft = scrollPos;
          this.autoScrollTimeout = false;
        }, 1);
      }
    }

    if (scrollLeft + columnHolder.clientWidth - xPos < this.autoScrollMargin) {
      if (!this.autoScrollTimeout) {
        this.autoScrollTimeout = setTimeout(() => {
          scrollPos = Math.min(columnHolder.clientWidth, scrollLeft + 5);
          this.table.rowManager.getElement().scrollLeft = scrollPos;
          this.autoScrollTimeout = false;
        }, 1);
      }
    }
  }

}

exports.MoveColumnsModule = MoveColumns;
MoveColumns.moduleName = "moveColumn";

class MoveRows extends Module {
  constructor(table) {
    super(table);
    this.placeholderElement = this.createPlaceholderElement();
    this.hoverElement = false; //floating row header element

    this.checkTimeout = false; //click check timeout holder

    this.checkPeriod = 150; //period to wait on mousedown to consider this a move and not a click

    this.moving = false; //currently moving row

    this.toRow = false; //destination row

    this.toRowAfter = false; //position of moving row relative to the destination row

    this.hasHandle = false; //row has handle instead of fully movable row

    this.startY = 0; //starting Y position within header element

    this.startX = 0; //starting X position within header element

    this.moveHover = this.moveHover.bind(this);
    this.endMove = this.endMove.bind(this);
    this.tableRowDropEvent = false;
    this.touchMove = false;
    this.connection = false;
    this.connectionSelectorsTables = false;
    this.connectionSelectorsElements = false;
    this.connectionElements = [];
    this.connections = [];
    this.connectedTable = false;
    this.connectedRow = false;
    this.registerTableOption("movableRows", false); //enable movable rows

    this.registerTableOption("movableRowsConnectedTables", false); //tables for movable rows to be connected to

    this.registerTableOption("movableRowsConnectedElements", false); //other elements for movable rows to be connected to

    this.registerTableOption("movableRowsSender", false);
    this.registerTableOption("movableRowsReceiver", "insert");
    this.registerColumnOption("rowHandle");
  }

  createPlaceholderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-row");
    el.classList.add("tabulator-row-placeholder");
    return el;
  }

  initialize() {
    if (this.table.options.movableRows) {
      this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables;
      this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements;
      this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements;
      this.subscribe("cell-init", this.initializeCell.bind(this));
      this.subscribe("column-init", this.initializeColumn.bind(this));
      this.subscribe("row-init", this.initializeRow.bind(this));
    }
  }

  initializeGroupHeader(group) {
    var self = this,
        config = {}; //inter table drag drop

    config.mouseup = function (e) {
      self.tableRowDrop(e, group);
    }.bind(self); //same table drag drop


    config.mousemove = function (e) {
      var rowEl;

      if (e.pageY - Helpers.elOffset(group.element).top + self.table.rowManager.element.scrollTop > group.getHeight() / 2) {
        if (self.toRow !== group || !self.toRowAfter) {
          rowEl = group.getElement();
          rowEl.parentNode.insertBefore(self.placeholderElement, rowEl.nextSibling);
          self.moveRow(group, true);
        }
      } else {
        if (self.toRow !== group || self.toRowAfter) {
          rowEl = group.getElement();

          if (rowEl.previousSibling) {
            rowEl.parentNode.insertBefore(self.placeholderElement, rowEl);
            self.moveRow(group, false);
          }
        }
      }
    }.bind(self);

    group.modules.moveRow = config;
  }

  initializeRow(row) {
    var self = this,
        config = {},
        rowEl; //inter table drag drop

    config.mouseup = function (e) {
      self.tableRowDrop(e, row);
    }.bind(self); //same table drag drop


    config.mousemove = function (e) {
      var rowEl = row.getElement();

      if (e.pageY - Helpers.elOffset(rowEl).top + self.table.rowManager.element.scrollTop > row.getHeight() / 2) {
        if (self.toRow !== row || !self.toRowAfter) {
          rowEl.parentNode.insertBefore(self.placeholderElement, rowEl.nextSibling);
          self.moveRow(row, true);
        }
      } else {
        if (self.toRow !== row || self.toRowAfter) {
          rowEl.parentNode.insertBefore(self.placeholderElement, rowEl);
          self.moveRow(row, false);
        }
      }
    }.bind(self);

    if (!this.hasHandle) {
      rowEl = row.getElement();
      rowEl.addEventListener("mousedown", function (e) {
        if (e.which === 1) {
          self.checkTimeout = setTimeout(function () {
            self.startMove(e, row);
          }, self.checkPeriod);
        }
      });
      rowEl.addEventListener("mouseup", function (e) {
        if (e.which === 1) {
          if (self.checkTimeout) {
            clearTimeout(self.checkTimeout);
          }
        }
      });
      this.bindTouchEvents(row, row.getElement());
    }

    row.modules.moveRow = config;
  }

  initializeColumn(column) {
    if (column.definition.rowHandle && this.table.options.movableRows !== false) {
      this.hasHandle = true;
    }
  }

  initializeCell(cell) {
    if (cell.column.definition.rowHandle && this.table.options.movableRows !== false) {
      var self = this,
          cellEl = cell.getElement(true);
      cellEl.addEventListener("mousedown", function (e) {
        if (e.which === 1) {
          self.checkTimeout = setTimeout(function () {
            self.startMove(e, cell.row);
          }, self.checkPeriod);
        }
      });
      cellEl.addEventListener("mouseup", function (e) {
        if (e.which === 1) {
          if (self.checkTimeout) {
            clearTimeout(self.checkTimeout);
          }
        }
      });
      this.bindTouchEvents(cell.row, cellEl);
    }
  }

  bindTouchEvents(row, element) {
    var startYMove = false,
        //shifting center position of the cell
    nextRow,
        prevRow,
        nextRowHeight,
        prevRowHeight,
        nextRowHeightLast,
        prevRowHeightLast;
    element.addEventListener("touchstart", e => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = true;
        nextRow = row.nextRow();
        nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
        prevRow = row.prevRow();
        prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
        nextRowHeightLast = 0;
        prevRowHeightLast = 0;
        startYMove = false;
        this.startMove(e, row);
      }, this.checkPeriod);
    }, {
      passive: true
    });
    this.moving, this.toRow, this.toRowAfter;
    element.addEventListener("touchmove", e => {
      var diff, moveToRow;

      if (this.moving) {
        e.preventDefault();
        this.moveHover(e);

        if (!startYMove) {
          startYMove = e.touches[0].pageY;
        }

        diff = e.touches[0].pageY - startYMove;

        if (diff > 0) {
          if (nextRow && diff - nextRowHeightLast > nextRowHeight) {
            moveToRow = nextRow;

            if (moveToRow !== row) {
              startYMove = e.touches[0].pageY;
              moveToRow.getElement().parentNode.insertBefore(this.placeholderElement, moveToRow.getElement().nextSibling);
              this.moveRow(moveToRow, true);
            }
          }
        } else {
          if (prevRow && -diff - prevRowHeightLast > prevRowHeight) {
            moveToRow = prevRow;

            if (moveToRow !== row) {
              startYMove = e.touches[0].pageY;
              moveToRow.getElement().parentNode.insertBefore(this.placeholderElement, moveToRow.getElement());
              this.moveRow(moveToRow, false);
            }
          }
        }

        if (moveToRow) {
          nextRow = moveToRow.nextRow();
          nextRowHeightLast = nextRowHeight;
          nextRowHeight = nextRow ? nextRow.getHeight() / 2 : 0;
          prevRow = moveToRow.prevRow();
          prevRowHeightLast = prevRowHeight;
          prevRowHeight = prevRow ? prevRow.getHeight() / 2 : 0;
        }
      }
    });
    element.addEventListener("touchend", e => {
      if (this.checkTimeout) {
        clearTimeout(this.checkTimeout);
      }

      if (this.moving) {
        this.endMove(e);
        this.touchMove = false;
      }
    });
  }

  _bindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach(row => {
      if ((row.type === "row" || row.type === "group") && row.modules.moveRow && row.modules.moveRow.mousemove) {
        row.getElement().addEventListener("mousemove", row.modules.moveRow.mousemove);
      }
    });
  }

  _unbindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach(row => {
      if ((row.type === "row" || row.type === "group") && row.modules.moveRow && row.modules.moveRow.mousemove) {
        row.getElement().removeEventListener("mousemove", row.modules.moveRow.mousemove);
      }
    });
  }

  startMove(e, row) {
    var element = row.getElement();
    this.setStartPosition(e, row);
    this.moving = row;
    this.table.element.classList.add("tabulator-block-select"); //create placeholder

    this.placeholderElement.style.width = row.getWidth() + "px";
    this.placeholderElement.style.height = row.getHeight() + "px";

    if (!this.connection) {
      element.parentNode.insertBefore(this.placeholderElement, element);
      element.parentNode.removeChild(element);
    } else {
      this.table.element.classList.add("tabulator-movingrow-sending");
      this.connectToTables(row);
    } //create hover element


    this.hoverElement = element.cloneNode(true);
    this.hoverElement.classList.add("tabulator-moving");

    if (this.connection) {
      document.body.appendChild(this.hoverElement);
      this.hoverElement.style.left = "0";
      this.hoverElement.style.top = "0";
      this.hoverElement.style.width = this.table.element.clientWidth + "px";
      this.hoverElement.style.whiteSpace = "nowrap";
      this.hoverElement.style.overflow = "hidden";
      this.hoverElement.style.pointerEvents = "none";
    } else {
      this.table.rowManager.getTableElement().appendChild(this.hoverElement);
      this.hoverElement.style.left = "0";
      this.hoverElement.style.top = "0";

      this._bindMouseMove();
    }

    document.body.addEventListener("mousemove", this.moveHover);
    document.body.addEventListener("mouseup", this.endMove);
    this.dispatchExternal("rowMoving", row.getComponent());
    this.moveHover(e);
  }

  setStartPosition(e, row) {
    var pageX = this.touchMove ? e.touches[0].pageX : e.pageX,
        pageY = this.touchMove ? e.touches[0].pageY : e.pageY,
        element,
        position;
    element = row.getElement();

    if (this.connection) {
      position = element.getBoundingClientRect();
      this.startX = position.left - pageX + window.pageXOffset;
      this.startY = position.top - pageY + window.pageYOffset;
    } else {
      this.startY = pageY - element.getBoundingClientRect().top;
    }
  }

  endMove(e) {
    if (!e || e.which === 1 || this.touchMove) {
      this._unbindMouseMove();

      if (!this.connection) {
        this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling);
        this.placeholderElement.parentNode.removeChild(this.placeholderElement);
      }

      this.hoverElement.parentNode.removeChild(this.hoverElement);
      this.table.element.classList.remove("tabulator-block-select");

      if (this.toRow) {
        this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter);
      } else {
        this.dispatchExternal("rowMoveCancelled", this.moving.getComponent());
      }

      this.moving = false;
      this.toRow = false;
      this.toRowAfter = false;
      document.body.removeEventListener("mousemove", this.moveHover);
      document.body.removeEventListener("mouseup", this.endMove);

      if (this.connection) {
        this.table.element.classList.remove("tabulator-movingrow-sending");
        this.disconnectFromTables();
      }
    }
  }

  moveRow(row, after) {
    this.toRow = row;
    this.toRowAfter = after;
  }

  moveHover(e) {
    if (this.connection) {
      this.moveHoverConnections.call(this, e);
    } else {
      this.moveHoverTable.call(this, e);
    }
  }

  moveHoverTable(e) {
    var rowHolder = this.table.rowManager.getElement(),
        scrollTop = rowHolder.scrollTop,
        yPos = (this.touchMove ? e.touches[0].pageY : e.pageY) - rowHolder.getBoundingClientRect().top + scrollTop;
    this.hoverElement.style.top = Math.min(yPos - this.startY, this.table.rowManager.element.scrollHeight - this.hoverElement.offsetHeight) + "px";
  }

  moveHoverConnections(e) {
    this.hoverElement.style.left = this.startX + (this.touchMove ? e.touches[0].pageX : e.pageX) + "px";
    this.hoverElement.style.top = this.startY + (this.touchMove ? e.touches[0].pageY : e.pageY) + "px";
  }

  elementRowDrop(e, element, row) {
    this.dispatchExternal("movableRowsElementDrop", e, element, row ? row.getComponent() : false);
  } //establish connection with other tables


  connectToTables(row) {
    var connectionTables;

    if (this.connectionSelectorsTables) {
      connectionTables = this.commsConnections(this.connectionSelectorsTables);
      this.dispatchExternal("movableRowsSendingStart", connectionTables);
      this.commsSend(this.connectionSelectorsTables, "moveRow", "connect", {
        row: row
      });
    }

    if (this.connectionSelectorsElements) {
      this.connectionElements = [];

      if (!Array.isArray(this.connectionSelectorsElements)) {
        this.connectionSelectorsElements = [this.connectionSelectorsElements];
      }

      this.connectionSelectorsElements.forEach(query => {
        if (typeof query === "string") {
          this.connectionElements = this.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(query)));
        } else {
          this.connectionElements.push(query);
        }
      });
      this.connectionElements.forEach(element => {
        var dropEvent = e => {
          this.elementRowDrop(e, element, this.moving);
        };

        element.addEventListener("mouseup", dropEvent);
        element.tabulatorElementDropEvent = dropEvent;
        element.classList.add("tabulator-movingrow-receiving");
      });
    }
  } //disconnect from other tables


  disconnectFromTables() {
    var connectionTables;

    if (this.connectionSelectorsTables) {
      connectionTables = this.commsConnections(this.connectionSelectorsTables);
      this.dispatchExternal("movableRowsSendingStop", connectionTables);
      this.commsSend(this.connectionSelectorsTables, "moveRow", "disconnect");
    }

    this.connectionElements.forEach(element => {
      element.classList.remove("tabulator-movingrow-receiving");
      element.removeEventListener("mouseup", element.tabulatorElementDropEvent);
      delete element.tabulatorElementDropEvent;
    });
  } //accept incomming connection


  connect(table, row) {
    if (!this.connectedTable) {
      this.connectedTable = table;
      this.connectedRow = row;
      this.table.element.classList.add("tabulator-movingrow-receiving");
      this.table.rowManager.getDisplayRows().forEach(row => {
        if (row.type === "row" && row.modules.moveRow && row.modules.moveRow.mouseup) {
          row.getElement().addEventListener("mouseup", row.modules.moveRow.mouseup);
        }
      });
      this.tableRowDropEvent = this.tableRowDrop.bind(this);
      this.table.element.addEventListener("mouseup", this.tableRowDropEvent);
      this.dispatchExternal("movableRowsReceivingStart", row, table);
      return true;
    } else {
      console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable);
      return false;
    }
  } //close incoming connection


  disconnect(table) {
    if (table === this.connectedTable) {
      this.connectedTable = false;
      this.connectedRow = false;
      this.table.element.classList.remove("tabulator-movingrow-receiving");
      this.table.rowManager.getDisplayRows().forEach(row => {
        if (row.type === "row" && row.modules.moveRow && row.modules.moveRow.mouseup) {
          row.getElement().removeEventListener("mouseup", row.modules.moveRow.mouseup);
        }
      });
      this.table.element.removeEventListener("mouseup", this.tableRowDropEvent);
      this.dispatchExternal("movableRowsReceivingStop", table);
    } else {
      console.warn("Move Row Error - trying to disconnect from non connected table");
    }
  }

  dropComplete(table, row, success) {
    var sender = false;

    if (success) {
      switch (typeof this.table.options.movableRowsSender) {
        case "string":
          sender = this.senders[this.table.options.movableRowsSender];
          break;

        case "function":
          sender = this.table.options.movableRowsSender;
          break;
      }

      if (sender) {
        sender.call(this, this.moving ? this.moving.getComponent() : undefined, row ? row.getComponent() : undefined, table);
      } else {
        if (this.table.options.movableRowsSender) {
          console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender);
        }
      }

      this.dispatchExternal("movableRowsSent", this.moving.getComponent(), row ? row.getComponent() : undefined, table);
    } else {
      this.dispatchExternal("movableRowsSentFailed", this.moving.getComponent(), row ? row.getComponent() : undefined, table);
    }

    this.endMove();
  }

  tableRowDrop(e, row) {
    var receiver = false,
        success = false;
    e.stopImmediatePropagation();

    switch (typeof this.table.options.movableRowsReceiver) {
      case "string":
        receiver = this.receivers[this.table.options.movableRowsReceiver];
        break;

      case "function":
        receiver = this.table.options.movableRowsReceiver;
        break;
    }

    if (receiver) {
      success = receiver.call(this, this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
    } else {
      console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver);
    }

    if (success) {
      this.dispatchExternal("movableRowsReceived", this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
    } else {
      this.dispatchExternal("movableRowsReceivedFailed", this.connectedRow.getComponent(), row ? row.getComponent() : undefined, this.connectedTable);
    }

    this.commsSend(this.connectedTable, "moveRow", "dropcomplete", {
      row: row,
      success: success
    });
  }

  commsReceived(table, action, data) {
    switch (action) {
      case "connect":
        return this.connect(table, data.row);

      case "disconnect":
        return this.disconnect(table);

      case "dropcomplete":
        return this.dropComplete(table, data.row, data.success);
    }
  }

}

exports.MoveRowsModule = MoveRows;
MoveRows.prototype.receivers = {
  insert: function (fromRow, toRow, fromTable) {
    this.table.addRow(fromRow.getData(), undefined, toRow);
    return true;
  },
  add: function (fromRow, toRow, fromTable) {
    this.table.addRow(fromRow.getData());
    return true;
  },
  update: function (fromRow, toRow, fromTable) {
    if (toRow) {
      toRow.update(fromRow.getData());
      return true;
    }

    return false;
  },
  replace: function (fromRow, toRow, fromTable) {
    if (toRow) {
      this.table.addRow(fromRow.getData(), undefined, toRow);
      toRow.delete();
      return true;
    }

    return false;
  }
};
MoveRows.prototype.senders = {
  delete: function (fromRow, toRow, toTable) {
    fromRow.delete();
  }
};
MoveRows.moduleName = "moveRow";
var defaultMutators = {};

class Mutator extends Module {
  constructor(table) {
    super(table);
    this.allowedTypes = ["", "data", "edit", "clipboard"]; //list of mutation types

    this.enabled = true;
    this.registerColumnOption("mutator");
    this.registerColumnOption("mutatorParams");
    this.registerColumnOption("mutatorData");
    this.registerColumnOption("mutatorDataParams");
    this.registerColumnOption("mutatorEdit");
    this.registerColumnOption("mutatorEditParams");
    this.registerColumnOption("mutatorClipboard");
    this.registerColumnOption("mutatorClipboardParams");
    this.registerColumnOption("mutateLink");
  }

  initialize() {
    this.subscribe("cell-value-changing", this.transformCell.bind(this));
    this.subscribe("cell-value-changed", this.mutateLink.bind(this));
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("row-data-init-before", this.rowDataChanged.bind(this));
    this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
  }

  rowDataChanged(row, tempData, updatedData) {
    return this.transformRow(tempData, "data", updatedData);
  } //initialize column mutator


  initializeColumn(column) {
    var match = false,
        config = {};
    this.allowedTypes.forEach(type => {
      var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)),
          mutator;

      if (column.definition[key]) {
        mutator = this.lookupMutator(column.definition[key]);

        if (mutator) {
          match = true;
          config[key] = {
            mutator: mutator,
            params: column.definition[key + "Params"] || {}
          };
        }
      }
    });

    if (match) {
      column.modules.mutate = config;
    }
  }

  lookupMutator(value) {
    var mutator = false; //set column mutator

    switch (typeof value) {
      case "string":
        if (Mutator.mutators[value]) {
          mutator = Mutator.mutators[value];
        } else {
          console.warn("Mutator Error - No such mutator found, ignoring: ", value);
        }

        break;

      case "function":
        mutator = value;
        break;
    }

    return mutator;
  } //apply mutator to row


  transformRow(data, type, updatedData) {
    var key = "mutator" + (type.charAt(0).toUpperCase() + type.slice(1)),
        value;

    if (this.enabled) {
      this.table.columnManager.traverse(column => {
        var mutator, params, component;

        if (column.modules.mutate) {
          mutator = column.modules.mutate[key] || column.modules.mutate.mutator || false;

          if (mutator) {
            value = column.getFieldValue(typeof updatedData !== "undefined" ? updatedData : data);

            if (type == "data" || typeof value !== "undefined") {
              component = column.getComponent();
              params = typeof mutator.params === "function" ? mutator.params(value, data, type, component) : mutator.params;
              column.setFieldValue(data, mutator.mutator(value, data, type, params, component));
            }
          }
        }
      });
    }

    return data;
  } //apply mutator to new cell value


  transformCell(cell, value) {
    if (cell.column.modules.mutate) {
      var mutator = cell.column.modules.mutate.mutatorEdit || cell.column.modules.mutate.mutator || false,
          tempData = {};

      if (mutator) {
        tempData = Object.assign(tempData, cell.row.getData());
        cell.column.setFieldValue(tempData, value);
        return mutator.mutator(value, tempData, "edit", mutator.params, cell.getComponent());
      }
    }

    return value;
  }

  mutateLink(cell) {
    var links = cell.column.definition.mutateLink;

    if (links) {
      if (!Array.isArray(links)) {
        links = [links];
      }

      links.forEach(link => {
        var linkCell = cell.row.getCell(link);

        if (linkCell) {
          linkCell.setValue(linkCell.getValue(), true, true);
        }
      });
    }
  }

  enable() {
    this.enabled = true;
  }

  disable() {
    this.enabled = false;
  }

}

exports.MutatorModule = Mutator;
Mutator.moduleName = "mutator"; //load defaults

Mutator.mutators = defaultMutators;

function rows(pageSize, currentRow, currentPage, totalRows, totalPages) {
  var el = document.createElement("span"),
      showingEl = document.createElement("span"),
      valueEl = document.createElement("span"),
      ofEl = document.createElement("span"),
      totalEl = document.createElement("span"),
      rowsEl = document.createElement("span");
  this.table.modules.localize.langBind("pagination|counter|showing", value => {
    showingEl.innerHTML = value;
  });
  this.table.modules.localize.langBind("pagination|counter|of", value => {
    ofEl.innerHTML = value;
  });
  this.table.modules.localize.langBind("pagination|counter|rows", value => {
    rowsEl.innerHTML = value;
  });

  if (totalRows) {
    valueEl.innerHTML = " " + currentRow + "-" + Math.min(currentRow + pageSize - 1, totalRows) + " ";
    totalEl.innerHTML = " " + totalRows + " ";
    el.appendChild(showingEl);
    el.appendChild(valueEl);
    el.appendChild(ofEl);
    el.appendChild(totalEl);
    el.appendChild(rowsEl);
  } else {
    valueEl.innerHTML = " 0 ";
    el.appendChild(showingEl);
    el.appendChild(valueEl);
    el.appendChild(rowsEl);
  }

  return el;
}

function pages(pageSize, currentRow, currentPage, totalRows, totalPages) {
  var el = document.createElement("span"),
      showingEl = document.createElement("span"),
      valueEl = document.createElement("span"),
      ofEl = document.createElement("span"),
      totalEl = document.createElement("span"),
      rowsEl = document.createElement("span");
  this.table.modules.localize.langBind("pagination|counter|showing", value => {
    showingEl.innerHTML = value;
  });
  valueEl.innerHTML = " " + currentPage + " ";
  this.table.modules.localize.langBind("pagination|counter|of", value => {
    ofEl.innerHTML = value;
  });
  totalEl.innerHTML = " " + totalPages + " ";
  this.table.modules.localize.langBind("pagination|counter|pages", value => {
    rowsEl.innerHTML = value;
  });
  el.appendChild(showingEl);
  el.appendChild(valueEl);
  el.appendChild(ofEl);
  el.appendChild(totalEl);
  el.appendChild(rowsEl);
  return el;
}

var defaultPageCounters = {
  rows: rows,
  pages: pages
};

class Page extends Module {
  constructor(table) {
    super(table);
    this.mode = "local";
    this.progressiveLoad = false;
    this.element = null;
    this.pageCounterElement = null;
    this.pageCounter = null;
    this.size = 0;
    this.page = 1;
    this.count = 5;
    this.max = 1;
    this.remoteRowCountEstimate = null;
    this.displayIndex = 0; //index in display pipeline

    this.initialLoad = true;
    this.dataChanging = false; //flag to check if data is being changed by this module

    this.pageSizes = [];
    this.registerTableOption("pagination", false); //set pagination type

    this.registerTableOption("paginationMode", "local"); //local or remote pagination

    this.registerTableOption("paginationSize", false); //set number of rows to a page

    this.registerTableOption("paginationInitialPage", 1); //initial page to show on load

    this.registerTableOption("paginationCounter", false); // set pagination counter

    this.registerTableOption("paginationCounterElement", false); // set pagination counter

    this.registerTableOption("paginationButtonCount", 5); // set count of page button

    this.registerTableOption("paginationSizeSelector", false); //add pagination size selector element

    this.registerTableOption("paginationElement", false); //element to hold pagination numbers
    // this.registerTableOption("paginationDataSent", {}); //pagination data sent to the server
    // this.registerTableOption("paginationDataReceived", {}); //pagination data received from the server

    this.registerTableOption("paginationAddRow", "page"); //add rows on table or page

    this.registerTableOption("progressiveLoad", false); //progressive loading

    this.registerTableOption("progressiveLoadDelay", 0); //delay between requests

    this.registerTableOption("progressiveLoadScrollMargin", 0); //margin before scroll begins

    this.registerTableFunction("setMaxPage", this.setMaxPage.bind(this));
    this.registerTableFunction("setPage", this.setPage.bind(this));
    this.registerTableFunction("setPageToRow", this.userSetPageToRow.bind(this));
    this.registerTableFunction("setPageSize", this.userSetPageSize.bind(this));
    this.registerTableFunction("getPageSize", this.getPageSize.bind(this));
    this.registerTableFunction("previousPage", this.previousPage.bind(this));
    this.registerTableFunction("nextPage", this.nextPage.bind(this));
    this.registerTableFunction("getPage", this.getPage.bind(this));
    this.registerTableFunction("getPageMax", this.getPageMax.bind(this)); //register component functions

    this.registerComponentFunction("row", "pageTo", this.setPageToRow.bind(this));
  }

  initialize() {
    if (this.table.options.pagination) {
      this.subscribe("row-deleted", this.rowsUpdated.bind(this));
      this.subscribe("row-added", this.rowsUpdated.bind(this));
      this.subscribe("data-processed", this.initialLoadComplete.bind(this));
      this.subscribe("table-built", this.calculatePageSizes.bind(this));
      this.subscribe("footer-redraw", this.footerRedraw.bind(this));

      if (this.table.options.paginationAddRow == "page") {
        this.subscribe("row-adding-position", this.rowAddingPosition.bind(this));
      }

      if (this.table.options.paginationMode === "remote") {
        this.subscribe("data-params", this.remotePageParams.bind(this));
        this.subscribe("data-loaded", this._parseRemoteData.bind(this));
      }

      if (this.table.options.progressiveLoad) {
        console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time");
      }

      this.registerDisplayHandler(this.restOnRenderBefore.bind(this), 40);
      this.registerDisplayHandler(this.getRows.bind(this), 50);
      this.createElements();
      this.initializePageCounter();
      this.initializePaginator();
    } else if (this.table.options.progressiveLoad) {
      this.subscribe("data-params", this.remotePageParams.bind(this));
      this.subscribe("data-loaded", this._parseRemoteData.bind(this));
      this.subscribe("table-built", this.calculatePageSizes.bind(this));
      this.subscribe("data-processed", this.initialLoadComplete.bind(this));
      this.initializeProgressive(this.table.options.progressiveLoad);

      if (this.table.options.progressiveLoad === "scroll") {
        this.subscribe("scroll-vertical", this.scrollVertical.bind(this));
      }
    }
  }

  rowAddingPosition(row, top) {
    var rowManager = this.table.rowManager,
        displayRows = rowManager.getDisplayRows(),
        index;

    if (top) {
      if (displayRows.length) {
        index = displayRows[0];
      } else {
        if (rowManager.activeRows.length) {
          index = rowManager.activeRows[rowManager.activeRows.length - 1];
          top = false;
        }
      }
    } else {
      if (displayRows.length) {
        index = displayRows[displayRows.length - 1];
        top = displayRows.length < this.size ? false : true;
      }
    }

    return {
      index,
      top
    };
  }

  calculatePageSizes() {
    var testElRow, testElCell;

    if (this.table.options.paginationSize) {
      this.size = this.table.options.paginationSize;
    } else {
      testElRow = document.createElement("div");
      testElRow.classList.add("tabulator-row");
      testElRow.style.visibility = "hidden";
      testElCell = document.createElement("div");
      testElCell.classList.add("tabulator-cell");
      testElCell.innerHTML = "Page Row Test";
      testElRow.appendChild(testElCell);
      this.table.rowManager.getTableElement().appendChild(testElRow);
      this.size = Math.floor(this.table.rowManager.getElement().clientHeight / testElRow.offsetHeight);
      this.table.rowManager.getTableElement().removeChild(testElRow);
    }

    this.dispatchExternal("pageSizeChanged", this.size);
    this.generatePageSizeSelectList();
  }

  initialLoadComplete() {
    this.initialLoad = false;
  }

  remotePageParams(data, config, silent, params) {
    if (!this.initialLoad) {
      if (this.progressiveLoad && !silent || !this.progressiveLoad && !this.dataChanging) {
        this.reset(true);
      }
    } //configure request params


    params.page = this.page; //set page size if defined

    if (this.size) {
      params.size = this.size;
    }

    return params;
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////


  userSetPageToRow(row) {
    if (this.table.options.pagination) {
      row = this.rowManager.findRow(row);

      if (row) {
        return this.setPageToRow(row);
      }
    }

    return Promise.reject();
  }

  userSetPageSize(size) {
    if (this.table.options.pagination) {
      this.setPageSize(size);
      return this.setPage(1);
    } else {
      return false;
    }
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  scrollVertical(top, dir) {
    var element, diff, margin;

    if (!dir && !this.table.dataLoader.loading) {
      element = this.table.rowManager.getElement();
      diff = element.scrollHeight - element.clientHeight - top;
      margin = this.table.options.progressiveLoadScrollMargin || element.clientHeight * 2;

      if (diff < margin) {
        this.nextPage().catch(() => {}); //consume the exception thrown when on the last page
      }
    }
  }

  restOnRenderBefore(rows, renderInPosition) {
    if (!renderInPosition) {
      if (this.mode === "local") {
        this.reset();
      }
    }

    return rows;
  }

  rowsUpdated() {
    this.refreshData(true, "all");
  }

  createElements() {
    var button;
    this.element = document.createElement("span");
    this.element.classList.add("tabulator-paginator");
    this.pagesElement = document.createElement("span");
    this.pagesElement.classList.add("tabulator-pages");
    button = document.createElement("button");
    button.classList.add("tabulator-page");
    button.setAttribute("type", "button");
    button.setAttribute("role", "button");
    button.setAttribute("aria-label", "");
    button.setAttribute("title", "");
    this.firstBut = button.cloneNode(true);
    this.firstBut.setAttribute("data-page", "first");
    this.prevBut = button.cloneNode(true);
    this.prevBut.setAttribute("data-page", "prev");
    this.nextBut = button.cloneNode(true);
    this.nextBut.setAttribute("data-page", "next");
    this.lastBut = button.cloneNode(true);
    this.lastBut.setAttribute("data-page", "last");

    if (this.table.options.paginationSizeSelector) {
      this.pageSizeSelect = document.createElement("select");
      this.pageSizeSelect.classList.add("tabulator-page-size");
    }
  }

  generatePageSizeSelectList() {
    var pageSizes = [];

    if (this.pageSizeSelect) {
      if (Array.isArray(this.table.options.paginationSizeSelector)) {
        pageSizes = this.table.options.paginationSizeSelector;
        this.pageSizes = pageSizes;

        if (this.pageSizes.indexOf(this.size) == -1) {
          pageSizes.unshift(this.size);
        }
      } else {
        if (this.pageSizes.indexOf(this.size) == -1) {
          pageSizes = [];

          for (let i = 1; i < 5; i++) {
            pageSizes.push(this.size * i);
          }

          this.pageSizes = pageSizes;
        } else {
          pageSizes = this.pageSizes;
        }
      }

      while (this.pageSizeSelect.firstChild) this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);

      pageSizes.forEach(item => {
        var itemEl = document.createElement("option");
        itemEl.value = item;

        if (item === true) {
          this.langBind("pagination|all", function (value) {
            itemEl.innerHTML = value;
          });
        } else {
          itemEl.innerHTML = item;
        }

        this.pageSizeSelect.appendChild(itemEl);
      });
      this.pageSizeSelect.value = this.size;
    }
  }

  initializePageCounter() {
    var counter = this.table.options.paginationCounter,
        pageCounter = null;

    if (counter) {
      if (typeof counter === "function") {
        pageCounter = counter;
      } else {
        pageCounter = Page.pageCounters[counter];
      }

      if (pageCounter) {
        this.pageCounter = pageCounter;
        this.pageCounterElement = document.createElement("span");
        this.pageCounterElement.classList.add("tabulator-page-counter");
      } else {
        console.warn("Pagination Error - No such page counter found: ", counter);
      }
    }
  } //setup pagination


  initializePaginator(hidden) {
    var pageSelectLabel, paginationCounterHolder;

    if (!hidden) {
      //build pagination element
      //bind localizations
      this.langBind("pagination|first", value => {
        this.firstBut.innerHTML = value;
      });
      this.langBind("pagination|first_title", value => {
        this.firstBut.setAttribute("aria-label", value);
        this.firstBut.setAttribute("title", value);
      });
      this.langBind("pagination|prev", value => {
        this.prevBut.innerHTML = value;
      });
      this.langBind("pagination|prev_title", value => {
        this.prevBut.setAttribute("aria-label", value);
        this.prevBut.setAttribute("title", value);
      });
      this.langBind("pagination|next", value => {
        this.nextBut.innerHTML = value;
      });
      this.langBind("pagination|next_title", value => {
        this.nextBut.setAttribute("aria-label", value);
        this.nextBut.setAttribute("title", value);
      });
      this.langBind("pagination|last", value => {
        this.lastBut.innerHTML = value;
      });
      this.langBind("pagination|last_title", value => {
        this.lastBut.setAttribute("aria-label", value);
        this.lastBut.setAttribute("title", value);
      }); //click bindings

      this.firstBut.addEventListener("click", () => {
        this.setPage(1);
      });
      this.prevBut.addEventListener("click", () => {
        this.previousPage();
      });
      this.nextBut.addEventListener("click", () => {
        this.nextPage();
      });
      this.lastBut.addEventListener("click", () => {
        this.setPage(this.max);
      });

      if (this.table.options.paginationElement) {
        this.element = this.table.options.paginationElement;
      }

      if (this.pageSizeSelect) {
        pageSelectLabel = document.createElement("label");
        this.langBind("pagination|page_size", value => {
          this.pageSizeSelect.setAttribute("aria-label", value);
          this.pageSizeSelect.setAttribute("title", value);
          pageSelectLabel.innerHTML = value;
        });
        this.element.appendChild(pageSelectLabel);
        this.element.appendChild(this.pageSizeSelect);
        this.pageSizeSelect.addEventListener("change", e => {
          this.setPageSize(this.pageSizeSelect.value == "true" ? true : this.pageSizeSelect.value);
          this.setPage(1);
        });
      } //append to DOM


      this.element.appendChild(this.firstBut);
      this.element.appendChild(this.prevBut);
      this.element.appendChild(this.pagesElement);
      this.element.appendChild(this.nextBut);
      this.element.appendChild(this.lastBut);

      if (!this.table.options.paginationElement) {
        if (this.table.options.paginationCounter) {
          if (this.table.options.paginationCounterElement) {
            if (this.table.options.paginationCounterElement instanceof HTMLElement) {
              this.table.options.paginationCounterElement.appendChild(this.pageCounterElement);
            } else if (typeof this.table.options.paginationCounterElement === "string") {
              paginationCounterHolder = document.querySelector(this.table.options.paginationCounterElement);

              if (paginationCounterHolder) {
                paginationCounterHolder.appendChild(this.pageCounterElement);
              } else {
                console.warn("Pagination Error - Unable to find element matching paginationCounterElement selector:", this.table.options.paginationCounterElement);
              }
            }
          } else {
            this.footerAppend(this.pageCounterElement);
          }
        }

        this.footerAppend(this.element);
      }

      this.page = this.table.options.paginationInitialPage;
      this.count = this.table.options.paginationButtonCount;
    } //set default values


    this.mode = this.table.options.paginationMode;
  }

  initializeProgressive(mode) {
    this.initializePaginator(true);
    this.mode = "progressive_" + mode;
    this.progressiveLoad = true;
  }

  trackChanges() {
    this.dispatch("page-changed");
  }

  setDisplayIndex(index) {
    this.displayIndex = index;
  }

  getDisplayIndex() {
    return this.displayIndex;
  } //calculate maximum page from number of rows


  setMaxRows(rowCount) {
    if (!rowCount) {
      this.max = 1;
    } else {
      this.max = this.size === true ? 1 : Math.ceil(rowCount / this.size);
    }

    if (this.page > this.max) {
      this.page = this.max;
    }
  } //reset to first page without triggering action


  reset(force) {
    if (!this.initialLoad) {
      if (this.mode == "local" || force) {
        this.page = 1;
      }
    }
  } //set the maximum page


  setMaxPage(max) {
    max = parseInt(max);
    this.max = max || 1;

    if (this.page > this.max) {
      this.page = this.max;
      this.trigger();
    }
  } //set current page number


  setPage(page) {
    switch (page) {
      case "first":
        return this.setPage(1);

      case "prev":
        return this.previousPage();

      case "next":
        return this.nextPage();

      case "last":
        return this.setPage(this.max);
    }

    page = parseInt(page);

    if (page > 0 && page <= this.max || this.mode !== "local") {
      this.page = page;
      this.trackChanges();
      return this.trigger();
    } else {
      console.warn("Pagination Error - Requested page is out of range of 1 - " + this.max + ":", page);
      return Promise.reject();
    }
  }

  setPageToRow(row) {
    var rows = this.table.rowManager.getDisplayRows(this.displayIndex - 1);
    var index = rows.indexOf(row);

    if (index > -1) {
      var page = this.size === true ? 1 : Math.ceil((index + 1) / this.size);
      return this.setPage(page);
    } else {
      console.warn("Pagination Error - Requested row is not visible");
      return Promise.reject();
    }
  }

  setPageSize(size) {
    if (size !== true) {
      size = parseInt(size);
    }

    if (size > 0) {
      this.size = size;
      this.dispatchExternal("pageSizeChanged", size);
    }

    if (this.pageSizeSelect) {
      // this.pageSizeSelect.value = size;
      this.generatePageSizeSelectList();
    }

    this.trackChanges();
  }

  _setPageCounter(totalRows, size, currentRow) {
    var content;

    if (this.pageCounter) {
      if (this.mode === "remote") {
        size = this.size;
        currentRow = (this.page - 1) * this.size + 1;
        totalRows = this.remoteRowCountEstimate;
      }

      content = this.pageCounter.call(this, size, currentRow, this.page, totalRows, this.max);

      switch (typeof content) {
        case "object":
          if (content instanceof Node) {
            //clear previous cell contents
            while (this.pageCounterElement.firstChild) this.pageCounterElement.removeChild(this.pageCounterElement.firstChild);

            this.pageCounterElement.appendChild(content);
          } else {
            this.pageCounterElement.innerHTML = "";

            if (content != null) {
              console.warn("Page Counter Error - Page Counter has returned a type of object, the only valid page counter object return is an instance of Node, the page counter returned:", content);
            }
          }

          break;

        case "undefined":
          this.pageCounterElement.innerHTML = "";
          break;

        default:
          this.pageCounterElement.innerHTML = content;
      }
    }
  } //setup the pagination buttons


  _setPageButtons() {
    let leftSize = Math.floor((this.count - 1) / 2);
    let rightSize = Math.ceil((this.count - 1) / 2);
    let min = this.max - this.page + leftSize + 1 < this.count ? this.max - this.count + 1 : Math.max(this.page - leftSize, 1);
    let max = this.page <= rightSize ? Math.min(this.count, this.max) : Math.min(this.page + rightSize, this.max);

    while (this.pagesElement.firstChild) this.pagesElement.removeChild(this.pagesElement.firstChild);

    if (this.page == 1) {
      this.firstBut.disabled = true;
      this.prevBut.disabled = true;
    } else {
      this.firstBut.disabled = false;
      this.prevBut.disabled = false;
    }

    if (this.page == this.max) {
      this.lastBut.disabled = true;
      this.nextBut.disabled = true;
    } else {
      this.lastBut.disabled = false;
      this.nextBut.disabled = false;
    }

    for (let i = min; i <= max; i++) {
      if (i > 0 && i <= this.max) {
        this.pagesElement.appendChild(this._generatePageButton(i));
      }
    }

    this.footerRedraw();
  }

  _generatePageButton(page) {
    var button = document.createElement("button");
    button.classList.add("tabulator-page");

    if (page == this.page) {
      button.classList.add("active");
    }

    button.setAttribute("type", "button");
    button.setAttribute("role", "button");
    this.langBind("pagination|page_title", value => {
      button.setAttribute("aria-label", value + " " + page);
      button.setAttribute("title", value + " " + page);
    });
    button.setAttribute("data-page", page);
    button.textContent = page;
    button.addEventListener("click", e => {
      this.setPage(page);
    });
    return button;
  } //previous page


  previousPage() {
    if (this.page > 1) {
      this.page--;
      this.trackChanges();
      return this.trigger();
    } else {
      console.warn("Pagination Error - Previous page would be less than page 1:", 0);
      return Promise.reject();
    }
  } //next page


  nextPage() {
    if (this.page < this.max) {
      this.page++;
      this.trackChanges();
      return this.trigger();
    } else {
      if (!this.progressiveLoad) {
        console.warn("Pagination Error - Next page would be greater than maximum page of " + this.max + ":", this.max + 1);
      }

      return Promise.reject();
    }
  } //return current page number


  getPage() {
    return this.page;
  } //return max page number


  getPageMax() {
    return this.max;
  }

  getPageSize(size) {
    return this.size;
  }

  getMode() {
    return this.mode;
  } //return appropriate rows for current page


  getRows(data) {
    var actualRowPageSize = 0,
        output,
        start,
        end,
        actualStartRow;
    var actualRows = data.filter(row => {
      return row.type === "row";
    });

    if (this.mode == "local") {
      output = [];
      this.setMaxRows(data.length);

      if (this.size === true) {
        start = 0;
        end = data.length;
      } else {
        start = this.size * (this.page - 1);
        end = start + parseInt(this.size);
      }

      this._setPageButtons();

      for (let i = start; i < end; i++) {
        let row = data[i];

        if (row) {
          output.push(row);

          if (row.type === "row") {
            if (!actualStartRow) {
              actualStartRow = row;
            }

            actualRowPageSize++;
          }
        }
      }

      this._setPageCounter(actualRows.length, actualRowPageSize, actualStartRow ? actualRows.indexOf(actualStartRow) + 1 : 0);

      return output;
    } else {
      this._setPageButtons();

      this._setPageCounter(actualRows.length);

      return data.slice(0);
    }
  }

  trigger() {
    var left;

    switch (this.mode) {
      case "local":
        left = this.table.rowManager.scrollLeft;
        this.refreshData();
        this.table.rowManager.scrollHorizontal(left);
        this.dispatchExternal("pageLoaded", this.getPage());
        return Promise.resolve();

      case "remote":
        this.dataChanging = true;
        return this.reloadData(null).finally(() => {
          this.dataChanging = false;
        });

      case "progressive_load":
      case "progressive_scroll":
        return this.reloadData(null, true);

      default:
        console.warn("Pagination Error - no such pagination mode:", this.mode);
        return Promise.reject();
    }
  }

  _parseRemoteData(data) {
    var margin;

    if (typeof data.last_page === "undefined") {
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").last_page || "last_page") + "' property");
    }

    if (data.data) {
      this.max = parseInt(data.last_page) || 1;
      this.remoteRowCountEstimate = typeof data.last_row !== "undefined" ? data.last_row : data.last_page * this.size - (this.page == data.last_page ? this.size - data.data.length : 0);

      if (this.progressiveLoad) {
        switch (this.mode) {
          case "progressive_load":
            if (this.page == 1) {
              this.table.rowManager.setData(data.data, false, this.page == 1);
            } else {
              this.table.rowManager.addRows(data.data);
            }

            if (this.page < this.max) {
              setTimeout(() => {
                this.nextPage();
              }, this.table.options.progressiveLoadDelay);
            }

            break;

          case "progressive_scroll":
            data = this.page === 1 ? data.data : this.table.rowManager.getData().concat(data.data);
            this.table.rowManager.setData(data, this.page !== 1, this.page == 1);
            margin = this.table.options.progressiveLoadScrollMargin || this.table.rowManager.element.clientHeight * 2;

            if (this.table.rowManager.element.scrollHeight <= this.table.rowManager.element.clientHeight + margin) {
              if (this.page < this.max) {
                setTimeout(() => {
                  this.nextPage();
                });
              }
            }

            break;
        }

        return false;
      } else {
        // left = this.table.rowManager.scrollLeft;
        this.dispatchExternal("pageLoaded", this.getPage()); // this.table.rowManager.scrollHorizontal(left);
        // this.table.columnManager.scrollHorizontal(left);
      }
    } else {
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").data || "data") + "' property");
    }

    return data.data;
  } //handle the footer element being redrawn


  footerRedraw() {
    var footer = this.table.footerManager.containerElement;

    if (Math.ceil(footer.clientWidth) - footer.scrollWidth < 0) {
      this.pagesElement.style.display = 'none';
    } else {
      this.pagesElement.style.display = '';

      if (Math.ceil(footer.clientWidth) - footer.scrollWidth < 0) {
        this.pagesElement.style.display = 'none';
      }
    }
  }

}

exports.PageModule = Page;
Page.moduleName = "page"; //load defaults

Page.pageCounters = defaultPageCounters; // read persistance information from storage

var defaultReaders = {
  local: function (id, type) {
    var data = localStorage.getItem(id + "-" + type);
    return data ? JSON.parse(data) : false;
  },
  cookie: function (id, type) {
    var cookie = document.cookie,
        key = id + "-" + type,
        cookiePos = cookie.indexOf(key + "="),
        end,
        data; //if cookie exists, decode and load column data into tabulator

    if (cookiePos > -1) {
      cookie = cookie.slice(cookiePos);
      end = cookie.indexOf(";");

      if (end > -1) {
        cookie = cookie.slice(0, end);
      }

      data = cookie.replace(key + "=", "");
    }

    return data ? JSON.parse(data) : false;
  }
}; //write persistence information to storage

var defaultWriters = {
  local: function (id, type, data) {
    localStorage.setItem(id + "-" + type, JSON.stringify(data));
  },
  cookie: function (id, type, data) {
    var expireDate = new Date();
    expireDate.setDate(expireDate.getDate() + 10000);
    document.cookie = id + "-" + type + "=" + JSON.stringify(data) + "; expires=" + expireDate.toUTCString();
  }
};

class Persistence extends Module {
  constructor(table) {
    super(table);
    this.mode = "";
    this.id = ""; // this.persistProps = ["field", "width", "visible"];

    this.defWatcherBlock = false;
    this.config = {};
    this.readFunc = false;
    this.writeFunc = false;
    this.registerTableOption("persistence", false);
    this.registerTableOption("persistenceID", ""); //key for persistent storage

    this.registerTableOption("persistenceMode", true); //mode for storing persistence information

    this.registerTableOption("persistenceReaderFunc", false); //function for handling persistence data reading

    this.registerTableOption("persistenceWriterFunc", false); //function for handling persistence data writing
  } // Test for whether localStorage is available for use.


  localStorageTest() {
    var testKey = "_tabulator_test";

    try {
      window.localStorage.setItem(testKey, testKey);
      window.localStorage.removeItem(testKey);
      return true;
    } catch (e) {
      return false;
    }
  } //setup parameters


  initialize() {
    if (this.table.options.persistence) {
      //determine persistent layout storage type
      var mode = this.table.options.persistenceMode,
          id = this.table.options.persistenceID,
          retrievedData;
      this.mode = mode !== true ? mode : this.localStorageTest() ? "local" : "cookie";

      if (this.table.options.persistenceReaderFunc) {
        if (typeof this.table.options.persistenceReaderFunc === "function") {
          this.readFunc = this.table.options.persistenceReaderFunc;
        } else {
          if (Persistence.readers[this.table.options.persistenceReaderFunc]) {
            this.readFunc = Persistence.readers[this.table.options.persistenceReaderFunc];
          } else {
            console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc);
          }
        }
      } else {
        if (Persistence.readers[this.mode]) {
          this.readFunc = Persistence.readers[this.mode];
        } else {
          console.warn("Persistence Read Error - invalid reader set", this.mode);
        }
      }

      if (this.table.options.persistenceWriterFunc) {
        if (typeof this.table.options.persistenceWriterFunc === "function") {
          this.writeFunc = this.table.options.persistenceWriterFunc;
        } else {
          if (Persistence.writers[this.table.options.persistenceWriterFunc]) {
            this.writeFunc = Persistence.writers[this.table.options.persistenceWriterFunc];
          } else {
            console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc);
          }
        }
      } else {
        if (Persistence.writers[this.mode]) {
          this.writeFunc = Persistence.writers[this.mode];
        } else {
          console.warn("Persistence Write Error - invalid writer set", this.mode);
        }
      } //set storage tag


      this.id = "tabulator-" + (id || this.table.element.getAttribute("id") || "");
      this.config = {
        sort: this.table.options.persistence === true || this.table.options.persistence.sort,
        filter: this.table.options.persistence === true || this.table.options.persistence.filter,
        group: this.table.options.persistence === true || this.table.options.persistence.group,
        page: this.table.options.persistence === true || this.table.options.persistence.page,
        columns: this.table.options.persistence === true ? ["title", "width", "visible"] : this.table.options.persistence.columns
      }; //load pagination data if needed

      if (this.config.page) {
        retrievedData = this.retrieveData("page");

        if (retrievedData) {
          if (typeof retrievedData.paginationSize !== "undefined" && (this.config.page === true || this.config.page.size)) {
            this.table.options.paginationSize = retrievedData.paginationSize;
          }

          if (typeof retrievedData.paginationInitialPage !== "undefined" && (this.config.page === true || this.config.page.page)) {
            this.table.options.paginationInitialPage = retrievedData.paginationInitialPage;
          }
        }
      } //load group data if needed


      if (this.config.group) {
        retrievedData = this.retrieveData("group");

        if (retrievedData) {
          if (typeof retrievedData.groupBy !== "undefined" && (this.config.group === true || this.config.group.groupBy)) {
            this.table.options.groupBy = retrievedData.groupBy;
          }

          if (typeof retrievedData.groupStartOpen !== "undefined" && (this.config.group === true || this.config.group.groupStartOpen)) {
            this.table.options.groupStartOpen = retrievedData.groupStartOpen;
          }

          if (typeof retrievedData.groupHeader !== "undefined" && (this.config.group === true || this.config.group.groupHeader)) {
            this.table.options.groupHeader = retrievedData.groupHeader;
          }
        }
      }

      if (this.config.columns) {
        this.table.options.columns = this.load("columns", this.table.options.columns);
        this.subscribe("column-init", this.initializeColumn.bind(this));
        this.subscribe("column-show", this.save.bind(this, "columns"));
        this.subscribe("column-hide", this.save.bind(this, "columns"));
        this.subscribe("column-moved", this.save.bind(this, "columns"));
      }

      this.subscribe("table-built", this.tableBuilt.bind(this), 0);
      this.subscribe("table-redraw", this.tableRedraw.bind(this));
      this.subscribe("filter-changed", this.eventSave.bind(this, "filter"));
      this.subscribe("sort-changed", this.eventSave.bind(this, "sort"));
      this.subscribe("group-changed", this.eventSave.bind(this, "group"));
      this.subscribe("page-changed", this.eventSave.bind(this, "page"));
      this.subscribe("column-resized", this.eventSave.bind(this, "columns"));
      this.subscribe("layout-refreshed", this.eventSave.bind(this, "columns"));
    }

    this.registerTableFunction("getColumnLayout", this.getColumnLayout.bind(this));
    this.registerTableFunction("setColumnLayout", this.setColumnLayout.bind(this));
  }

  eventSave(type) {
    if (this.config[type]) {
      this.save(type);
    }
  }

  tableBuilt() {
    var sorters, filters;

    if (this.config.sort) {
      sorters = this.load("sort");

      if (!sorters === false) {
        this.table.options.initialSort = sorters;
      }
    }

    if (this.config.filter) {
      filters = this.load("filter");

      if (!filters === false) {
        this.table.options.initialFilter = filters;
      }
    }
  }

  tableRedraw(force) {
    if (force && this.config.columns) {
      this.save("columns");
    }
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////


  getColumnLayout() {
    return this.parseColumns(this.table.columnManager.getColumns());
  }

  setColumnLayout(layout) {
    this.table.columnManager.setColumns(this.mergeDefinition(this.table.options.columns, layout));
    return true;
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  initializeColumn(column) {
    var def, keys;

    if (this.config.columns) {
      this.defWatcherBlock = true;
      def = column.getDefinition();
      keys = this.config.columns === true ? Object.keys(def) : this.config.columns;
      keys.forEach(key => {
        var props = Object.getOwnPropertyDescriptor(def, key);
        var value = def[key];

        if (props) {
          Object.defineProperty(def, key, {
            set: function (newValue) {
              value = newValue;

              if (!this.defWatcherBlock) {
                this.save("columns");
              }

              if (props.set) {
                props.set(newValue);
              }
            },
            get: function () {
              if (props.get) {
                props.get();
              }

              return value;
            }
          });
        }
      });
      this.defWatcherBlock = false;
    }
  } //load saved definitions


  load(type, current) {
    var data = this.retrieveData(type);

    if (current) {
      data = data ? this.mergeDefinition(current, data) : current;
    }

    return data;
  } //retrieve data from memory


  retrieveData(type) {
    return this.readFunc ? this.readFunc(this.id, type) : false;
  } //merge old and new column definitions


  mergeDefinition(oldCols, newCols) {
    var output = [];
    newCols = newCols || [];
    newCols.forEach((column, to) => {
      var from = this._findColumn(oldCols, column),
          keys;

      if (from) {
        if (this.config.columns === true || this.config.columns == undefined) {
          keys = Object.keys(from);
          keys.push("width");
        } else {
          keys = this.config.columns;
        }

        keys.forEach(key => {
          if (key !== "columns" && typeof column[key] !== "undefined") {
            from[key] = column[key];
          }
        });

        if (from.columns) {
          from.columns = this.mergeDefinition(from.columns, column.columns);
        }

        output.push(from);
      }
    });
    oldCols.forEach((column, i) => {
      var from = this._findColumn(newCols, column);

      if (!from) {
        if (output.length > i) {
          output.splice(i, 0, column);
        } else {
          output.push(column);
        }
      }
    });
    return output;
  } //find matching columns


  _findColumn(columns, subject) {
    var type = subject.columns ? "group" : subject.field ? "field" : "object";
    return columns.find(function (col) {
      switch (type) {
        case "group":
          return col.title === subject.title && col.columns.length === subject.columns.length;

        case "field":
          return col.field === subject.field;

        case "object":
          return col === subject;
      }
    });
  } //save data


  save(type) {
    var data = {};

    switch (type) {
      case "columns":
        data = this.parseColumns(this.table.columnManager.getColumns());
        break;

      case "filter":
        data = this.table.modules.filter.getFilters();
        break;

      case "sort":
        data = this.validateSorters(this.table.modules.sort.getSort());
        break;

      case "group":
        data = this.getGroupConfig();
        break;

      case "page":
        data = this.getPageConfig();
        break;
    }

    if (this.writeFunc) {
      this.writeFunc(this.id, type, data);
    }
  } //ensure sorters contain no function data


  validateSorters(data) {
    data.forEach(function (item) {
      item.column = item.field;
      delete item.field;
    });
    return data;
  }

  getGroupConfig() {
    var data = {};

    if (this.config.group) {
      if (this.config.group === true || this.config.group.groupBy) {
        data.groupBy = this.table.options.groupBy;
      }

      if (this.config.group === true || this.config.group.groupStartOpen) {
        data.groupStartOpen = this.table.options.groupStartOpen;
      }

      if (this.config.group === true || this.config.group.groupHeader) {
        data.groupHeader = this.table.options.groupHeader;
      }
    }

    return data;
  }

  getPageConfig() {
    var data = {};

    if (this.config.page) {
      if (this.config.page === true || this.config.page.size) {
        data.paginationSize = this.table.modules.page.getPageSize();
      }

      if (this.config.page === true || this.config.page.page) {
        data.paginationInitialPage = this.table.modules.page.getPage();
      }
    }

    return data;
  } //parse columns for data to store


  parseColumns(columns) {
    var definitions = [],
        excludedKeys = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];
    columns.forEach(column => {
      var defStore = {},
          colDef = column.getDefinition(),
          keys;

      if (column.isGroup) {
        defStore.title = colDef.title;
        defStore.columns = this.parseColumns(column.getColumns());
      } else {
        defStore.field = column.getField();

        if (this.config.columns === true || this.config.columns == undefined) {
          keys = Object.keys(colDef);
          keys.push("width");
          keys.push("visible");
        } else {
          keys = this.config.columns;
        }

        keys.forEach(key => {
          switch (key) {
            case "width":
              defStore.width = column.getWidth();
              break;

            case "visible":
              defStore.visible = column.visible;
              break;

            default:
              if (typeof colDef[key] !== "function" && excludedKeys.indexOf(key) === -1) {
                defStore[key] = colDef[key];
              }

          }
        });
      }

      definitions.push(defStore);
    });
    return definitions;
  }

}

exports.PersistenceModule = Persistence;
Persistence.moduleName = "persistence";
Persistence.moduleInitOrder = -10; //load defaults

Persistence.readers = defaultReaders;
Persistence.writers = defaultWriters;

class Popup$1 extends Module {
  constructor(table) {
    super(table);
    this.columnSubscribers = {};
    this.registerTableOption("rowContextPopup", false);
    this.registerTableOption("rowClickPopup", false);
    this.registerTableOption("groupContextPopup", false);
    this.registerTableOption("groupClickPopup", false);
    this.registerColumnOption("headerContextPopup");
    this.registerColumnOption("headerClickPopup");
    this.registerColumnOption("headerPopup");
    this.registerColumnOption("headerPopupIcon");
    this.registerColumnOption("contextPopup");
    this.registerColumnOption("clickPopup");
  }

  initialize() {
    this.initializeRowWatchers();
    this.initializeGroupWatchers();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }

  initializeRowWatchers() {
    if (this.table.options.rowContextPopup) {
      this.subscribe("row-contextmenu", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup));
      this.table.on("rowTapHold", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup));
    }

    if (this.table.options.rowClickPopup) {
      this.subscribe("row-click", this.loadPopupEvent.bind(this, this.table.options.rowClickPopup));
    }
  }

  initializeGroupWatchers() {
    if (this.table.options.groupContextPopup) {
      this.subscribe("group-contextmenu", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup));
      this.table.on("groupTapHold", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup));
    }

    if (this.table.options.groupClickPopup) {
      this.subscribe("group-click", this.loadPopupEvent.bind(this, this.table.options.groupClickPopup));
    }
  }

  initializeColumn(column) {
    var def = column.definition; //handle column events

    if (def.headerContextPopup && !this.columnSubscribers.headerContextPopup) {
      this.columnSubscribers.headerContextPopup = this.loadPopupTableColumnEvent.bind(this, "headerContextPopup");
      this.subscribe("column-contextmenu", this.columnSubscribers.headerContextPopup);
      this.table.on("headerTapHold", this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"));
    }

    if (def.headerClickPopup && !this.columnSubscribers.headerClickPopup) {
      this.columnSubscribers.headerClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerClickPopup");
      this.subscribe("column-click", this.columnSubscribers.headerClickPopup);
    }

    if (def.headerPopup) {
      this.initializeColumnHeaderPopup(column);
    } //handle cell events


    if (def.contextPopup && !this.columnSubscribers.contextPopup) {
      this.columnSubscribers.contextPopup = this.loadPopupTableCellEvent.bind(this, "contextPopup");
      this.subscribe("cell-contextmenu", this.columnSubscribers.contextPopup);
      this.table.on("cellTapHold", this.loadPopupTableCellEvent.bind(this, "contextPopup"));
    }

    if (def.clickPopup && !this.columnSubscribers.clickPopup) {
      this.columnSubscribers.clickPopup = this.loadPopupTableCellEvent.bind(this, "clickPopup");
      this.subscribe("cell-click", this.columnSubscribers.clickPopup);
    }
  }

  initializeColumnHeaderPopup(column) {
    var icon = column.definition.headerPopupIcon,
        headerPopupEl;
    headerPopupEl = document.createElement("span");
    headerPopupEl.classList.add("tabulator-header-popup-button");

    if (icon) {
      if (typeof icon === "function") {
        icon = icon(column.getComponent());
      }

      if (icon instanceof HTMLElement) {
        headerPopupEl.appendChild(icon);
      } else {
        headerPopupEl.innerHTML = icon;
      }
    } else {
      headerPopupEl.innerHTML = "&vellip;";
    }

    headerPopupEl.addEventListener("click", e => {
      e.stopPropagation();
      e.preventDefault();
      this.loadPopupEvent(column.definition.headerPopup, e, column);
    });
    column.titleElement.insertBefore(headerPopupEl, column.titleElement.firstChild);
  }

  loadPopupTableCellEvent(option, e, cell) {
    if (cell._cell) {
      cell = cell._cell;
    }

    if (cell.column.definition[option]) {
      this.loadPopupEvent(cell.column.definition[option], e, cell);
    }
  }

  loadPopupTableColumnEvent(option, e, column) {
    if (column._column) {
      column = column._column;
    }

    if (column.definition[option]) {
      this.loadPopupEvent(column.definition[option], e, column);
    }
  }

  loadPopupEvent(contents, e, component) {
    var renderedCallback;

    function onRendered(callback) {
      renderedCallback = callback;
    }

    if (component._group) {
      component = component._group;
    } else if (component._row) {
      component = component._row;
    }

    contents = typeof contents == "function" ? contents.call(this.table, e, component.getComponent(), onRendered) : contents;
    this.loadPopup(e, component, contents, renderedCallback);
  }

  loadPopup(e, component, contents, renderedCallback) {
    var touch = !(e instanceof MouseEvent),
        contentsEl,
        popup;

    if (contents instanceof HTMLElement) {
      contentsEl = contents;
    } else {
      contentsEl = document.createElement("div");
      contentsEl.innerHTML = contents;
    }

    contentsEl.classList.add("tabulator-popup");
    contentsEl.addEventListener("click", e => {
      e.stopPropagation();
    });

    if (!touch) {
      e.preventDefault();
    }

    popup = this.popup(contentsEl);

    if (typeof renderedCallback === "function") {
      popup.renderCallback(renderedCallback);
    }

    popup.show(e).hideOnBlur(() => {
      this.dispatchExternal("popupClosed", component.getComponent());
    });
    this.dispatchExternal("popupOpened", component.getComponent());
  }

}

exports.PopupModule = Popup$1;
Popup$1.moduleName = "popup";

class Print extends Module {
  constructor(table) {
    super(table);
    this.element = false;
    this.manualBlock = false;
    this.registerTableOption("printAsHtml", false); //enable print as html

    this.registerTableOption("printFormatter", false); //printing page formatter

    this.registerTableOption("printHeader", false); //page header contents

    this.registerTableOption("printFooter", false); //page footer contents

    this.registerTableOption("printStyled", true); //enable print as html styling

    this.registerTableOption("printRowRange", "visible"); //restrict print to visible rows only

    this.registerTableOption("printConfig", {}); //print config options

    this.registerColumnOption("print");
    this.registerColumnOption("titlePrint");
  }

  initialize() {
    if (this.table.options.printAsHtml) {
      window.addEventListener("beforeprint", this.replaceTable.bind(this));
      window.addEventListener("afterprint", this.cleanup.bind(this));
    }

    this.registerTableFunction("print", this.printFullscreen.bind(this));
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  replaceTable() {
    if (!this.manualBlock) {
      this.element = document.createElement("div");
      this.element.classList.add("tabulator-print-table");
      this.element.appendChild(this.table.modules.export.generateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print"));
      this.table.element.style.display = "none";
      this.table.element.parentNode.insertBefore(this.element, this.table.element);
    }
  }

  cleanup() {
    document.body.classList.remove("tabulator-print-fullscreen-hide");

    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
      this.table.element.style.display = "";
    }
  }

  printFullscreen(visible, style, config) {
    var scrollX = window.scrollX,
        scrollY = window.scrollY,
        headerEl = document.createElement("div"),
        footerEl = document.createElement("div"),
        tableEl = this.table.modules.export.generateTable(typeof config != "undefined" ? config : this.table.options.printConfig, typeof style != "undefined" ? style : this.table.options.printStyled, visible || this.table.options.printRowRange, "print"),
        headerContent,
        footerContent;
    this.manualBlock = true;
    this.element = document.createElement("div");
    this.element.classList.add("tabulator-print-fullscreen");

    if (this.table.options.printHeader) {
      headerEl.classList.add("tabulator-print-header");
      headerContent = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader;

      if (typeof headerContent == "string") {
        headerEl.innerHTML = headerContent;
      } else {
        headerEl.appendChild(headerContent);
      }

      this.element.appendChild(headerEl);
    }

    this.element.appendChild(tableEl);

    if (this.table.options.printFooter) {
      footerEl.classList.add("tabulator-print-footer");
      footerContent = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter;

      if (typeof footerContent == "string") {
        footerEl.innerHTML = footerContent;
      } else {
        footerEl.appendChild(footerContent);
      }

      this.element.appendChild(footerEl);
    }

    document.body.classList.add("tabulator-print-fullscreen-hide");
    document.body.appendChild(this.element);

    if (this.table.options.printFormatter) {
      this.table.options.printFormatter(this.element, tableEl);
    }

    window.print();
    this.cleanup();
    window.scrollTo(scrollX, scrollY);
    this.manualBlock = false;
  }

}

exports.PrintModule = Print;
Print.moduleName = "print";

class ReactiveData extends Module {
  constructor(table) {
    super(table);
    this.data = false;
    this.blocked = false; //block reactivity while performing update

    this.origFuncs = {}; // hold original data array functions to allow replacement after data is done with

    this.currentVersion = 0;
    this.registerTableOption("reactiveData", false); //enable data reactivity
  }

  initialize() {
    if (this.table.options.reactiveData) {
      this.subscribe("cell-value-save-before", this.block.bind(this, "cellsave"));
      this.subscribe("cell-value-save-after", this.unblock.bind(this, "cellsave"));
      this.subscribe("row-data-save-before", this.block.bind(this, "rowsave"));
      this.subscribe("row-data-save-after", this.unblock.bind(this, "rowsave"));
      this.subscribe("row-data-init-after", this.watchRow.bind(this));
      this.subscribe("data-processing", this.watchData.bind(this));
      this.subscribe("table-destroy", this.unwatchData.bind(this));
    }
  }

  watchData(data) {
    var self = this,
        version;
    this.currentVersion++;
    version = this.currentVersion;
    this.unwatchData();
    this.data = data; //override array push function

    this.origFuncs.push = data.push;
    Object.defineProperty(this.data, "push", {
      enumerable: false,
      configurable: true,
      value: function () {
        var args = Array.from(arguments),
            result;

        if (!self.blocked && version === self.currentVersion) {
          self.block("data-push");
          args.forEach(arg => {
            self.table.rowManager.addRowActual(arg, false);
          });
          result = self.origFuncs.push.apply(data, arguments);
          self.unblock("data-push");
        }

        return result;
      }
    }); //override array unshift function

    this.origFuncs.unshift = data.unshift;
    Object.defineProperty(this.data, "unshift", {
      enumerable: false,
      configurable: true,
      value: function () {
        var args = Array.from(arguments),
            result;

        if (!self.blocked && version === self.currentVersion) {
          self.block("data-unshift");
          args.forEach(arg => {
            self.table.rowManager.addRowActual(arg, true);
          });
          result = self.origFuncs.unshift.apply(data, arguments);
          self.unblock("data-unshift");
        }

        return result;
      }
    }); //override array shift function

    this.origFuncs.shift = data.shift;
    Object.defineProperty(this.data, "shift", {
      enumerable: false,
      configurable: true,
      value: function () {
        var row, result;

        if (!self.blocked && version === self.currentVersion) {
          self.block("data-shift");

          if (self.data.length) {
            row = self.table.rowManager.getRowFromDataObject(self.data[0]);

            if (row) {
              row.deleteActual();
            }
          }

          result = self.origFuncs.shift.call(data);
          self.unblock("data-shift");
        }

        return result;
      }
    }); //override array pop function

    this.origFuncs.pop = data.pop;
    Object.defineProperty(this.data, "pop", {
      enumerable: false,
      configurable: true,
      value: function () {
        var row, result;

        if (!self.blocked && version === self.currentVersion) {
          self.block("data-pop");

          if (self.data.length) {
            row = self.table.rowManager.getRowFromDataObject(self.data[self.data.length - 1]);

            if (row) {
              row.deleteActual();
            }
          }

          result = self.origFuncs.pop.call(data);
          self.unblock("data-pop");
        }

        return result;
      }
    }); //override array splice function

    this.origFuncs.splice = data.splice;
    Object.defineProperty(this.data, "splice", {
      enumerable: false,
      configurable: true,
      value: function () {
        var args = Array.from(arguments),
            start = args[0] < 0 ? data.length + args[0] : args[0],
            end = args[1],
            newRows = args[2] ? args.slice(2) : false,
            startRow,
            result;

        if (!self.blocked && version === self.currentVersion) {
          self.block("data-splice"); //add new rows

          if (newRows) {
            startRow = data[start] ? self.table.rowManager.getRowFromDataObject(data[start]) : false;

            if (startRow) {
              newRows.forEach(rowData => {
                self.table.rowManager.addRowActual(rowData, true, startRow, true);
              });
            } else {
              newRows = newRows.slice().reverse();
              newRows.forEach(rowData => {
                self.table.rowManager.addRowActual(rowData, true, false, true);
              });
            }
          } //delete removed rows


          if (end !== 0) {
            var oldRows = data.slice(start, typeof args[1] === "undefined" ? args[1] : start + end);
            oldRows.forEach((rowData, i) => {
              var row = self.table.rowManager.getRowFromDataObject(rowData);

              if (row) {
                row.deleteActual(i !== oldRows.length - 1);
              }
            });
          }

          if (newRows || end !== 0) {
            self.table.rowManager.reRenderInPosition();
          }

          result = self.origFuncs.splice.apply(data, arguments);
          self.unblock("data-splice");
        }

        return result;
      }
    });
  }

  unwatchData() {
    if (this.data !== false) {
      for (var key in this.origFuncs) {
        Object.defineProperty(this.data, key, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: this.origFuncs.key
        });
      }
    }
  }

  watchRow(row) {
    var data = row.getData();

    for (var key in data) {
      this.watchKey(row, data, key);
    }

    if (this.table.options.dataTree) {
      this.watchTreeChildren(row);
    }
  }

  watchTreeChildren(row) {
    var self = this,
        childField = row.getData()[this.table.options.dataTreeChildField],
        origFuncs = {};

    if (childField) {
      origFuncs.push = childField.push;
      Object.defineProperty(childField, "push", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-push");
            var result = origFuncs.push.apply(childField, arguments);
            this.rebuildTree(row);
            self.unblock("tree-push");
          }

          return result;
        }
      });
      origFuncs.unshift = childField.unshift;
      Object.defineProperty(childField, "unshift", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-unshift");
            var result = origFuncs.unshift.apply(childField, arguments);
            this.rebuildTree(row);
            self.unblock("tree-unshift");
          }

          return result;
        }
      });
      origFuncs.shift = childField.shift;
      Object.defineProperty(childField, "shift", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-shift");
            var result = origFuncs.shift.call(childField);
            this.rebuildTree(row);
            self.unblock("tree-shift");
          }

          return result;
        }
      });
      origFuncs.pop = childField.pop;
      Object.defineProperty(childField, "pop", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-pop");
            var result = origFuncs.pop.call(childField);
            this.rebuildTree(row);
            self.unblock("tree-pop");
          }

          return result;
        }
      });
      origFuncs.splice = childField.splice;
      Object.defineProperty(childField, "splice", {
        enumerable: false,
        configurable: true,
        value: () => {
          if (!self.blocked) {
            self.block("tree-splice");
            var result = origFuncs.splice.apply(childField, arguments);
            this.rebuildTree(row);
            self.unblock("tree-splice");
          }

          return result;
        }
      });
    }
  }

  rebuildTree(row) {
    this.table.modules.dataTree.initializeRow(row);
    this.table.modules.dataTree.layoutRow(row);
    this.table.rowManager.refreshActiveData("tree", false, true);
  }

  watchKey(row, data, key) {
    var self = this,
        props = Object.getOwnPropertyDescriptor(data, key),
        value = data[key],
        version = this.currentVersion;
    Object.defineProperty(data, key, {
      set: newValue => {
        value = newValue;

        if (!self.blocked && version === self.currentVersion) {
          self.block("key");
          var update = {};
          update[key] = newValue;
          row.updateData(update);
          self.unblock("key");
        }

        if (props.set) {
          props.set(newValue);
        }
      },
      get: () => {
        if (props.get) {
          props.get();
        }

        return value;
      }
    });
  }

  unwatchRow(row) {
    var data = row.getData();

    for (var key in data) {
      Object.defineProperty(data, key, {
        value: data[key]
      });
    }
  }

  block(key) {
    if (!this.blocked) {
      this.blocked = key;
    }
  }

  unblock(key) {
    if (this.blocked === key) {
      this.blocked = false;
    }
  }

}

exports.ReactiveDataModule = ReactiveData;
ReactiveData.moduleName = "reactiveData";

class ResizeColumns extends Module {
  constructor(table) {
    super(table);
    this.startColumn = false;
    this.startX = false;
    this.startWidth = false;
    this.latestX = false;
    this.handle = null;
    this.initialNextColumn = null;
    this.nextColumn = null;
    this.initialized = false;
    this.registerColumnOption("resizable", true);
    this.registerTableOption("resizableColumnFit", false);
  }

  initialize() {
    this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
  }

  initializeEventWatchers() {
    if (!this.initialized) {
      this.subscribe("cell-rendered", this.layoutCellHandles.bind(this));
      this.subscribe("cell-delete", this.deInitializeComponent.bind(this));
      this.subscribe("cell-height", this.resizeHandle.bind(this));
      this.subscribe("column-moved", this.columnLayoutUpdated.bind(this));
      this.subscribe("column-hide", this.deInitializeColumn.bind(this));
      this.subscribe("column-show", this.columnLayoutUpdated.bind(this));
      this.subscribe("column-width", this.columnWidthUpdated.bind(this));
      this.subscribe("column-delete", this.deInitializeComponent.bind(this));
      this.subscribe("column-height", this.resizeHandle.bind(this));
      this.initialized = true;
    }
  }

  layoutCellHandles(cell) {
    if (cell.row.type === "row") {
      this.deInitializeComponent(cell);
      this.initializeColumn("cell", cell, cell.column, cell.element);
    }
  }

  layoutColumnHeader(column) {
    if (column.definition.resizable) {
      this.initializeEventWatchers();
      this.deInitializeComponent(column);
      this.initializeColumn("header", column, column, column.element);
    }
  }

  columnLayoutUpdated(column) {
    var prev = column.prevColumn();
    this.reinitializeColumn(column);

    if (prev) {
      this.reinitializeColumn(prev);
    }
  }

  columnWidthUpdated(column) {
    if (column.modules.frozen) {
      if (this.table.modules.frozenColumns.leftColumns.includes(column)) {
        this.table.modules.frozenColumns.leftColumns.forEach(col => {
          this.reinitializeColumn(col);
        });
      } else if (this.table.modules.frozenColumns.rightColumns.includes(column)) {
        this.table.modules.frozenColumns.rightColumns.forEach(col => {
          this.reinitializeColumn(col);
        });
      }
    }
  }

  reinitializeColumn(column) {
    var frozenOffset = column.modules.frozen ? column.modules.frozen.marginValue + column.getWidth() + "px" : false;
    column.cells.forEach(cell => {
      if (cell.modules.resize && cell.modules.resize.handleEl) {
        if (frozenOffset) {
          cell.modules.resize.handleEl.style.left = frozenOffset;
        }

        cell.element.after(cell.modules.resize.handleEl);
      }
    });

    if (column.modules.resize && column.modules.resize.handleEl) {
      if (frozenOffset) {
        column.modules.resize.handleEl.style.left = frozenOffset;
      }

      column.element.after(column.modules.resize.handleEl);
    }
  }

  initializeColumn(type, component, column, element) {
    var self = this,
        variableHeight = false,
        mode = column.definition.resizable,
        config = {},
        nearestColumn = column.getLastColumn(); //set column resize mode

    if (type === "header") {
      variableHeight = column.definition.formatter == "textarea" || column.definition.variableHeight;
      config = {
        variableHeight: variableHeight
      };
    }

    if ((mode === true || mode == type) && this._checkResizability(nearestColumn)) {
      var handle = document.createElement('span');
      handle.className = "tabulator-col-resize-handle";
      handle.addEventListener("click", function (e) {
        e.stopPropagation();
      });

      var handleDown = function (e) {
        self.startColumn = column;
        self.initialNextColumn = self.nextColumn = nearestColumn.nextColumn();

        self._mouseDown(e, nearestColumn, handle);
      };

      handle.addEventListener("mousedown", handleDown);
      handle.addEventListener("touchstart", handleDown, {
        passive: true
      }); //resize column on  double click

      handle.addEventListener("dblclick", e => {
        var oldWidth = nearestColumn.getWidth();
        e.stopPropagation();
        nearestColumn.reinitializeWidth(true);

        if (oldWidth !== nearestColumn.getWidth()) {
          self.dispatch("column-resized", nearestColumn);
          self.table.externalEvents.dispatch("columnResized", nearestColumn.getComponent());
        }
      });

      if (column.modules.frozen) {
        handle.style.position = "absolute";
        handle.style.left = column.modules.frozen.marginValue + column.getWidth() + "px";
      }

      config.handleEl = handle;

      if (element.parentNode && column.visible) {
        element.after(handle);
      }
    }

    component.modules.resize = config;
  }

  deInitializeColumn(column) {
    this.deInitializeComponent(column);
    column.cells.forEach(cell => {
      this.deInitializeComponent(cell);
    });
  }

  deInitializeComponent(component) {
    var handleEl;

    if (component.modules.resize) {
      handleEl = component.modules.resize.handleEl;

      if (handleEl && handleEl.parentElement) {
        handleEl.parentElement.removeChild(handleEl);
      }
    }
  }

  resizeHandle(component, height) {
    if (component.modules.resize && component.modules.resize.handleEl) {
      component.modules.resize.handleEl.style.height = height;
    }
  }

  _checkResizability(column) {
    return column.definition.resizable;
  }

  _mouseDown(e, column, handle) {
    var self = this;
    self.table.element.classList.add("tabulator-block-select");

    function mouseMove(e) {
      var x = typeof e.screenX === "undefined" ? e.touches[0].screenX : e.screenX,
          startDiff = x - self.startX,
          moveDiff = x - self.latestX,
          blockedBefore,
          blockedAfter;
      self.latestX = x;

      if (self.table.rtl) {
        startDiff = -startDiff;
        moveDiff = -moveDiff;
      }

      blockedBefore = column.width == column.minWidth || column.width == column.maxWidth;
      column.setWidth(self.startWidth + startDiff);
      blockedAfter = column.width == column.minWidth || column.width == column.maxWidth;

      if (moveDiff < 0) {
        self.nextColumn = self.initialNextColumn;
      }

      if (self.table.options.resizableColumnFit && self.nextColumn && !(blockedBefore && blockedAfter)) {
        let colWidth = self.nextColumn.getWidth();

        if (moveDiff > 0) {
          if (colWidth <= self.nextColumn.minWidth) {
            self.nextColumn = self.nextColumn.nextColumn();
          }
        }

        if (self.nextColumn) {
          self.nextColumn.setWidth(self.nextColumn.getWidth() - moveDiff);
        }
      }

      self.table.columnManager.rerenderColumns(true);

      if (!self.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
        column.checkCellHeights();
      }
    }

    function mouseUp(e) {
      //block editor from taking action while resizing is taking place
      if (self.startColumn.modules.edit) {
        self.startColumn.modules.edit.blocked = false;
      }

      if (self.table.browserSlow && column.modules.resize && column.modules.resize.variableHeight) {
        column.checkCellHeights();
      }

      document.body.removeEventListener("mouseup", mouseUp);
      document.body.removeEventListener("mousemove", mouseMove);
      handle.removeEventListener("touchmove", mouseMove);
      handle.removeEventListener("touchend", mouseUp);
      self.table.element.classList.remove("tabulator-block-select");

      if (self.startWidth !== column.getWidth()) {
        self.dispatch("column-resized", column);
        self.table.externalEvents.dispatch("columnResized", column.getComponent());
      }
    }

    e.stopPropagation(); //prevent resize from interfering with movable columns
    //block editor from taking action while resizing is taking place

    if (self.startColumn.modules.edit) {
      self.startColumn.modules.edit.blocked = true;
    }

    self.startX = typeof e.screenX === "undefined" ? e.touches[0].screenX : e.screenX;
    self.latestX = self.startX;
    self.startWidth = column.getWidth();
    document.body.addEventListener("mousemove", mouseMove);
    document.body.addEventListener("mouseup", mouseUp);
    handle.addEventListener("touchmove", mouseMove, {
      passive: true
    });
    handle.addEventListener("touchend", mouseUp);
  }

}

exports.ResizeColumnsModule = ResizeColumns;
ResizeColumns.moduleName = "resizeColumns";

class ResizeRows extends Module {
  constructor(table) {
    super(table);
    this.startColumn = false;
    this.startY = false;
    this.startHeight = false;
    this.handle = null;
    this.prevHandle = null;
    this.registerTableOption("resizableRows", false); //resizable rows
  }

  initialize() {
    if (this.table.options.resizableRows) {
      this.subscribe("row-layout-after", this.initializeRow.bind(this));
    }
  }

  initializeRow(row) {
    var self = this,
        rowEl = row.getElement();
    var handle = document.createElement('div');
    handle.className = "tabulator-row-resize-handle";
    var prevHandle = document.createElement('div');
    prevHandle.className = "tabulator-row-resize-handle prev";
    handle.addEventListener("click", function (e) {
      e.stopPropagation();
    });

    var handleDown = function (e) {
      self.startRow = row;

      self._mouseDown(e, row, handle);
    };

    handle.addEventListener("mousedown", handleDown);
    handle.addEventListener("touchstart", handleDown, {
      passive: true
    });
    prevHandle.addEventListener("click", function (e) {
      e.stopPropagation();
    });

    var prevHandleDown = function (e) {
      var prevRow = self.table.rowManager.prevDisplayRow(row);

      if (prevRow) {
        self.startRow = prevRow;

        self._mouseDown(e, prevRow, prevHandle);
      }
    };

    prevHandle.addEventListener("mousedown", prevHandleDown);
    prevHandle.addEventListener("touchstart", prevHandleDown, {
      passive: true
    });
    rowEl.appendChild(handle);
    rowEl.appendChild(prevHandle);
  }

  _mouseDown(e, row, handle) {
    var self = this;
    self.table.element.classList.add("tabulator-block-select");

    function mouseMove(e) {
      row.setHeight(self.startHeight + ((typeof e.screenY === "undefined" ? e.touches[0].screenY : e.screenY) - self.startY));
    }

    function mouseUp(e) {
      // //block editor from taking action while resizing is taking place
      // if(self.startColumn.modules.edit){
      // 	self.startColumn.modules.edit.blocked = false;
      // }
      document.body.removeEventListener("mouseup", mouseMove);
      document.body.removeEventListener("mousemove", mouseMove);
      handle.removeEventListener("touchmove", mouseMove);
      handle.removeEventListener("touchend", mouseUp);
      self.table.element.classList.remove("tabulator-block-select");
      self.dispatchExternal("rowResized", row.getComponent());
    }

    e.stopPropagation(); //prevent resize from interfering with movable columns
    //block editor from taking action while resizing is taking place
    // if(self.startColumn.modules.edit){
    // 	self.startColumn.modules.edit.blocked = true;
    // }

    self.startY = typeof e.screenY === "undefined" ? e.touches[0].screenY : e.screenY;
    self.startHeight = row.getHeight();
    document.body.addEventListener("mousemove", mouseMove);
    document.body.addEventListener("mouseup", mouseUp);
    handle.addEventListener("touchmove", mouseMove, {
      passive: true
    });
    handle.addEventListener("touchend", mouseUp);
  }

}

exports.ResizeRowsModule = ResizeRows;
ResizeRows.moduleName = "resizeRows";

class ResizeTable extends Module {
  constructor(table) {
    super(table);
    this.binding = false;
    this.visibilityObserver = false;
    this.resizeObserver = false;
    this.containerObserver = false;
    this.tableHeight = 0;
    this.tableWidth = 0;
    this.containerHeight = 0;
    this.containerWidth = 0;
    this.autoResize = false;
    this.visible = false;
    this.initialized = false;
    this.initialRedraw = false;
    this.registerTableOption("autoResize", true); //auto resize table
  }

  initialize() {
    if (this.table.options.autoResize) {
      var table = this.table,
          tableStyle;
      this.tableHeight = table.element.clientHeight;
      this.tableWidth = table.element.clientWidth;

      if (table.element.parentNode) {
        this.containerHeight = table.element.parentNode.clientHeight;
        this.containerWidth = table.element.parentNode.clientWidth;
      }

      if (typeof IntersectionObserver !== "undefined" && typeof ResizeObserver !== "undefined" && table.rowManager.getRenderMode() === "virtual") {
        this.initializeVisibilityObserver();
        this.autoResize = true;
        this.resizeObserver = new ResizeObserver(entry => {
          if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {
            var nodeHeight = Math.floor(entry[0].contentRect.height);
            var nodeWidth = Math.floor(entry[0].contentRect.width);

            if (this.tableHeight != nodeHeight || this.tableWidth != nodeWidth) {
              this.tableHeight = nodeHeight;
              this.tableWidth = nodeWidth;

              if (table.element.parentNode) {
                this.containerHeight = table.element.parentNode.clientHeight;
                this.containerWidth = table.element.parentNode.clientWidth;
              }

              this.redrawTable();
            }
          }
        });
        this.resizeObserver.observe(table.element);
        tableStyle = window.getComputedStyle(table.element);

        if (this.table.element.parentNode && !this.table.rowManager.fixedHeight && (tableStyle.getPropertyValue("max-height") || tableStyle.getPropertyValue("min-height"))) {
          this.containerObserver = new ResizeObserver(entry => {
            if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {
              var nodeHeight = Math.floor(entry[0].contentRect.height);
              var nodeWidth = Math.floor(entry[0].contentRect.width);

              if (this.containerHeight != nodeHeight || this.containerWidth != nodeWidth) {
                this.containerHeight = nodeHeight;
                this.containerWidth = nodeWidth;
                this.tableHeight = table.element.clientHeight;
                this.tableWidth = table.element.clientWidth;
              }

              this.redrawTable();
            }
          });
          this.containerObserver.observe(this.table.element.parentNode);
        }

        this.subscribe("table-resize", this.tableResized.bind(this));
      } else {
        this.binding = function () {
          if (!table.browserMobile || table.browserMobile && !table.modules.edit.currentCell) {
            table.columnManager.rerenderColumns(true);
            table.redraw();
          }
        };

        window.addEventListener("resize", this.binding);
      }

      this.subscribe("table-destroy", this.clearBindings.bind(this));
    }
  }

  initializeVisibilityObserver() {
    this.visibilityObserver = new IntersectionObserver(entries => {
      this.visible = entries[0].isIntersecting;

      if (!this.initialized) {
        this.initialized = true;
        this.initialRedraw = !this.visible;
      }

      if (this.visible) {
        this.redrawTable(this.initialRedraw);
        this.initialRedraw = false;
      }
    });
    this.visibilityObserver.observe(this.table.element);
  }

  redrawTable(force) {
    if (this.initialized && this.visible) {
      this.table.columnManager.rerenderColumns(true);
      this.table.redraw(force);
    }
  }

  tableResized() {
    this.table.rowManager.redraw();
  }

  clearBindings() {
    if (this.binding) {
      window.removeEventListener("resize", this.binding);
    }

    if (this.resizeObserver) {
      this.resizeObserver.unobserve(this.table.element);
    }

    if (this.visibilityObserver) {
      this.visibilityObserver.unobserve(this.table.element);
    }

    if (this.containerObserver) {
      this.containerObserver.unobserve(this.table.element.parentNode);
    }
  }

}

exports.ResizeTableModule = ResizeTable;
ResizeTable.moduleName = "resizeTable";

class ResponsiveLayout extends Module {
  constructor(table) {
    super(table);
    this.columns = [];
    this.hiddenColumns = [];
    this.mode = "";
    this.index = 0;
    this.collapseFormatter = [];
    this.collapseStartOpen = true;
    this.collapseHandleColumn = false;
    this.registerTableOption("responsiveLayout", false); //responsive layout flags

    this.registerTableOption("responsiveLayoutCollapseStartOpen", true); //start showing collapsed data

    this.registerTableOption("responsiveLayoutCollapseUseFormatters", true); //responsive layout collapse formatter

    this.registerTableOption("responsiveLayoutCollapseFormatter", false); //responsive layout collapse formatter

    this.registerColumnOption("responsive");
  } //generate responsive columns list


  initialize() {
    if (this.table.options.responsiveLayout) {
      this.subscribe("column-layout", this.initializeColumn.bind(this));
      this.subscribe("column-show", this.updateColumnVisibility.bind(this));
      this.subscribe("column-hide", this.updateColumnVisibility.bind(this));
      this.subscribe("columns-loaded", this.initializeResponsivity.bind(this));
      this.subscribe("column-moved", this.initializeResponsivity.bind(this));
      this.subscribe("column-add", this.initializeResponsivity.bind(this));
      this.subscribe("column-delete", this.initializeResponsivity.bind(this));
      this.subscribe("table-redrawing", this.tableRedraw.bind(this));

      if (this.table.options.responsiveLayout === "collapse") {
        this.subscribe("row-data-changed", this.generateCollapsedRowContent.bind(this));
        this.subscribe("row-init", this.initializeRow.bind(this));
        this.subscribe("row-layout", this.layoutRow.bind(this));
      }
    }
  }

  tableRedraw(force) {
    if (["fitColumns", "fitDataStretch"].indexOf(this.layoutMode()) === -1) {
      if (!force) {
        this.update();
      }
    }
  }

  initializeResponsivity() {
    var columns = [];
    this.mode = this.table.options.responsiveLayout;
    this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData;
    this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen;
    this.hiddenColumns = []; //determine level of responsivity for each column

    this.table.columnManager.columnsByIndex.forEach((column, i) => {
      if (column.modules.responsive) {
        if (column.modules.responsive.order && column.modules.responsive.visible) {
          column.modules.responsive.index = i;
          columns.push(column);

          if (!column.visible && this.mode === "collapse") {
            this.hiddenColumns.push(column);
          }
        }
      }
    }); //sort list by responsivity

    columns = columns.reverse();
    columns = columns.sort((a, b) => {
      var diff = b.modules.responsive.order - a.modules.responsive.order;
      return diff || b.modules.responsive.index - a.modules.responsive.index;
    });
    this.columns = columns;

    if (this.mode === "collapse") {
      this.generateCollapsedContent();
    } //assign collapse column


    for (let col of this.table.columnManager.columnsByIndex) {
      if (col.definition.formatter == "responsiveCollapse") {
        this.collapseHandleColumn = col;
        break;
      }
    }

    if (this.collapseHandleColumn) {
      if (this.hiddenColumns.length) {
        this.collapseHandleColumn.show();
      } else {
        this.collapseHandleColumn.hide();
      }
    }
  } //define layout information


  initializeColumn(column) {
    var def = column.getDefinition();
    column.modules.responsive = {
      order: typeof def.responsive === "undefined" ? 1 : def.responsive,
      visible: def.visible === false ? false : true
    };
  }

  initializeRow(row) {
    var el;

    if (row.type !== "calc") {
      el = document.createElement("div");
      el.classList.add("tabulator-responsive-collapse");
      row.modules.responsiveLayout = {
        element: el,
        open: this.collapseStartOpen
      };

      if (!this.collapseStartOpen) {
        el.style.display = 'none';
      }
    }
  }

  layoutRow(row) {
    var rowEl = row.getElement();

    if (row.modules.responsiveLayout) {
      rowEl.appendChild(row.modules.responsiveLayout.element);
      this.generateCollapsedRowContent(row);
    }
  } //update column visibility


  updateColumnVisibility(column, responsiveToggle) {
    if (!responsiveToggle && column.modules.responsive) {
      column.modules.responsive.visible = column.visible;
      this.initializeResponsivity();
    }
  }

  hideColumn(column) {
    var colCount = this.hiddenColumns.length;
    column.hide(false, true);

    if (this.mode === "collapse") {
      this.hiddenColumns.unshift(column);
      this.generateCollapsedContent();

      if (this.collapseHandleColumn && !colCount) {
        this.collapseHandleColumn.show();
      }
    }
  }

  showColumn(column) {
    var index;
    column.show(false, true); //set column width to prevent calculation loops on uninitialized columns

    column.setWidth(column.getWidth());

    if (this.mode === "collapse") {
      index = this.hiddenColumns.indexOf(column);

      if (index > -1) {
        this.hiddenColumns.splice(index, 1);
      }

      this.generateCollapsedContent();

      if (this.collapseHandleColumn && !this.hiddenColumns.length) {
        this.collapseHandleColumn.hide();
      }
    }
  } //redraw columns to fit space


  update() {
    var self = this,
        working = true;

    while (working) {
      let width = self.table.modules.layout.getMode() == "fitColumns" ? self.table.columnManager.getFlexBaseWidth() : self.table.columnManager.getWidth();
      let diff = (self.table.options.headerVisible ? self.table.columnManager.element.clientWidth : self.table.element.clientWidth) - width;

      if (diff < 0) {
        //table is too wide
        let column = self.columns[self.index];

        if (column) {
          self.hideColumn(column);
          self.index++;
        } else {
          working = false;
        }
      } else {
        //table has spare space
        let column = self.columns[self.index - 1];

        if (column) {
          if (diff > 0) {
            if (diff >= column.getWidth()) {
              self.showColumn(column);
              self.index--;
            } else {
              working = false;
            }
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      }

      if (!self.table.rowManager.activeRowsCount) {
        self.table.rowManager.renderEmptyScroll();
      }
    }
  }

  generateCollapsedContent() {
    var self = this,
        rows = this.table.rowManager.getDisplayRows();
    rows.forEach(function (row) {
      self.generateCollapsedRowContent(row);
    });
  }

  generateCollapsedRowContent(row) {
    var el, contents;

    if (row.modules.responsiveLayout) {
      el = row.modules.responsiveLayout.element;

      while (el.firstChild) el.removeChild(el.firstChild);

      contents = this.collapseFormatter(this.generateCollapsedRowData(row));

      if (contents) {
        el.appendChild(contents);
      }
    }
  }

  generateCollapsedRowData(row) {
    var self = this,
        data = row.getData(),
        output = [],
        mockCellComponent;
    this.hiddenColumns.forEach(function (column) {
      var value = column.getFieldValue(data);

      if (column.definition.title && column.field) {
        if (column.modules.format && self.table.options.responsiveLayoutCollapseUseFormatters) {
          mockCellComponent = {
            value: false,
            data: {},
            getValue: function () {
              return value;
            },
            getData: function () {
              return data;
            },
            getElement: function () {
              return document.createElement("div");
            },
            getRow: function () {
              return row.getComponent();
            },
            getColumn: function () {
              return column.getComponent();
            }
          };

          function onRendered(callback) {
            callback();
          }

          output.push({
            field: column.field,
            title: column.definition.title,
            value: column.modules.format.formatter.call(self.table.modules.format, mockCellComponent, column.modules.format.params, onRendered)
          });
        } else {
          output.push({
            field: column.field,
            title: column.definition.title,
            value: value
          });
        }
      }
    });
    return output;
  }

  formatCollapsedData(data) {
    var list = document.createElement("table");
    data.forEach(function (item) {
      var row = document.createElement("tr");
      var titleData = document.createElement("td");
      var valueData = document.createElement("td");
      var node_content;
      var titleHighlight = document.createElement("strong");
      titleData.appendChild(titleHighlight);
      this.langBind("columns|" + item.field, function (text) {
        titleHighlight.innerHTML = text || item.title;
      });

      if (item.value instanceof Node) {
        node_content = document.createElement("div");
        node_content.appendChild(item.value);
        valueData.appendChild(node_content);
      } else {
        valueData.innerHTML = item.value;
      }

      row.appendChild(titleData);
      row.appendChild(valueData);
      list.appendChild(row);
    }, this);
    return Object.keys(data).length ? list : "";
  }

}

exports.ResponsiveLayoutModule = ResponsiveLayout;
ResponsiveLayout.moduleName = "responsiveLayout";

class SelectRow extends Module {
  constructor(table) {
    super(table);
    this.selecting = false; //flag selecting in progress

    this.lastClickedRow = false; //last clicked row

    this.selectPrev = []; //hold previously selected element for drag drop selection

    this.selectedRows = []; //hold selected rows

    this.headerCheckboxElement = null; // hold header select element

    this.registerTableOption("selectable", "highlight"); //highlight rows on hover

    this.registerTableOption("selectableRangeMode", "drag"); //highlight rows on hover

    this.registerTableOption("selectableRollingSelection", true); //roll selection once maximum number of selectable rows is reached

    this.registerTableOption("selectablePersistence", true); // maintain selection when table view is updated

    this.registerTableOption("selectableCheck", function (data, row) {
      return true;
    }); //check whether row is selectable

    this.registerTableFunction("selectRow", this.selectRows.bind(this));
    this.registerTableFunction("deselectRow", this.deselectRows.bind(this));
    this.registerTableFunction("toggleSelectRow", this.toggleRow.bind(this));
    this.registerTableFunction("getSelectedRows", this.getSelectedRows.bind(this));
    this.registerTableFunction("getSelectedData", this.getSelectedData.bind(this)); //register component functions

    this.registerComponentFunction("row", "select", this.selectRows.bind(this));
    this.registerComponentFunction("row", "deselect", this.deselectRows.bind(this));
    this.registerComponentFunction("row", "toggleSelect", this.toggleRow.bind(this));
    this.registerComponentFunction("row", "isSelected", this.isRowSelected.bind(this));
  }

  initialize() {
    if (this.table.options.selectable !== false) {
      this.subscribe("row-init", this.initializeRow.bind(this));
      this.subscribe("row-deleting", this.rowDeleted.bind(this));
      this.subscribe("rows-wipe", this.clearSelectionData.bind(this));
      this.subscribe("rows-retrieve", this.rowRetrieve.bind(this));

      if (this.table.options.selectable && !this.table.options.selectablePersistence) {
        this.subscribe("data-refreshing", this.deselectRows.bind(this));
      }
    }
  }

  rowRetrieve(type, prevValue) {
    return type === "selected" ? this.selectedRows : prevValue;
  }

  rowDeleted(row) {
    this._deselectRow(row, true);
  }

  clearSelectionData(silent) {
    this.selecting = false;
    this.lastClickedRow = false;
    this.selectPrev = [];
    this.selectedRows = [];

    if (silent !== true) {
      this._rowSelectionChanged();
    }
  }

  initializeRow(row) {
    var self = this,
        element = row.getElement(); // trigger end of row selection

    var endSelect = function () {
      setTimeout(function () {
        self.selecting = false;
      }, 50);
      document.body.removeEventListener("mouseup", endSelect);
    };

    row.modules.select = {
      selected: false
    }; //set row selection class

    if (self.table.options.selectableCheck.call(this.table, row.getComponent())) {
      element.classList.add("tabulator-selectable");
      element.classList.remove("tabulator-unselectable");

      if (self.table.options.selectable && self.table.options.selectable != "highlight") {
        if (self.table.options.selectableRangeMode === "click") {
          element.addEventListener("click", this.handleComplexRowClick.bind(this, row));
        } else {
          element.addEventListener("click", function (e) {
            if (!self.table.modExists("edit") || !self.table.modules.edit.getCurrentCell()) {
              self.table._clearSelection();
            }

            if (!self.selecting) {
              self.toggleRow(row);
            }
          });
          element.addEventListener("mousedown", function (e) {
            if (e.shiftKey) {
              self.table._clearSelection();

              self.selecting = true;
              self.selectPrev = [];
              document.body.addEventListener("mouseup", endSelect);
              document.body.addEventListener("keyup", endSelect);
              self.toggleRow(row);
              return false;
            }
          });
          element.addEventListener("mouseenter", function (e) {
            if (self.selecting) {
              self.table._clearSelection();

              self.toggleRow(row);

              if (self.selectPrev[1] == row) {
                self.toggleRow(self.selectPrev[0]);
              }
            }
          });
          element.addEventListener("mouseout", function (e) {
            if (self.selecting) {
              self.table._clearSelection();

              self.selectPrev.unshift(row);
            }
          });
        }
      }
    } else {
      element.classList.add("tabulator-unselectable");
      element.classList.remove("tabulator-selectable");
    }
  }

  handleComplexRowClick(row, e) {
    if (e.shiftKey) {
      this.table._clearSelection();

      this.lastClickedRow = this.lastClickedRow || row;
      var lastClickedRowIdx = this.table.rowManager.getDisplayRowIndex(this.lastClickedRow);
      var rowIdx = this.table.rowManager.getDisplayRowIndex(row);
      var fromRowIdx = lastClickedRowIdx <= rowIdx ? lastClickedRowIdx : rowIdx;
      var toRowIdx = lastClickedRowIdx >= rowIdx ? lastClickedRowIdx : rowIdx;
      var rows = this.table.rowManager.getDisplayRows().slice(0);
      var toggledRows = rows.splice(fromRowIdx, toRowIdx - fromRowIdx + 1);

      if (e.ctrlKey || e.metaKey) {
        toggledRows.forEach(toggledRow => {
          if (toggledRow !== this.lastClickedRow) {
            if (this.table.options.selectable !== true && !this.isRowSelected(row)) {
              if (this.selectedRows.length < this.table.options.selectable) {
                this.toggleRow(toggledRow);
              }
            } else {
              this.toggleRow(toggledRow);
            }
          }
        });
        this.lastClickedRow = row;
      } else {
        this.deselectRows(undefined, true);

        if (this.table.options.selectable !== true) {
          if (toggledRows.length > this.table.options.selectable) {
            toggledRows = toggledRows.slice(0, this.table.options.selectable);
          }
        }

        this.selectRows(toggledRows);
      }

      this.table._clearSelection();
    } else if (e.ctrlKey || e.metaKey) {
      this.toggleRow(row);
      this.lastClickedRow = row;
    } else {
      this.deselectRows(undefined, true);
      this.selectRows(row);
      this.lastClickedRow = row;
    }
  } //toggle row selection


  toggleRow(row) {
    if (this.table.options.selectableCheck.call(this.table, row.getComponent())) {
      if (row.modules.select && row.modules.select.selected) {
        this._deselectRow(row);
      } else {
        this._selectRow(row);
      }
    }
  } //select a number of rows


  selectRows(rows) {
    var rowMatch;

    switch (typeof rows) {
      case "undefined":
        this.table.rowManager.rows.forEach(row => {
          this._selectRow(row, true, true);
        });

        this._rowSelectionChanged();

        break;

      case "string":
        rowMatch = this.table.rowManager.findRow(rows);

        if (rowMatch) {
          this._selectRow(rowMatch, true, true);
        } else {
          this.table.rowManager.getRows(rows).forEach(row => {
            this._selectRow(row, true, true);
          });
        }

        this._rowSelectionChanged();

        break;

      default:
        if (Array.isArray(rows)) {
          rows.forEach(row => {
            this._selectRow(row, true, true);
          });

          this._rowSelectionChanged();
        } else {
          this._selectRow(rows, false, true);
        }

        break;
    }
  } //select an individual row


  _selectRow(rowInfo, silent, force) {
    //handle max row count
    if (!isNaN(this.table.options.selectable) && this.table.options.selectable !== true && !force) {
      if (this.selectedRows.length >= this.table.options.selectable) {
        if (this.table.options.selectableRollingSelection) {
          this._deselectRow(this.selectedRows[0]);
        } else {
          return false;
        }
      }
    }

    var row = this.table.rowManager.findRow(rowInfo);

    if (row) {
      if (this.selectedRows.indexOf(row) == -1) {
        row.getElement().classList.add("tabulator-selected");

        if (!row.modules.select) {
          row.modules.select = {};
        }

        row.modules.select.selected = true;

        if (row.modules.select.checkboxEl) {
          row.modules.select.checkboxEl.checked = true;
        }

        this.selectedRows.push(row);

        if (this.table.options.dataTreeSelectPropagate) {
          this.childRowSelection(row, true);
        }

        this.dispatchExternal("rowSelected", row.getComponent());

        this._rowSelectionChanged(silent);
      }
    } else {
      if (!silent) {
        console.warn("Selection Error - No such row found, ignoring selection:" + rowInfo);
      }
    }
  }

  isRowSelected(row) {
    return this.selectedRows.indexOf(row) !== -1;
  } //deselect a number of rows


  deselectRows(rows, silent) {
    var self = this,
        rowCount;

    if (typeof rows == "undefined") {
      rowCount = self.selectedRows.length;

      for (let i = 0; i < rowCount; i++) {
        self._deselectRow(self.selectedRows[0], true);
      }

      if (rowCount) {
        self._rowSelectionChanged(silent);
      }
    } else {
      if (Array.isArray(rows)) {
        rows.forEach(function (row) {
          self._deselectRow(row, true);
        });

        self._rowSelectionChanged(silent);
      } else {
        self._deselectRow(rows, silent);
      }
    }
  } //deselect an individual row


  _deselectRow(rowInfo, silent) {
    var self = this,
        row = self.table.rowManager.findRow(rowInfo),
        index;

    if (row) {
      index = self.selectedRows.findIndex(function (selectedRow) {
        return selectedRow == row;
      });

      if (index > -1) {
        row.getElement().classList.remove("tabulator-selected");

        if (!row.modules.select) {
          row.modules.select = {};
        }

        row.modules.select.selected = false;

        if (row.modules.select.checkboxEl) {
          row.modules.select.checkboxEl.checked = false;
        }

        self.selectedRows.splice(index, 1);

        if (this.table.options.dataTreeSelectPropagate) {
          this.childRowSelection(row, false);
        }

        this.dispatchExternal("rowDeselected", row.getComponent());

        self._rowSelectionChanged(silent);
      }
    } else {
      if (!silent) {
        console.warn("Deselection Error - No such row found, ignoring selection:" + rowInfo);
      }
    }
  }

  getSelectedData() {
    var data = [];
    this.selectedRows.forEach(function (row) {
      data.push(row.getData());
    });
    return data;
  }

  getSelectedRows() {
    var rows = [];
    this.selectedRows.forEach(function (row) {
      rows.push(row.getComponent());
    });
    return rows;
  }

  _rowSelectionChanged(silent) {
    if (this.headerCheckboxElement) {
      if (this.selectedRows.length === 0) {
        this.headerCheckboxElement.checked = false;
        this.headerCheckboxElement.indeterminate = false;
      } else if (this.table.rowManager.rows.length === this.selectedRows.length) {
        this.headerCheckboxElement.checked = true;
        this.headerCheckboxElement.indeterminate = false;
      } else {
        this.headerCheckboxElement.indeterminate = true;
        this.headerCheckboxElement.checked = false;
      }
    }

    if (!silent) {
      this.dispatchExternal("rowSelectionChanged", this.getSelectedData(), this.getSelectedRows());
    }
  }

  registerRowSelectCheckbox(row, element) {
    if (!row._row.modules.select) {
      row._row.modules.select = {};
    }

    row._row.modules.select.checkboxEl = element;
  }

  registerHeaderSelectCheckbox(element) {
    this.headerCheckboxElement = element;
  }

  childRowSelection(row, select) {
    var children = this.table.modules.dataTree.getChildren(row, true);

    if (select) {
      for (let child of children) {
        this._selectRow(child, true);
      }
    } else {
      for (let child of children) {
        this._deselectRow(child, true);
      }
    }
  }

}

exports.SelectRowModule = SelectRow;
SelectRow.moduleName = "selectRow"; //sort numbers

function number$1(a, b, aRow, bRow, column, dir, params) {
  var alignEmptyValues = params.alignEmptyValues;
  var decimal = params.decimalSeparator;
  var thousand = params.thousandSeparator;
  var emptyAlign = 0;
  a = String(a);
  b = String(b);

  if (thousand) {
    a = a.split(thousand).join("");
    b = b.split(thousand).join("");
  }

  if (decimal) {
    a = a.split(decimal).join(".");
    b = b.split(decimal).join(".");
  }

  a = parseFloat(a);
  b = parseFloat(b); //handle non numeric values

  if (isNaN(a)) {
    emptyAlign = isNaN(b) ? 0 : -1;
  } else if (isNaN(b)) {
    emptyAlign = 1;
  } else {
    //compare valid values
    return a - b;
  } //fix empty values in position


  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }

  return emptyAlign;
} //sort strings


function string(a, b, aRow, bRow, column, dir, params) {
  var alignEmptyValues = params.alignEmptyValues;
  var emptyAlign = 0;
  var locale; //handle empty values

  if (!a) {
    emptyAlign = !b ? 0 : -1;
  } else if (!b) {
    emptyAlign = 1;
  } else {
    //compare valid values
    switch (typeof params.locale) {
      case "boolean":
        if (params.locale) {
          locale = this.langLocale();
        }

        break;

      case "string":
        locale = params.locale;
        break;
    }

    return String(a).toLowerCase().localeCompare(String(b).toLowerCase(), locale);
  } //fix empty values in position


  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }

  return emptyAlign;
} //sort datetime


function datetime$2(a, b, aRow, bRow, column, dir, params) {
  var DT = window.DateTime || luxon.DateTime;
  var format = params.format || "dd/MM/yyyy HH:mm:ss",
      alignEmptyValues = params.alignEmptyValues,
      emptyAlign = 0;

  if (typeof DT != "undefined") {
    if (!DT.isDateTime(a)) {
      if (format === "iso") {
        a = DT.fromISO(String(a));
      } else {
        a = DT.fromFormat(String(a), format);
      }
    }

    if (!DT.isDateTime(b)) {
      if (format === "iso") {
        b = DT.fromISO(String(b));
      } else {
        b = DT.fromFormat(String(b), format);
      }
    }

    if (!a.isValid) {
      emptyAlign = !b.isValid ? 0 : -1;
    } else if (!b.isValid) {
      emptyAlign = 1;
    } else {
      //compare valid values
      return a - b;
    } //fix empty values in position


    if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
      emptyAlign *= -1;
    }

    return emptyAlign;
  } else {
    console.error("Sort Error - 'datetime' sorter is dependant on luxon.js");
  }
} //sort date


function date$1(a, b, aRow, bRow, column, dir, params) {
  if (!params.format) {
    params.format = "dd/MM/yyyy";
  }

  return datetime$2.call(this, a, b, aRow, bRow, column, dir, params);
} //sort times


function time$1(a, b, aRow, bRow, column, dir, params) {
  if (!params.format) {
    params.format = "HH:mm";
  }

  return datetime$2.call(this, a, b, aRow, bRow, column, dir, params);
} //sort booleans


function boolean(a, b, aRow, bRow, column, dir, params) {
  var el1 = a === true || a === "true" || a === "True" || a === 1 ? 1 : 0;
  var el2 = b === true || b === "true" || b === "True" || b === 1 ? 1 : 0;
  return el1 - el2;
} //sort if element contains any data


function array(a, b, aRow, bRow, column, dir, params) {
  var type = params.type || "length",
      alignEmptyValues = params.alignEmptyValues,
      emptyAlign = 0;

  function calc(value) {
    var result;

    switch (type) {
      case "length":
        result = value.length;
        break;

      case "sum":
        result = value.reduce(function (c, d) {
          return c + d;
        });
        break;

      case "max":
        result = Math.max.apply(null, value);
        break;

      case "min":
        result = Math.min.apply(null, value);
        break;

      case "avg":
        result = value.reduce(function (c, d) {
          return c + d;
        }) / value.length;
        break;
    }

    return result;
  } //handle non array values


  if (!Array.isArray(a)) {
    emptyAlign = !Array.isArray(b) ? 0 : -1;
  } else if (!Array.isArray(b)) {
    emptyAlign = 1;
  } else {
    return calc(b) - calc(a);
  } //fix empty values in position


  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }

  return emptyAlign;
} //sort if element contains any data


function exists(a, b, aRow, bRow, column, dir, params) {
  var el1 = typeof a == "undefined" ? 0 : 1;
  var el2 = typeof b == "undefined" ? 0 : 1;
  return el1 - el2;
} //sort alpha numeric strings


function alphanum(as, bs, aRow, bRow, column, dir, params) {
  var a,
      b,
      a1,
      b1,
      i = 0,
      L,
      rx = /(\d+)|(\D+)/g,
      rd = /\d/;
  var alignEmptyValues = params.alignEmptyValues;
  var emptyAlign = 0; //handle empty values

  if (!as && as !== 0) {
    emptyAlign = !bs && bs !== 0 ? 0 : -1;
  } else if (!bs && bs !== 0) {
    emptyAlign = 1;
  } else {
    if (isFinite(as) && isFinite(bs)) return as - bs;
    a = String(as).toLowerCase();
    b = String(bs).toLowerCase();
    if (a === b) return 0;
    if (!(rd.test(a) && rd.test(b))) return a > b ? 1 : -1;
    a = a.match(rx);
    b = b.match(rx);
    L = a.length > b.length ? b.length : a.length;

    while (i < L) {
      a1 = a[i];
      b1 = b[i++];

      if (a1 !== b1) {
        if (isFinite(a1) && isFinite(b1)) {
          if (a1.charAt(0) === "0") a1 = "." + a1;
          if (b1.charAt(0) === "0") b1 = "." + b1;
          return a1 - b1;
        } else return a1 > b1 ? 1 : -1;
      }
    }

    return a.length > b.length;
  } //fix empty values in position


  if (alignEmptyValues === "top" && dir === "desc" || alignEmptyValues === "bottom" && dir === "asc") {
    emptyAlign *= -1;
  }

  return emptyAlign;
}

var defaultSorters = {
  number: number$1,
  string: string,
  date: date$1,
  time: time$1,
  datetime: datetime$2,
  boolean: boolean,
  array: array,
  exists: exists,
  alphanum: alphanum
};

class Sort extends Module {
  constructor(table) {
    super(table);
    this.sortList = []; //holder current sort

    this.changed = false; //has the sort changed since last render

    this.registerTableOption("sortMode", "local"); //local or remote sorting

    this.registerTableOption("initialSort", false); //initial sorting criteria

    this.registerTableOption("columnHeaderSortMulti", true); //multiple or single column sorting

    this.registerTableOption("sortOrderReverse", false); //reverse internal sort ordering

    this.registerTableOption("headerSortElement", "<div class='tabulator-arrow'></div>"); //header sort element

    this.registerColumnOption("sorter");
    this.registerColumnOption("sorterParams");
    this.registerColumnOption("headerSort", true);
    this.registerColumnOption("headerSortStartingDir");
    this.registerColumnOption("headerSortTristate");
  }

  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this));
    this.subscribe("table-built", this.tableBuilt.bind(this));
    this.registerDataHandler(this.sort.bind(this), 20);
    this.registerTableFunction("setSort", this.userSetSort.bind(this));
    this.registerTableFunction("getSorters", this.getSort.bind(this));
    this.registerTableFunction("clearSort", this.clearSort.bind(this));

    if (this.table.options.sortMode === "remote") {
      this.subscribe("data-params", this.remoteSortParams.bind(this));
    }
  }

  tableBuilt() {
    if (this.table.options.initialSort) {
      this.setSort(this.table.options.initialSort);
    }
  }

  remoteSortParams(data, config, silent, params) {
    var sorters = this.getSort();
    sorters.forEach(item => {
      delete item.column;
    });
    params.sort = sorters;
    return params;
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////


  userSetSort(sortList, dir) {
    this.setSort(sortList, dir); // this.table.rowManager.sorterRefresh();

    this.refreshSort();
  }

  clearSort() {
    this.clear(); // this.table.rowManager.sorterRefresh();

    this.refreshSort();
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //initialize column header for sorting


  initializeColumn(column) {
    var sorter = false,
        colEl,
        arrowEl;

    switch (typeof column.definition.sorter) {
      case "string":
        if (Sort.sorters[column.definition.sorter]) {
          sorter = Sort.sorters[column.definition.sorter];
        } else {
          console.warn("Sort Error - No such sorter found: ", column.definition.sorter);
        }

        break;

      case "function":
        sorter = column.definition.sorter;
        break;
    }

    column.modules.sort = {
      sorter: sorter,
      dir: "none",
      params: column.definition.sorterParams || {},
      startingDir: column.definition.headerSortStartingDir || "asc",
      tristate: column.definition.headerSortTristate
    };

    if (column.definition.headerSort !== false) {
      colEl = column.getElement();
      colEl.classList.add("tabulator-sortable");
      arrowEl = document.createElement("div");
      arrowEl.classList.add("tabulator-col-sorter");

      switch (this.table.options.headerSortElement) {
        case "function":
          //do nothing
          break;

        case "object":
          arrowEl.appendChild(this.table.options.headerSortElement);
          break;

        default:
          arrowEl.innerHTML = this.table.options.headerSortElement;
      } //create sorter arrow


      column.titleHolderElement.appendChild(arrowEl);
      column.modules.sort.element = arrowEl;
      this.setColumnHeaderSortIcon(column, "none"); //sort on click

      colEl.addEventListener("click", e => {
        var dir = "",
            sorters = [],
            match = false;

        if (column.modules.sort) {
          if (column.modules.sort.tristate) {
            if (column.modules.sort.dir == "none") {
              dir = column.modules.sort.startingDir;
            } else {
              if (column.modules.sort.dir == column.modules.sort.startingDir) {
                dir = column.modules.sort.dir == "asc" ? "desc" : "asc";
              } else {
                dir = "none";
              }
            }
          } else {
            switch (column.modules.sort.dir) {
              case "asc":
                dir = "desc";
                break;

              case "desc":
                dir = "asc";
                break;

              default:
                dir = column.modules.sort.startingDir;
            }
          }

          if (this.table.options.columnHeaderSortMulti && (e.shiftKey || e.ctrlKey)) {
            sorters = this.getSort();
            match = sorters.findIndex(sorter => {
              return sorter.field === column.getField();
            });

            if (match > -1) {
              sorters[match].dir = dir;

              if (match != sorters.length - 1) {
                match = sorters.splice(match, 1)[0];

                if (dir != "none") {
                  sorters.push(match);
                }
              }
            } else {
              if (dir != "none") {
                sorters.push({
                  column: column,
                  dir: dir
                });
              }
            } //add to existing sort


            this.setSort(sorters);
          } else {
            if (dir == "none") {
              this.clear();
            } else {
              //sort by column only
              this.setSort(column, dir);
            }
          } // this.table.rowManager.sorterRefresh(!this.sortList.length);


          this.refreshSort();
        }
      });
    }
  }

  refreshSort() {
    if (this.table.options.sortMode === "remote") {
      this.reloadData(null, false, false);
    } else {
      this.refreshData(true);
    } //TODO - Persist left position of row manager
    // left = this.scrollLeft;
    // this.scrollHorizontal(left);

  } //check if the sorters have changed since last use


  hasChanged() {
    var changed = this.changed;
    this.changed = false;
    return changed;
  } //return current sorters


  getSort() {
    var self = this,
        sorters = [];
    self.sortList.forEach(function (item) {
      if (item.column) {
        sorters.push({
          column: item.column.getComponent(),
          field: item.column.getField(),
          dir: item.dir
        });
      }
    });
    return sorters;
  } //change sort list and trigger sort


  setSort(sortList, dir) {
    var self = this,
        newSortList = [];

    if (!Array.isArray(sortList)) {
      sortList = [{
        column: sortList,
        dir: dir
      }];
    }

    sortList.forEach(function (item) {
      var column;
      column = self.table.columnManager.findColumn(item.column);

      if (column) {
        item.column = column;
        newSortList.push(item);
        self.changed = true;
      } else {
        console.warn("Sort Warning - Sort field does not exist and is being ignored: ", item.column);
      }
    });
    self.sortList = newSortList;
    this.dispatch("sort-changed");
  } //clear sorters


  clear() {
    this.setSort([]);
  } //find appropriate sorter for column


  findSorter(column) {
    var row = this.table.rowManager.activeRows[0],
        sorter = "string",
        field,
        value;

    if (row) {
      row = row.getData();
      field = column.getField();

      if (field) {
        value = column.getFieldValue(row);

        switch (typeof value) {
          case "undefined":
            sorter = "string";
            break;

          case "boolean":
            sorter = "boolean";
            break;

          default:
            if (!isNaN(value) && value !== "") {
              sorter = "number";
            } else {
              if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {
                sorter = "alphanum";
              }
            }

            break;
        }
      }
    }

    return Sort.sorters[sorter];
  } //work through sort list sorting data


  sort(data) {
    var self = this,
        sortList = this.table.options.sortOrderReverse ? self.sortList.slice().reverse() : self.sortList,
        sortListActual = [],
        rowComponents = [];

    if (this.subscribedExternal("dataSorting")) {
      this.dispatchExternal("dataSorting", self.getSort());
    }

    self.clearColumnHeaders();

    if (this.table.options.sortMode !== "remote") {
      //build list of valid sorters and trigger column specific callbacks before sort begins
      sortList.forEach(function (item, i) {
        var sortObj;

        if (item.column) {
          sortObj = item.column.modules.sort;

          if (sortObj) {
            //if no sorter has been defined, take a guess
            if (!sortObj.sorter) {
              sortObj.sorter = self.findSorter(item.column);
            }

            item.params = typeof sortObj.params === "function" ? sortObj.params(item.column.getComponent(), item.dir) : sortObj.params;
            sortListActual.push(item);
          }

          self.setColumnHeader(item.column, item.dir);
        }
      }); //sort data

      if (sortListActual.length) {
        self._sortItems(data, sortListActual);
      }
    } else {
      sortList.forEach(function (item, i) {
        self.setColumnHeader(item.column, item.dir);
      });
    }

    if (this.subscribedExternal("dataSorted")) {
      data.forEach(row => {
        rowComponents.push(row.getComponent());
      });
      this.dispatchExternal("dataSorted", self.getSort(), rowComponents);
    }

    return data;
  } //clear sort arrows on columns


  clearColumnHeaders() {
    this.table.columnManager.getRealColumns().forEach(column => {
      if (column.modules.sort) {
        column.modules.sort.dir = "none";
        column.getElement().setAttribute("aria-sort", "none");
        this.setColumnHeaderSortIcon(column, "none");
      }
    });
  } //set the column header sort direction


  setColumnHeader(column, dir) {
    column.modules.sort.dir = dir;
    column.getElement().setAttribute("aria-sort", dir === "asc" ? "ascending" : "descending");
    this.setColumnHeaderSortIcon(column, dir);
  }

  setColumnHeaderSortIcon(column, dir) {
    var sortEl = column.modules.sort.element,
        arrowEl;

    if (typeof this.table.options.headerSortElement === "function") {
      while (sortEl.firstChild) sortEl.removeChild(sortEl.firstChild);

      arrowEl = this.table.options.headerSortElement.call(this.table, column.getComponent(), dir);

      if (typeof arrowEl === "object") {
        sortEl.appendChild(arrowEl);
      } else {
        sortEl.innerHTML = arrowEl;
      }
    }
  } //sort each item in sort list


  _sortItems(data, sortList) {
    var sorterCount = sortList.length - 1;
    data.sort((a, b) => {
      var result;

      for (var i = sorterCount; i >= 0; i--) {
        let sortItem = sortList[i];
        result = this._sortRow(a, b, sortItem.column, sortItem.dir, sortItem.params);

        if (result !== 0) {
          break;
        }
      }

      return result;
    });
  } //process individual rows for a sort function on active data


  _sortRow(a, b, column, dir, params) {
    var el1Comp, el2Comp; //switch elements depending on search direction

    var el1 = dir == "asc" ? a : b;
    var el2 = dir == "asc" ? b : a;
    a = column.getFieldValue(el1.getData());
    b = column.getFieldValue(el2.getData());
    a = typeof a !== "undefined" ? a : "";
    b = typeof b !== "undefined" ? b : "";
    el1Comp = el1.getComponent();
    el2Comp = el2.getComponent();
    return column.modules.sort.sorter.call(this, a, b, el1Comp, el2Comp, column.getComponent(), dir, params);
  }

}

exports.SortModule = Sort;
Sort.moduleName = "sort"; //load defaults

Sort.sorters = defaultSorters;

class Tooltip extends Module {
  constructor(table) {
    super(table);
    this.tooltipSubscriber = null, this.headerSubscriber = null, this.timeout = null;
    this.popupInstance = null;
    this.registerTableOption("tooltipGenerationMode", undefined); //deprecated

    this.registerTableOption("tooltipDelay", 300);
    this.registerColumnOption("tooltip");
    this.registerColumnOption("headerTooltip");
  }

  initialize() {
    this.deprecatedOptionsCheck();
    this.subscribe("column-init", this.initializeColumn.bind(this));
  }

  deprecatedOptionsCheck() {
    this.deprecationCheckMsg("tooltipGenerationMode", "This option is no longer needed as tooltips are always generated on hover now");
  }

  initializeColumn(column) {
    if (column.definition.headerTooltip && !this.headerSubscriber) {
      this.headerSubscriber = true;
      this.subscribe("column-mousemove", this.mousemoveCheck.bind(this, "headerTooltip"));
      this.subscribe("column-mouseout", this.mouseoutCheck.bind(this, "headerTooltip"));
    }

    if (column.definition.tooltip && !this.tooltipSubscriber) {
      this.tooltipSubscriber = true;
      this.subscribe("cell-mousemove", this.mousemoveCheck.bind(this, "tooltip"));
      this.subscribe("cell-mouseout", this.mouseoutCheck.bind(this, "tooltip"));
    }
  }

  mousemoveCheck(action, e, component) {
    var tooltip = action === "tooltip" ? component.column.definition.tooltip : component.definition.headerTooltip;

    if (tooltip) {
      this.clearPopup();
      this.timeout = setTimeout(this.loadTooltip.bind(this, e, component, tooltip), this.table.options.tooltipDelay);
    }
  }

  mouseoutCheck(action, e, component) {
    if (!this.popupInstance) {
      this.clearPopup();
    }
  }

  clearPopup(action, e, component) {
    clearTimeout(this.timeout);
    this.timeout = null;

    if (this.popupInstance) {
      this.popupInstance.hide();
    }
  }

  loadTooltip(e, component, tooltip) {
    var contentsEl, renderedCallback, coords;

    function onRendered(callback) {
      renderedCallback = callback;
    }

    if (typeof tooltip === "function") {
      tooltip = tooltip(e, component.getComponent(), onRendered);
    }

    if (tooltip instanceof HTMLElement) {
      contentsEl = tooltip;
    } else {
      contentsEl = document.createElement("div");

      if (tooltip === true) {
        if (component instanceof Cell) {
          tooltip = component.value;
        } else {
          if (component.definition.field) {
            this.langBind("columns|" + component.definition.field, value => {
              contentsEl.innerHTML = tooltip = value || component.definition.title;
            });
          } else {
            tooltip = component.definition.title;
          }
        }
      }

      contentsEl.innerHTML = tooltip;
    }

    if (tooltip || tooltip === 0 || tooltip === false) {
      contentsEl.classList.add("tabulator-tooltip");
      contentsEl.addEventListener("mousemove", e => e.preventDefault());
      this.popupInstance = this.popup(contentsEl);

      if (typeof renderedCallback === "function") {
        this.popupInstance.renderCallback(renderedCallback);
      }

      coords = this.popupInstance.containerEventCoords(e);
      this.popupInstance.show(coords.x + 15, coords.y + 15).hideOnBlur(() => {
        this.dispatchExternal("TooltipClosed", component.getComponent());
        this.popupInstance = null;
      });
      this.dispatchExternal("TooltipOpened", component.getComponent());
    }
  }

}

exports.TooltipModule = Tooltip;
Tooltip.moduleName = "tooltip";
var defaultValidators = {
  //is integer
  integer: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    value = Number(value);
    return !isNaN(value) && isFinite(value) && Math.floor(value) === value;
  },
  //is float
  float: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    value = Number(value);
    return !isNaN(value) && isFinite(value) && value % 1 !== 0;
  },
  //must be a number
  numeric: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    return !isNaN(value);
  },
  //must be a string
  string: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    return isNaN(value);
  },
  //maximum value
  max: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    return parseFloat(value) <= parameters;
  },
  //minimum value
  min: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    return parseFloat(value) >= parameters;
  },
  //starts with  value
  starts: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    return String(value).toLowerCase().startsWith(String(parameters).toLowerCase());
  },
  //ends with  value
  ends: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    return String(value).toLowerCase().endsWith(String(parameters).toLowerCase());
  },
  //minimum string length
  minLength: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    return String(value).length >= parameters;
  },
  //maximum string length
  maxLength: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    return String(value).length <= parameters;
  },
  //in provided value list
  in: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    if (typeof parameters == "string") {
      parameters = parameters.split("|");
    }

    return parameters.indexOf(value) > -1;
  },
  //must match provided regex
  regex: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    var reg = new RegExp(parameters);
    return reg.test(value);
  },
  //value must be unique in this column
  unique: function (cell, value, parameters) {
    if (value === "" || value === null || typeof value === "undefined") {
      return true;
    }

    var unique = true;
    var cellData = cell.getData();

    var column = cell.getColumn()._getSelf();

    this.table.rowManager.rows.forEach(function (row) {
      var data = row.getData();

      if (data !== cellData) {
        if (value == column.getFieldValue(data)) {
          unique = false;
        }
      }
    });
    return unique;
  },
  //must have a value
  required: function (cell, value, parameters) {
    return value !== "" && value !== null && typeof value !== "undefined";
  }
};

class Validate extends Module {
  constructor(table) {
    super(table);
    this.invalidCells = [];
    this.registerTableOption("validationMode", "blocking");
    this.registerColumnOption("validator");
    this.registerTableFunction("getInvalidCells", this.getInvalidCells.bind(this));
    this.registerTableFunction("clearCellValidation", this.userClearCellValidation.bind(this));
    this.registerTableFunction("validate", this.userValidate.bind(this));
    this.registerComponentFunction("cell", "isValid", this.cellIsValid.bind(this));
    this.registerComponentFunction("cell", "clearValidation", this.clearValidation.bind(this));
    this.registerComponentFunction("cell", "validate", this.cellValidate.bind(this));
    this.registerComponentFunction("column", "validate", this.columnValidate.bind(this));
    this.registerComponentFunction("row", "validate", this.rowValidate.bind(this));
  }

  initialize() {
    this.subscribe("cell-delete", this.clearValidation.bind(this));
    this.subscribe("column-layout", this.initializeColumnCheck.bind(this));
    this.subscribe("edit-success", this.editValidate.bind(this));
    this.subscribe("edit-editor-clear", this.editorClear.bind(this));
    this.subscribe("edit-edited-clear", this.editedClear.bind(this));
  } ///////////////////////////////////
  ///////// Event Handling //////////
  ///////////////////////////////////


  editValidate(cell, value, previousValue) {
    var valid = this.table.options.validationMode !== "manual" ? this.validate(cell.column.modules.validate, cell, value) : true; // allow time for editor to make render changes then style cell

    if (valid !== true) {
      setTimeout(() => {
        cell.getElement().classList.add("tabulator-validation-fail");
        this.dispatchExternal("validationFailed", cell.getComponent(), value, valid);
      });
    }

    return valid;
  }

  editorClear(cell, cancelled) {
    if (cancelled) {
      if (cell.column.modules.validate) {
        this.cellValidate(cell);
      }
    }

    cell.getElement().classList.remove("tabulator-validation-fail");
  }

  editedClear(cell) {
    if (cell.modules.validate) {
      cell.modules.validate.invalid = false;
    }
  } ///////////////////////////////////
  ////////// Cell Functions /////////
  ///////////////////////////////////


  cellIsValid(cell) {
    return cell.modules.validate ? cell.modules.validate.invalid || true : true;
  }

  cellValidate(cell) {
    return this.validate(cell.column.modules.validate, cell, cell.getValue());
  } ///////////////////////////////////
  ///////// Column Functions ////////
  ///////////////////////////////////


  columnValidate(column) {
    var invalid = [];
    column.cells.forEach(cell => {
      if (this.cellValidate(cell) !== true) {
        invalid.push(cell.getComponent());
      }
    });
    return invalid.length ? invalid : true;
  } ///////////////////////////////////
  ////////// Row Functions //////////
  ///////////////////////////////////


  rowValidate(row) {
    var invalid = [];
    row.cells.forEach(cell => {
      if (this.cellValidate(cell) !== true) {
        invalid.push(cell.getComponent());
      }
    });
    return invalid.length ? invalid : true;
  } ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////


  userClearCellValidation(cells) {
    if (!cells) {
      cells = this.getInvalidCells();
    }

    if (!Array.isArray(cells)) {
      cells = [cells];
    }

    cells.forEach(cell => {
      this.clearValidation(cell._getSelf());
    });
  }

  userValidate(cells) {
    var output = []; //clear row data

    this.table.rowManager.rows.forEach(row => {
      row = row.getComponent();
      var valid = row.validate();

      if (valid !== true) {
        output = output.concat(valid);
      }
    });
    return output.length ? output : true;
  } ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////


  initializeColumnCheck(column) {
    if (typeof column.definition.validator !== "undefined") {
      this.initializeColumn(column);
    }
  } //validate


  initializeColumn(column) {
    var self = this,
        config = [],
        validator;

    if (column.definition.validator) {
      if (Array.isArray(column.definition.validator)) {
        column.definition.validator.forEach(item => {
          validator = self._extractValidator(item);

          if (validator) {
            config.push(validator);
          }
        });
      } else {
        validator = this._extractValidator(column.definition.validator);

        if (validator) {
          config.push(validator);
        }
      }

      column.modules.validate = config.length ? config : false;
    }
  }

  _extractValidator(value) {
    var type, params, pos;

    switch (typeof value) {
      case "string":
        pos = value.indexOf(':');

        if (pos > -1) {
          type = value.substring(0, pos);
          params = value.substring(pos + 1);
        } else {
          type = value;
        }

        return this._buildValidator(type, params);

      case "function":
        return this._buildValidator(value);

      case "object":
        return this._buildValidator(value.type, value.parameters);
    }
  }

  _buildValidator(type, params) {
    var func = typeof type == "function" ? type : Validate.validators[type];

    if (!func) {
      console.warn("Validator Setup Error - No matching validator found:", type);
      return false;
    } else {
      return {
        type: typeof type == "function" ? "function" : type,
        func: func,
        params: params
      };
    }
  }

  validate(validators, cell, value) {
    var self = this,
        failedValidators = [],
        invalidIndex = this.invalidCells.indexOf(cell);

    if (validators) {
      validators.forEach(item => {
        if (!item.func.call(self, cell.getComponent(), value, item.params)) {
          failedValidators.push({
            type: item.type,
            parameters: item.params
          });
        }
      });
    }

    if (!cell.modules.validate) {
      cell.modules.validate = {};
    }

    if (!failedValidators.length) {
      cell.modules.validate.invalid = false;
      cell.getElement().classList.remove("tabulator-validation-fail");

      if (invalidIndex > -1) {
        this.invalidCells.splice(invalidIndex, 1);
      }
    } else {
      cell.modules.validate.invalid = failedValidators;

      if (this.table.options.validationMode !== "manual") {
        cell.getElement().classList.add("tabulator-validation-fail");
      }

      if (invalidIndex == -1) {
        this.invalidCells.push(cell);
      }
    }

    return failedValidators.length ? failedValidators : true;
  }

  getInvalidCells() {
    var output = [];
    this.invalidCells.forEach(cell => {
      output.push(cell.getComponent());
    });
    return output;
  }

  clearValidation(cell) {
    var invalidIndex;

    if (cell.modules.validate && cell.modules.validate.invalid) {
      cell.getElement().classList.remove("tabulator-validation-fail");
      cell.modules.validate.invalid = false;
      invalidIndex = this.invalidCells.indexOf(cell);

      if (invalidIndex > -1) {
        this.invalidCells.splice(invalidIndex, 1);
      }
    }
  }

}

exports.ValidateModule = Validate;
Validate.moduleName = "validate"; //load defaults

Validate.validators = defaultValidators;
var modules = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AccessorModule: Accessor,
  AjaxModule: Ajax,
  ClipboardModule: Clipboard,
  ColumnCalcsModule: ColumnCalcs,
  DataTreeModule: DataTree,
  DownloadModule: Download,
  EditModule: Edit$1,
  ExportModule: Export,
  FilterModule: Filter,
  FormatModule: Format,
  FrozenColumnsModule: FrozenColumns,
  FrozenRowsModule: FrozenRows,
  GroupRowsModule: GroupRows,
  HistoryModule: History,
  HtmlTableImportModule: HtmlTableImport,
  ImportModule: Import,
  InteractionModule: Interaction,
  KeybindingsModule: Keybindings,
  MenuModule: Menu,
  MoveColumnsModule: MoveColumns,
  MoveRowsModule: MoveRows,
  MutatorModule: Mutator,
  PageModule: Page,
  PersistenceModule: Persistence,
  PopupModule: Popup$1,
  PrintModule: Print,
  ReactiveDataModule: ReactiveData,
  ResizeColumnsModule: ResizeColumns,
  ResizeRowsModule: ResizeRows,
  ResizeTableModule: ResizeTable,
  ResponsiveLayoutModule: ResponsiveLayout,
  SelectRowModule: SelectRow,
  SortModule: Sort,
  TooltipModule: Tooltip,
  ValidateModule: Validate
});
var defaultOptions = {
  debugEventsExternal: false,
  //flag to console log events
  debugEventsInternal: false,
  //flag to console log events
  debugInvalidOptions: true,
  //allow toggling of invalid option warnings
  debugInvalidComponentFuncs: true,
  //allow toggling of invalid component warnings
  debugInitialization: true,
  //allow toggling of pre initialization function call warnings
  debugDeprecation: true,
  //allow toggling of deprecation warnings
  height: false,
  //height of tabulator
  minHeight: false,
  //minimum height of tabulator
  maxHeight: false,
  //maximum height of tabulator
  columnHeaderVertAlign: "top",
  //vertical alignment of column headers
  popupContainer: false,
  columns: [],
  //store for colum header info
  columnDefaults: {},
  //store column default props
  data: false,
  //default starting data
  autoColumns: false,
  //build columns from data row structure
  autoColumnsDefinitions: false,
  nestedFieldSeparator: ".",
  //separator for nested data
  footerElement: false,
  //hold footer element
  index: "id",
  //filed for row index
  textDirection: "auto",
  addRowPos: "bottom",
  //position to insert blank rows, top|bottom
  headerVisible: true,
  //hide header
  renderVertical: "virtual",
  renderHorizontal: "basic",
  renderVerticalBuffer: 0,
  // set virtual DOM buffer size
  scrollToRowPosition: "top",
  scrollToRowIfVisible: true,
  scrollToColumnPosition: "left",
  scrollToColumnIfVisible: true,
  rowFormatter: false,
  rowFormatterPrint: null,
  rowFormatterClipboard: null,
  rowFormatterHtmlOutput: null,
  rowHeight: null,
  placeholder: false,
  dataLoader: true,
  dataLoaderLoading: false,
  dataLoaderError: false,
  dataLoaderErrorTimeout: 3000,
  dataSendParams: {},
  dataReceiveParams: {}
};

class OptionsList {
  constructor(table, msgType, defaults = {}) {
    this.table = table;
    this.msgType = msgType;
    this.registeredDefaults = Object.assign({}, defaults);
  }

  register(option, value) {
    this.registeredDefaults[option] = value;
  }

  generate(defaultOptions, userOptions = {}) {
    var output = Object.assign({}, this.registeredDefaults);
    Object.assign(output, defaultOptions);

    if (userOptions.debugInvalidOptions !== false || this.table.options.debugInvalidOptions) {
      for (let key in userOptions) {
        if (!output.hasOwnProperty(key)) {
          console.warn("Invalid " + this.msgType + " option:", key);
        }
      }
    }

    for (let key in output) {
      if (key in userOptions) {
        output[key] = userOptions[key];
      } else {
        if (Array.isArray(output[key])) {
          output[key] = Object.assign([], output[key]);
        } else if (typeof output[key] === "object" && output[key] !== null) {
          output[key] = Object.assign({}, output[key]);
        } else if (typeof output[key] === "undefined") {
          delete output[key];
        }
      }
    }

    return output;
  }

}

class Renderer extends CoreFeature {
  constructor(table) {
    super(table);
    this.elementVertical = table.rowManager.element;
    this.elementHorizontal = table.columnManager.element;
    this.tableElement = table.rowManager.tableElement;
    this.verticalFillMode = "fit"; // used by row manager to determine how to size the render area ("fit" - fits container to the contents, "fill" - fills the container without resizing it)
  } ///////////////////////////////////
  /////// Internal Bindings /////////
  ///////////////////////////////////


  initialize() {//initialize core functionality
  }

  clearRows() {//clear down existing rows layout
  }

  clearColumns() {//clear down existing columns layout
  }

  reinitializeColumnWidths(columns) {//resize columns to fit data
  }

  renderRows() {//render rows from a clean slate
  }

  renderColumns() {//render columns from a clean slate
  }

  rerenderRows(callback) {
    // rerender rows and keep position
    if (callback) {
      callback();
    }
  }

  rerenderColumns(update, blockRedraw) {//rerender columns
  }

  renderRowCells(row) {//render the cells in a row
  }

  rerenderRowCells(row, force) {//rerender the cells in a row
  }

  scrollColumns(left, dir) {//handle horizontal scrolling
  }

  scrollRows(top, dir) {//handle vertical scrolling
  }

  resize() {//container has resized, carry out any needed recalculations (DO NOT RERENDER IN THIS FUNCTION)
  }

  scrollToRow(row) {//scroll to a specific row
  }

  scrollToRowNearestTop(row) {//determine weather the row is nearest the top or bottom of the table, return true for top or false for bottom
  }

  visibleRows(includingBuffer) {
    //return the visible rows
    return [];
  } ///////////////////////////////////
  //////// Helper Functions /////////
  ///////////////////////////////////


  rows() {
    return this.table.rowManager.getDisplayRows();
  }

  styleRow(row, index) {
    var rowEl = row.getElement();

    if (index % 2) {
      rowEl.classList.add("tabulator-row-even");
      rowEl.classList.remove("tabulator-row-odd");
    } else {
      rowEl.classList.add("tabulator-row-odd");
      rowEl.classList.remove("tabulator-row-even");
    }
  } ///////////////////////////////////
  /////// External Triggers /////////
  /////// (DO NOT OVERRIDE) /////////
  ///////////////////////////////////


  clear() {
    //clear down existing layout
    this.clearRows();
    this.clearColumns();
  }

  render() {
    //render from a clean slate
    this.renderRows();
    this.renderColumns();
  }

  rerender(callback) {
    // rerender and keep position
    this.rerenderRows();
    this.rerenderColumns();
  }

  scrollToRowPosition(row, position, ifVisible) {
    var rowIndex = this.rows().indexOf(row),
        rowEl = row.getElement(),
        offset = 0;
    return new Promise((resolve, reject) => {
      if (rowIndex > -1) {
        if (typeof ifVisible === "undefined") {
          ifVisible = this.table.options.scrollToRowIfVisible;
        } //check row visibility


        if (!ifVisible) {
          if (Helpers.elVisible(rowEl)) {
            offset = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top;

            if (offset > 0 && offset < this.elementVertical.clientHeight - rowEl.offsetHeight) {
              resolve();
              return false;
            }
          }
        }

        if (typeof position === "undefined") {
          position = this.table.options.scrollToRowPosition;
        }

        if (position === "nearest") {
          position = this.scrollToRowNearestTop(row) ? "top" : "bottom";
        } //scroll to row


        this.scrollToRow(row); //align to correct position

        switch (position) {
          case "middle":
          case "center":
            if (this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight) {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop + (rowEl.offsetTop - this.elementVertical.scrollTop) - (this.elementVertical.scrollHeight - rowEl.offsetTop) / 2;
            } else {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight / 2;
            }

            break;

          case "bottom":
            if (this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight) {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - rowEl.offsetTop) + rowEl.offsetHeight;
            } else {
              this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + rowEl.offsetHeight;
            }

            break;

          case "top":
            this.elementVertical.scrollTop = rowEl.offsetTop;
            break;
        }

        resolve();
      } else {
        console.warn("Scroll Error - Row not visible");
        reject("Scroll Error - Row not visible");
      }
    });
  }

}

exports.Renderer = Renderer;

class BasicHorizontal extends Renderer {
  constructor(table) {
    super(table);
  }

  renderRowCells(row) {
    row.cells.forEach(cell => {
      row.element.appendChild(cell.getElement());
      cell.cellRendered();
    });
  }

  reinitializeColumnWidths(columns) {
    columns.forEach(function (column) {
      column.reinitializeWidth();
    });
  }

}

class VirtualDomHorizontal extends Renderer {
  constructor(table) {
    super(table);
    this.leftCol = 0;
    this.rightCol = 0;
    this.scrollLeft = 0;
    this.vDomScrollPosLeft = 0;
    this.vDomScrollPosRight = 0;
    this.vDomPadLeft = 0;
    this.vDomPadRight = 0;
    this.fitDataColAvg = 0;
    this.windowBuffer = 200; //pixel margin to make column visible before it is shown on screen

    this.visibleRows = null;
    this.initialized = false;
    this.isFitData = false;
    this.columns = [];
  }

  initialize() {
    this.compatibilityCheck();
    this.layoutCheck();
    this.vertScrollListen();
  }

  compatibilityCheck() {
    var columns = this.options("columns"),
        frozen = false,
        ok = true;

    if (this.options("layout") == "fitDataTable") {
      console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode");
      ok = false;
    }

    if (this.options("responsiveLayout")) {
      console.warn("Horizontal Virtual DOM is not compatible with responsive columns");
      ok = false;
    }

    if (this.options("rtl")) {
      console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
      ok = false;
    }

    if (columns) {
      frozen = columns.find(col => {
        return col.frozen;
      });

      if (frozen) {
        console.warn("Horizontal Virtual DOM is not compatible with frozen columns");
        ok = false;
      }
    } // if(!ok){
    // 	options.virtualDomHoz = false;
    // }


    return ok;
  }

  layoutCheck() {
    this.isFitData = this.options("layout").startsWith('fitData');
  }

  vertScrollListen() {
    this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this));
    this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
  }

  clearVisRowCache() {
    this.visibleRows = null;
  } //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////


  renderColumns(row, force) {
    this.dataChange();
  }

  scrollColumns(left, dir) {
    if (this.scrollLeft != left) {
      this.scrollLeft = left;
      this.scroll(left - (this.vDomScrollPosLeft + this.windowBuffer));
    }
  }

  calcWindowBuffer() {
    var buffer = this.elementVertical.clientWidth;
    this.table.columnManager.columnsByIndex.forEach(column => {
      if (column.visible) {
        var width = column.getWidth();

        if (width > buffer) {
          buffer = width;
        }
      }
    });
    this.windowBuffer = buffer * 2;
  }

  rerenderColumns(update, blockRedraw) {
    var old = {
      cols: this.columns,
      leftCol: this.leftCol,
      rightCol: this.rightCol
    },
        colPos = 0;

    if (update && !this.initialized) {
      return;
    }

    this.clear();
    this.calcWindowBuffer();
    this.scrollLeft = this.elementVertical.scrollLeft;
    this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer;
    this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
    this.table.columnManager.columnsByIndex.forEach(column => {
      var config = {};

      if (column.visible) {
        var width = column.getWidth();
        config.leftPos = colPos;
        config.rightPos = colPos + width;
        config.width = width;

        if (this.isFitData) {
          config.fitDataCheck = column.modules.vdomHoz ? column.modules.vdomHoz.fitDataCheck : true;
        }

        if (colPos + width > this.vDomScrollPosLeft && colPos < this.vDomScrollPosRight) {
          //column is visible
          if (this.leftCol == -1) {
            this.leftCol = this.columns.length;
            this.vDomPadLeft = colPos;
          }

          this.rightCol = this.columns.length;
        } else {
          // column is hidden
          if (this.leftCol !== -1) {
            this.vDomPadRight += width;
          }
        }

        this.columns.push(column);
        column.modules.vdomHoz = config;
        colPos += width;
      }
    });
    this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    this.initialized = true;

    if (!blockRedraw) {
      if (!update || this.reinitChanged(old)) {
        this.reinitializeRows();
      }
    }

    this.elementVertical.scrollLeft = this.scrollLeft;
  }

  renderRowCells(row) {
    if (this.initialized) {
      this.initializeRow(row);
    } else {
      row.cells.forEach(cell => {
        row.element.appendChild(cell.getElement());
        cell.cellRendered();
      });
    }
  }

  rerenderRowCells(row, force) {
    this.reinitializeRow(row, force);
  }

  reinitializeColumnWidths(columns) {
    for (let i = this.leftCol; i <= this.rightCol; i++) {
      this.columns[i].reinitializeWidth();
    }
  } //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////


  deinitialize() {
    this.initialized = false;
  }

  clear() {
    this.columns = [];
    this.leftCol = -1;
    this.rightCol = 0;
    this.vDomScrollPosLeft = 0;
    this.vDomScrollPosRight = 0;
    this.vDomPadLeft = 0;
    this.vDomPadRight = 0;
  }

  dataChange() {
    var change = false,
        row,
        rowEl;

    if (this.isFitData) {
      this.table.columnManager.columnsByIndex.forEach(column => {
        if (!column.definition.width && column.visible) {
          change = true;
        }
      });

      if (change && this.table.rowManager.getDisplayRows().length) {
        this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer;
        row = this.chain("rows-sample", [1], [], () => {
          return this.table.rowManager.getDisplayRows();
        })[0];

        if (row) {
          rowEl = row.getElement();
          row.generateCells();
          this.tableElement.appendChild(rowEl);

          for (let colEnd = 0; colEnd < row.cells.length; colEnd++) {
            let cell = row.cells[colEnd];
            rowEl.appendChild(cell.getElement());
            cell.column.reinitializeWidth();
          }

          rowEl.parentNode.removeChild(rowEl);
          this.rerenderColumns(false, true);
        }
      }
    } else {
      if (this.options("layout") === "fitColumns") {
        this.layoutRefresh();
        this.rerenderColumns(false, true);
      }
    }
  }

  reinitChanged(old) {
    var match = true;

    if (old.cols.length !== this.columns.length || old.leftCol !== this.leftCol || old.rightCol !== this.rightCol) {
      return true;
    }

    old.cols.forEach((col, i) => {
      if (col !== this.columns[i]) {
        match = false;
      }
    });
    return !match;
  }

  reinitializeRows() {
    var rows = this.getVisibleRows();
    rows.forEach(row => {
      this.reinitializeRow(row, true);
    });
  }

  getVisibleRows() {
    if (!this.visibleRows) {
      this.visibleRows = this.table.rowManager.getVisibleRows();
    }

    return this.visibleRows;
  }

  scroll(diff) {
    this.vDomScrollPosLeft += diff;
    this.vDomScrollPosRight += diff;

    if (Math.abs(diff) > this.windowBuffer / 2) {
      this.rerenderColumns();
    } else {
      if (diff > 0) {
        //scroll right
        this.addColRight();
        this.removeColLeft();
      } else {
        //scroll left
        this.addColLeft();
        this.removeColRight();
      }
    }
  }

  colPositionAdjust(start, end, diff) {
    for (let i = start; i < end; i++) {
      let column = this.columns[i];
      column.modules.vdomHoz.leftPos += diff;
      column.modules.vdomHoz.rightPos += diff;
    }
  }

  addColRight() {
    var changes = false,
        working = true;

    while (working) {
      let column = this.columns[this.rightCol + 1];

      if (column) {
        if (column.modules.vdomHoz.leftPos <= this.vDomScrollPosRight) {
          changes = true;
          this.getVisibleRows().forEach(row => {
            if (row.type !== "group") {
              var cell = row.getCell(column);
              row.getElement().appendChild(cell.getElement());
              cell.cellRendered();
            }
          });
          this.fitDataColActualWidthCheck(column);
          this.rightCol++; // Don't move this below the >= check below

          if (this.rightCol >= this.columns.length - 1) {
            this.vDomPadRight = 0;
          } else {
            this.vDomPadRight -= column.getWidth();
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }

    if (changes) {
      this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    }
  }

  addColLeft() {
    var changes = false,
        working = true;

    while (working) {
      let column = this.columns[this.leftCol - 1];

      if (column) {
        if (column.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
          changes = true;
          this.getVisibleRows().forEach(row => {
            if (row.type !== "group") {
              var cell = row.getCell(column);
              row.getElement().prepend(cell.getElement());
              cell.cellRendered();
            }
          });
          this.leftCol--; // don't move this below the <= check below

          if (this.leftCol <= 0) {
            // replicating logic in addColRight
            this.vDomPadLeft = 0;
          } else {
            this.vDomPadLeft -= column.getWidth();
          }

          let diff = this.fitDataColActualWidthCheck(column);

          if (diff) {
            this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + diff;
            this.vDomPadRight -= diff;
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }

    if (changes) {
      this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    }
  }

  removeColRight() {
    var changes = false,
        working = true;

    while (working) {
      let column = this.columns[this.rightCol];

      if (column) {
        if (column.modules.vdomHoz.leftPos > this.vDomScrollPosRight) {
          changes = true;
          this.getVisibleRows().forEach(row => {
            if (row.type !== "group") {
              var cell = row.getCell(column);

              try {
                row.getElement().removeChild(cell.getElement());
              } catch (ex) {
                console.warn("Could not removeColRight", ex.message);
              }
            }
          });
          this.vDomPadRight += column.getWidth();
          this.rightCol--;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }

    if (changes) {
      this.tableElement.style.paddingRight = this.vDomPadRight + "px";
    }
  }

  removeColLeft() {
    var changes = false,
        working = true;

    while (working) {
      let column = this.columns[this.leftCol];

      if (column) {
        if (column.modules.vdomHoz.rightPos < this.vDomScrollPosLeft) {
          changes = true;
          this.getVisibleRows().forEach(row => {
            if (row.type !== "group") {
              var cell = row.getCell(column);

              try {
                row.getElement().removeChild(cell.getElement());
              } catch (ex) {
                console.warn("Could not removeColLeft", ex.message);
              }
            }
          });
          this.vDomPadLeft += column.getWidth();
          this.leftCol++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }

    if (changes) {
      this.tableElement.style.paddingLeft = this.vDomPadLeft + "px";
    }
  }

  fitDataColActualWidthCheck(column) {
    var newWidth, widthDiff;

    if (column.modules.vdomHoz.fitDataCheck) {
      column.reinitializeWidth();
      newWidth = column.getWidth();
      widthDiff = newWidth - column.modules.vdomHoz.width;

      if (widthDiff) {
        column.modules.vdomHoz.rightPos += widthDiff;
        column.modules.vdomHoz.width = newWidth;
        this.colPositionAdjust(this.columns.indexOf(column) + 1, this.columns.length, widthDiff);
      }

      column.modules.vdomHoz.fitDataCheck = false;
    }

    return widthDiff;
  }

  initializeRow(row) {
    if (row.type !== "group") {
      row.modules.vdomHoz = {
        leftCol: this.leftCol,
        rightCol: this.rightCol
      };

      for (let i = this.leftCol; i <= this.rightCol; i++) {
        let column = this.columns[i];

        if (column && column.visible) {
          let cell = row.getCell(column);
          row.getElement().appendChild(cell.getElement());
          cell.cellRendered();
        }
      }
    }
  }

  reinitializeRow(row, force) {
    if (row.type !== "group") {
      if (force || !row.modules.vdomHoz || row.modules.vdomHoz.leftCol !== this.leftCol || row.modules.vdomHoz.rightCol !== this.rightCol) {
        var rowEl = row.getElement();

        while (rowEl.firstChild) rowEl.removeChild(rowEl.firstChild);

        this.initializeRow(row);
      }
    }
  }

}

class ColumnManager extends CoreFeature {
  constructor(table) {
    super(table);
    this.blockHozScrollEvent = false;
    this.headersElement = null;
    this.element = null; //containing element

    this.columns = []; // column definition object

    this.columnsByIndex = []; //columns by index

    this.columnsByField = {}; //columns by field

    this.scrollLeft = 0;
    this.optionsList = new OptionsList(this.table, "column definition", defaultColumnOptions);
    this.redrawBlock = false; //prevent redraws to allow multiple data manipulations before continuing

    this.redrawBlockUpdate = null; //store latest redraw update only status

    this.renderer = null;
  } ////////////// Setup Functions /////////////////


  initialize() {
    this.initializeRenderer();
    this.headersElement = this.createHeadersElement();
    this.element = this.createHeaderElement();
    this.element.insertBefore(this.headersElement, this.element.firstChild);
    this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this));
  }

  initializeRenderer() {
    var renderClass;
    var renderers = {
      "virtual": VirtualDomHorizontal,
      "basic": BasicHorizontal
    };

    if (typeof this.table.options.renderHorizontal === "string") {
      renderClass = renderers[this.table.options.renderHorizontal];
    } else {
      renderClass = this.table.options.renderHorizontal;
    }

    if (renderClass) {
      this.renderer = new renderClass(this.table, this.element, this.tableElement);
      this.renderer.initialize();
    } else {
      console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
    }
  }

  createHeadersElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-headers");
    el.setAttribute("role", "row");
    return el;
  }

  createHeaderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-header");
    el.setAttribute("role", "rowgroup");

    if (!this.table.options.headerVisible) {
      el.classList.add("tabulator-header-hidden");
    }

    return el;
  } //return containing element


  getElement() {
    return this.element;
  } //return header containing element


  getHeadersElement() {
    return this.headersElement;
  } //scroll horizontally to match table body


  scrollHorizontal(left) {
    var hozAdjust = 0,
        scrollWidth = this.element.scrollWidth - this.table.element.clientWidth; // this.tempScrollBlock();

    this.element.scrollLeft = left; //adjust for vertical scrollbar moving table when present

    if (left > scrollWidth) {
      hozAdjust = left - scrollWidth;
      this.element.style.marginLeft = -hozAdjust + "px";
    } else {
      this.element.style.marginLeft = 0;
    }

    this.scrollLeft = left;
    this.renderer.scrollColumns(left);
  } ///////////// Column Setup Functions /////////////


  generateColumnsFromRowData(data) {
    var cols = [],
        definitions = this.table.options.autoColumnsDefinitions,
        row,
        sorter;

    if (data && data.length) {
      row = data[0];

      for (var key in row) {
        let col = {
          field: key,
          title: key
        };
        let value = row[key];

        switch (typeof value) {
          case "undefined":
            sorter = "string";
            break;

          case "boolean":
            sorter = "boolean";
            break;

          case "object":
            if (Array.isArray(value)) {
              sorter = "array";
            } else {
              sorter = "string";
            }

            break;

          default:
            if (!isNaN(value) && value !== "") {
              sorter = "number";
            } else {
              if (value.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i)) {
                sorter = "alphanum";
              } else {
                sorter = "string";
              }
            }

            break;
        }

        col.sorter = sorter;
        cols.push(col);
      }

      if (definitions) {
        switch (typeof definitions) {
          case "function":
            this.table.options.columns = definitions.call(this.table, cols);
            break;

          case "object":
            if (Array.isArray(definitions)) {
              cols.forEach(col => {
                var match = definitions.find(def => {
                  return def.field === col.field;
                });

                if (match) {
                  Object.assign(col, match);
                }
              });
            } else {
              cols.forEach(col => {
                if (definitions[col.field]) {
                  Object.assign(col, definitions[col.field]);
                }
              });
            }

            this.table.options.columns = cols;
            break;
        }
      } else {
        this.table.options.columns = cols;
      }

      this.setColumns(this.table.options.columns);
    }
  }

  setColumns(cols, row) {
    while (this.headersElement.firstChild) this.headersElement.removeChild(this.headersElement.firstChild);

    this.columns = [];
    this.columnsByIndex = [];
    this.columnsByField = {};
    this.dispatch("columns-loading");
    cols.forEach((def, i) => {
      this._addColumn(def);
    });

    this._reIndexColumns();

    this.dispatch("columns-loaded");
    this.rerenderColumns(false, true);
    this.redraw(true);
  }

  _addColumn(definition, before, nextToColumn) {
    var column = new Column(definition, this),
        colEl = column.getElement(),
        index = nextToColumn ? this.findColumnIndex(nextToColumn) : nextToColumn;

    if (nextToColumn && index > -1) {
      var topColumn = nextToColumn.getTopColumn();
      var parentIndex = this.columns.indexOf(topColumn);
      var nextEl = topColumn.getElement();

      if (before) {
        this.columns.splice(parentIndex, 0, column);
        nextEl.parentNode.insertBefore(colEl, nextEl);
      } else {
        this.columns.splice(parentIndex + 1, 0, column);
        nextEl.parentNode.insertBefore(colEl, nextEl.nextSibling);
      }
    } else {
      if (before) {
        this.columns.unshift(column);
        this.headersElement.insertBefore(column.getElement(), this.headersElement.firstChild);
      } else {
        this.columns.push(column);
        this.headersElement.appendChild(column.getElement());
      }
    }

    column.columnRendered();
    return column;
  }

  registerColumnField(col) {
    if (col.definition.field) {
      this.columnsByField[col.definition.field] = col;
    }
  }

  registerColumnPosition(col) {
    this.columnsByIndex.push(col);
  }

  _reIndexColumns() {
    this.columnsByIndex = [];
    this.columns.forEach(function (column) {
      column.reRegisterPosition();
    });
  } //ensure column headers take up the correct amount of space in column groups


  verticalAlignHeaders() {
    var minHeight = 0;

    if (!this.redrawBlock) {
      this.columns.forEach(column => {
        column.clearVerticalAlign();
      });
      this.columns.forEach(column => {
        var height = column.getHeight();

        if (height > minHeight) {
          minHeight = height;
        }
      });
      this.columns.forEach(column => {
        column.verticalAlign(this.table.options.columnHeaderVertAlign, minHeight);
      });
      this.table.rowManager.adjustTableSize();
    }
  } //////////////// Column Details /////////////////


  findColumn(subject) {
    var columns;

    if (typeof subject == "object") {
      if (subject instanceof Column) {
        //subject is column element
        return subject;
      } else if (subject instanceof ColumnComponent) {
        //subject is public column component
        return subject._getSelf() || false;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        columns = [];
        this.columns.forEach(column => {
          columns.push(column);
          columns = columns.concat(column.getColumns(true));
        }); //subject is a HTML element of the column header

        let match = columns.find(column => {
          return column.element === subject;
        });
        return match || false;
      }
    } else {
      //subject should be treated as the field name of the column
      return this.columnsByField[subject] || false;
    } //catch all for any other type of input


    return false;
  }

  getColumnByField(field) {
    return this.columnsByField[field];
  }

  getColumnsByFieldRoot(root) {
    var matches = [];
    Object.keys(this.columnsByField).forEach(field => {
      var fieldRoot = field.split(".")[0];

      if (fieldRoot === root) {
        matches.push(this.columnsByField[field]);
      }
    });
    return matches;
  }

  getColumnByIndex(index) {
    return this.columnsByIndex[index];
  }

  getFirstVisibleColumn() {
    var index = this.columnsByIndex.findIndex(col => {
      return col.visible;
    });
    return index > -1 ? this.columnsByIndex[index] : false;
  }

  getColumns() {
    return this.columns;
  }

  findColumnIndex(column) {
    return this.columnsByIndex.findIndex(col => {
      return column === col;
    });
  } //return all columns that are not groups


  getRealColumns() {
    return this.columnsByIndex;
  } //traverse across columns and call action


  traverse(callback) {
    this.columnsByIndex.forEach((column, i) => {
      callback(column, i);
    });
  } //get definitions of actual columns


  getDefinitions(active) {
    var output = [];
    this.columnsByIndex.forEach(column => {
      if (!active || active && column.visible) {
        output.push(column.getDefinition());
      }
    });
    return output;
  } //get full nested definition tree


  getDefinitionTree() {
    var output = [];
    this.columns.forEach(column => {
      output.push(column.getDefinition(true));
    });
    return output;
  }

  getComponents(structured) {
    var output = [],
        columns = structured ? this.columns : this.columnsByIndex;
    columns.forEach(column => {
      output.push(column.getComponent());
    });
    return output;
  }

  getWidth() {
    var width = 0;
    this.columnsByIndex.forEach(column => {
      if (column.visible) {
        width += column.getWidth();
      }
    });
    return width;
  }

  moveColumn(from, to, after) {
    this.moveColumnActual(from, to, after);
    to.element.parentNode.insertBefore(from.element, to.element);

    if (after) {
      to.element.parentNode.insertBefore(to.element, from.element);
    }

    this.verticalAlignHeaders();
    this.table.rowManager.reinitialize();
  }

  moveColumnActual(from, to, after) {
    if (from.parent.isGroup) {
      this._moveColumnInArray(from.parent.columns, from, to, after);
    } else {
      this._moveColumnInArray(this.columns, from, to, after);
    }

    this._moveColumnInArray(this.columnsByIndex, from, to, after, true);

    this.rerenderColumns(true);
    this.dispatch("column-moved", from, to, after);

    if (this.subscribedExternal("columnMoved")) {
      this.dispatchExternal("columnMoved", from.getComponent(), this.table.columnManager.getComponents());
    }
  }

  _moveColumnInArray(columns, from, to, after, updateRows) {
    var fromIndex = columns.indexOf(from),
        toIndex,
        rows = [];

    if (fromIndex > -1) {
      columns.splice(fromIndex, 1);
      toIndex = columns.indexOf(to);

      if (toIndex > -1) {
        if (after) {
          toIndex = toIndex + 1;
        }
      } else {
        toIndex = fromIndex;
      }

      columns.splice(toIndex, 0, from);

      if (updateRows) {
        rows = this.chain("column-moving-rows", [from, to, after], null, []) || [];
        rows = rows.concat(this.table.rowManager.rows);
        rows.forEach(function (row) {
          if (row.cells.length) {
            var cell = row.cells.splice(fromIndex, 1)[0];
            row.cells.splice(toIndex, 0, cell);
          }
        });
      }
    }
  }

  scrollToColumn(column, position, ifVisible) {
    var left = 0,
        offset = 0,
        adjust = 0,
        colEl = column.getElement();
    return new Promise((resolve, reject) => {
      if (typeof position === "undefined") {
        position = this.table.options.scrollToColumnPosition;
      }

      if (typeof ifVisible === "undefined") {
        ifVisible = this.table.options.scrollToColumnIfVisible;
      }

      if (column.visible) {
        //align to correct position
        switch (position) {
          case "middle":
          case "center":
            adjust = -this.element.clientWidth / 2;
            break;

          case "right":
            adjust = colEl.clientWidth - this.headersElement.clientWidth;
            break;
        } //check column visibility


        if (!ifVisible) {
          offset = colEl.offsetLeft;

          if (offset > 0 && offset + colEl.offsetWidth < this.element.clientWidth) {
            return false;
          }
        } //calculate scroll position


        left = colEl.offsetLeft + adjust;
        left = Math.max(Math.min(left, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth), 0);
        this.table.rowManager.scrollHorizontal(left);
        this.scrollHorizontal(left);
        resolve();
      } else {
        console.warn("Scroll Error - Column not visible");
        reject("Scroll Error - Column not visible");
      }
    });
  } //////////////// Cell Management /////////////////


  generateCells(row) {
    var cells = [];
    this.columnsByIndex.forEach(column => {
      cells.push(column.generateCell(row));
    });
    return cells;
  } //////////////// Column Management /////////////////


  getFlexBaseWidth() {
    var totalWidth = this.table.element.clientWidth,
        //table element width
    fixedWidth = 0; //adjust for vertical scrollbar if present

    if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {
      totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
    }

    this.columnsByIndex.forEach(function (column) {
      var width, minWidth, colWidth;

      if (column.visible) {
        width = column.definition.width || 0;
        minWidth = parseInt(column.minWidth);

        if (typeof width == "string") {
          if (width.indexOf("%") > -1) {
            colWidth = totalWidth / 100 * parseInt(width);
          } else {
            colWidth = parseInt(width);
          }
        } else {
          colWidth = width;
        }

        fixedWidth += colWidth > minWidth ? colWidth : minWidth;
      }
    });
    return fixedWidth;
  }

  addColumn(definition, before, nextToColumn) {
    return new Promise((resolve, reject) => {
      var column = this._addColumn(definition, before, nextToColumn);

      this._reIndexColumns();

      this.dispatch("column-add", definition, before, nextToColumn);

      if (this.layoutMode() != "fitColumns") {
        column.reinitializeWidth();
      }

      this.redraw(true);
      this.table.rowManager.reinitialize();
      this.rerenderColumns();
      resolve(column);
    });
  } //remove column from system


  deregisterColumn(column) {
    var field = column.getField(),
        index; //remove from field list

    if (field) {
      delete this.columnsByField[field];
    } //remove from index list


    index = this.columnsByIndex.indexOf(column);

    if (index > -1) {
      this.columnsByIndex.splice(index, 1);
    } //remove from column list


    index = this.columns.indexOf(column);

    if (index > -1) {
      this.columns.splice(index, 1);
    }

    this.verticalAlignHeaders();
    this.redraw();
  }

  rerenderColumns(update, silent) {
    if (!this.redrawBlock) {
      this.renderer.rerenderColumns(update, silent);
    } else {
      if (update === false || update === true && this.redrawBlockUpdate === null) {
        this.redrawBlockUpdate = update;
      }
    }
  }

  blockRedraw() {
    this.redrawBlock = true;
    this.redrawBlockUpdate = null;
  }

  restoreRedraw() {
    this.redrawBlock = false;
    this.verticalAlignHeaders();
    this.renderer.rerenderColumns(this.redrawBlockUpdate);
  } //redraw columns


  redraw(force) {
    if (Helpers.elVisible(this.element)) {
      this.verticalAlignHeaders();
    }

    if (force) {
      this.table.rowManager.resetScroll();
      this.table.rowManager.reinitialize();
    }

    if (!this.confirm("table-redrawing", force)) {
      this.layoutRefresh(force);
    }

    this.dispatch("table-redraw", force);
    this.table.footerManager.redraw();
  }

}

class BasicVertical extends Renderer {
  constructor(table) {
    super(table);
    this.verticalFillMode = "fill";
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.scrollTop = 0;
    this.scrollLeft = 0;
  }

  clearRows() {
    var element = this.tableElement; // element.children.detach();

    while (element.firstChild) element.removeChild(element.firstChild);

    element.scrollTop = 0;
    element.scrollLeft = 0;
    element.style.minWidth = "";
    element.style.minHeight = "";
    element.style.display = "";
    element.style.visibility = "";
  }

  renderRows() {
    var element = this.tableElement,
        onlyGroupHeaders = true;
    this.rows().forEach((row, index) => {
      this.styleRow(row, index);
      element.appendChild(row.getElement());
      row.initialize(true);

      if (row.type !== "group") {
        onlyGroupHeaders = false;
      }
    });

    if (onlyGroupHeaders) {
      element.style.minWidth = this.table.columnManager.getWidth() + "px";
    } else {
      element.style.minWidth = "";
    }
  }

  rerenderRows(callback) {
    this.clearRows();
    this.renderRows();

    if (callback) {
      callback();
    }
  }

  scrollToRowNearestTop(row) {
    var rowTop = Helpers.elOffset(row.getElement()).top;
    return !(Math.abs(this.elementVertical.scrollTop - rowTop) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - rowTop));
  }

  scrollToRow(row) {
    var rowEl = row.getElement();
    this.elementVertical.scrollTop = Helpers.elOffset(rowEl).top - Helpers.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
  }

  visibleRows(includingBuffer) {
    return this.rows();
  }

}

class VirtualDomVertical extends Renderer {
  constructor(table) {
    super(table);
    this.verticalFillMode = "fill";
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.vDomRowHeight = 20; //approximation of row heights for padding

    this.vDomTop = 0; //hold position for first rendered row in the virtual DOM

    this.vDomBottom = 0; //hold position for last rendered row in the virtual DOM

    this.vDomScrollPosTop = 0; //last scroll position of the vDom top;

    this.vDomScrollPosBottom = 0; //last scroll position of the vDom bottom;

    this.vDomTopPad = 0; //hold value of padding for top of virtual DOM

    this.vDomBottomPad = 0; //hold value of padding for bottom of virtual DOM

    this.vDomMaxRenderChain = 90; //the maximum number of dom elements that can be rendered in 1 go

    this.vDomWindowBuffer = 0; //window row buffer before removing elements, to smooth scrolling

    this.vDomWindowMinTotalRows = 20; //minimum number of rows to be generated in virtual dom (prevent buffering issues on tables with tall rows)

    this.vDomWindowMinMarginRows = 5; //minimum number of rows to be generated in virtual dom margin

    this.vDomTopNewRows = []; //rows to normalize after appending to optimize render speed

    this.vDomBottomNewRows = []; //rows to normalize after appending to optimize render speed
  } //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////


  clearRows() {
    var element = this.tableElement; // element.children.detach();

    while (element.firstChild) element.removeChild(element.firstChild);

    element.style.paddingTop = "";
    element.style.paddingBottom = ""; // element.style.minWidth = "";

    element.style.minHeight = "";
    element.style.display = "";
    element.style.visibility = "";
    this.elementVertical.scrollTop = 0;
    this.elementVertical.scrollLeft = 0;
    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.vDomTop = 0;
    this.vDomBottom = 0;
    this.vDomTopPad = 0;
    this.vDomBottomPad = 0;
    this.vDomScrollPosTop = 0;
    this.vDomScrollPosBottom = 0;
  }

  renderRows() {
    this._virtualRenderFill();
  }

  rerenderRows(callback) {
    var scrollTop = this.elementVertical.scrollTop;
    var topRow = false;
    var topOffset = false;
    var left = this.table.rowManager.scrollLeft;
    var rows = this.rows();

    for (var i = this.vDomTop; i <= this.vDomBottom; i++) {
      if (rows[i]) {
        var diff = scrollTop - rows[i].getElement().offsetTop;

        if (topOffset === false || Math.abs(diff) < topOffset) {
          topOffset = diff;
          topRow = i;
        } else {
          break;
        }
      }
    }

    rows.forEach(row => {
      row.deinitializeHeight();
    });

    if (callback) {
      callback();
    }

    if (this.rows().length) {
      this._virtualRenderFill(topRow === false ? this.rows.length - 1 : topRow, true, topOffset || 0);
    } else {
      this.clear();

      this.table.rowManager._showPlaceholder();
    }

    this.scrollColumns(left);
  }

  scrollColumns(left) {
    this.table.rowManager.scrollHorizontal(left);
  }

  scrollRows(top, dir) {
    var topDiff = top - this.vDomScrollPosTop;
    var bottomDiff = top - this.vDomScrollPosBottom;
    var margin = this.vDomWindowBuffer * 2;
    var rows = this.rows();
    this.scrollTop = top;

    if (-topDiff > margin || bottomDiff > margin) {
      //if big scroll redraw table;
      var left = this.table.rowManager.scrollLeft;

      this._virtualRenderFill(Math.floor(this.elementVertical.scrollTop / this.elementVertical.scrollHeight * rows.length));

      this.scrollColumns(left);
    } else {
      if (dir) {
        //scrolling up
        if (topDiff < 0) {
          this._addTopRow(rows, -topDiff);
        }

        if (bottomDiff < 0) {
          //hide bottom row if needed
          if (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer) {
            this._removeBottomRow(rows, -bottomDiff);
          } else {
            this.vDomScrollPosBottom = this.scrollTop;
          }
        }
      } else {
        if (bottomDiff >= 0) {
          this._addBottomRow(rows, bottomDiff);
        } //scrolling down


        if (topDiff >= 0) {
          //hide top row if needed
          if (this.scrollTop > this.vDomWindowBuffer) {
            this._removeTopRow(rows, topDiff);
          } else {
            this.vDomScrollPosTop = this.scrollTop;
          }
        }
      }
    }
  }

  resize() {
    this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
  }

  scrollToRowNearestTop(row) {
    var rowIndex = this.rows().indexOf(row);
    return !(Math.abs(this.vDomTop - rowIndex) > Math.abs(this.vDomBottom - rowIndex));
  }

  scrollToRow(row) {
    var index = this.rows().indexOf(row);

    if (index > -1) {
      this._virtualRenderFill(index, true);
    }
  }

  visibleRows(includingBuffer) {
    var topEdge = this.elementVertical.scrollTop,
        bottomEdge = this.elementVertical.clientHeight + topEdge,
        topFound = false,
        topRow = 0,
        bottomRow = 0,
        rows = this.rows();

    if (includingBuffer) {
      topRow = this.vDomTop;
      bottomRow = this.vDomBottom;
    } else {
      for (var i = this.vDomTop; i <= this.vDomBottom; i++) {
        if (rows[i]) {
          if (!topFound) {
            if (topEdge - rows[i].getElement().offsetTop >= 0) {
              topRow = i;
            } else {
              topFound = true;

              if (bottomEdge - rows[i].getElement().offsetTop >= 0) {
                bottomRow = i;
              } else {
                break;
              }
            }
          } else {
            if (bottomEdge - rows[i].getElement().offsetTop >= 0) {
              bottomRow = i;
            } else {
              break;
            }
          }
        }
      }
    }

    return rows.slice(topRow, bottomRow + 1);
  } //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  //full virtual render


  _virtualRenderFill(position, forceMove, offset) {
    var element = this.tableElement,
        holder = this.elementVertical,
        topPad = 0,
        rowsHeight = 0,
        heightOccupied = 0,
        topPadHeight = 0,
        i = 0,
        rows = this.rows(),
        rowsCount = rows.length,
        containerHeight = this.elementVertical.clientHeight;
    position = position || 0;
    offset = offset || 0;

    if (!position) {
      this.clear();
    } else {
      while (element.firstChild) element.removeChild(element.firstChild); //check if position is too close to bottom of table


      heightOccupied = (rowsCount - position + 1) * this.vDomRowHeight;

      if (heightOccupied < containerHeight) {
        position -= Math.ceil((containerHeight - heightOccupied) / this.vDomRowHeight);

        if (position < 0) {
          position = 0;
        }
      } //calculate initial pad


      topPad = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight), this.vDomWindowMinMarginRows), position);
      position -= topPad;
    }

    if (rowsCount && Helpers.elVisible(this.elementVertical)) {
      this.vDomTop = position;
      this.vDomBottom = position - 1;

      while ((rowsHeight <= containerHeight + this.vDomWindowBuffer || i < this.vDomWindowMinTotalRows) && this.vDomBottom < rowsCount - 1) {
        var index = this.vDomBottom + 1,
            row = rows[index],
            rowHeight = 0;
        this.styleRow(row, index);
        element.appendChild(row.getElement());
        row.initialize();

        if (!row.heightInitialized) {
          row.normalizeHeight(true);
        }

        rowHeight = row.getHeight();

        if (i < topPad) {
          topPadHeight += rowHeight;
        } else {
          rowsHeight += rowHeight;
        }

        if (rowHeight > this.vDomWindowBuffer) {
          this.vDomWindowBuffer = rowHeight * 2;
        }

        this.vDomBottom++;
        i++;
      }

      if (!position) {
        this.vDomTopPad = 0; //adjust row height to match average of rendered elements

        this.vDomRowHeight = Math.floor((rowsHeight + topPadHeight) / i);
        this.vDomBottomPad = this.vDomRowHeight * (rowsCount - this.vDomBottom - 1);
        this.vDomScrollHeight = topPadHeight + rowsHeight + this.vDomBottomPad - containerHeight;
      } else {
        this.vDomTopPad = !forceMove ? this.scrollTop - topPadHeight : this.vDomRowHeight * this.vDomTop + offset;
        this.vDomBottomPad = this.vDomBottom == rowsCount - 1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - rowsHeight - topPadHeight, 0);
      }

      element.style.paddingTop = this.vDomTopPad + "px";
      element.style.paddingBottom = this.vDomBottomPad + "px";

      if (forceMove) {
        this.scrollTop = this.vDomTopPad + topPadHeight + offset - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - containerHeight : 0);
      }

      this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - containerHeight); //adjust for horizontal scrollbar if present (and not at top of table)

      if (this.elementVertical.scrollWidth > this.elementVertical.offsetWidth && forceMove) {
        this.scrollTop += this.elementVertical.offsetHeight - containerHeight;
      }

      this.vDomScrollPosTop = this.scrollTop;
      this.vDomScrollPosBottom = this.scrollTop;
      holder.scrollTop = this.scrollTop;
      this.dispatch("render-virtual-fill");
    }
  }

  _addTopRow(rows, fillableSpace) {
    var table = this.tableElement,
        addedRows = [],
        paddingAdjust = 0,
        index = this.vDomTop - 1,
        i = 0,
        working = true;

    while (working) {
      if (this.vDomTop) {
        let row = rows[index],
            rowHeight,
            initialized;

        if (row && i < this.vDomMaxRenderChain) {
          rowHeight = row.getHeight() || this.vDomRowHeight;
          initialized = row.initialized;

          if (fillableSpace >= rowHeight) {
            this.styleRow(row, index);
            table.insertBefore(row.getElement(), table.firstChild);

            if (!row.initialized || !row.heightInitialized) {
              addedRows.push(row);
            }

            row.initialize();

            if (!initialized) {
              rowHeight = row.getElement().offsetHeight;

              if (rowHeight > this.vDomWindowBuffer) {
                this.vDomWindowBuffer = rowHeight * 2;
              }
            }

            fillableSpace -= rowHeight;
            paddingAdjust += rowHeight;
            this.vDomTop--;
            index--;
            i++;
          } else {
            working = false;
          }
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }

    for (let row of addedRows) {
      row.clearCellHeight();
    }

    this._quickNormalizeRowHeight(addedRows);

    if (paddingAdjust) {
      this.vDomTopPad -= paddingAdjust;

      if (this.vDomTopPad < 0) {
        this.vDomTopPad = index * this.vDomRowHeight;
      }

      if (index < 1) {
        this.vDomTopPad = 0;
      }

      table.style.paddingTop = this.vDomTopPad + "px";
      this.vDomScrollPosTop -= paddingAdjust;
    }
  }

  _removeTopRow(rows, fillableSpace) {
    var removableRows = [],
        paddingAdjust = 0,
        i = 0,
        working = true;

    while (working) {
      let row = rows[this.vDomTop],
          rowHeight;

      if (row && i < this.vDomMaxRenderChain) {
        rowHeight = row.getHeight() || this.vDomRowHeight;

        if (fillableSpace >= rowHeight) {
          this.vDomTop++;
          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          removableRows.push(row);
          i++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }

    for (let row of removableRows) {
      let rowEl = row.getElement();

      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }
    }

    if (paddingAdjust) {
      this.vDomTopPad += paddingAdjust;
      this.tableElement.style.paddingTop = this.vDomTopPad + "px";
      this.vDomScrollPosTop += this.vDomTop ? paddingAdjust : paddingAdjust + this.vDomWindowBuffer;
    }
  }

  _addBottomRow(rows, fillableSpace) {
    var table = this.tableElement,
        addedRows = [],
        paddingAdjust = 0,
        index = this.vDomBottom + 1,
        i = 0,
        working = true;

    while (working) {
      let row = rows[index],
          rowHeight,
          initialized;

      if (row && i < this.vDomMaxRenderChain) {
        rowHeight = row.getHeight() || this.vDomRowHeight;
        initialized = row.initialized;

        if (fillableSpace >= rowHeight) {
          this.styleRow(row, index);
          table.appendChild(row.getElement());

          if (!row.initialized || !row.heightInitialized) {
            addedRows.push(row);
          }

          row.initialize();

          if (!initialized) {
            rowHeight = row.getElement().offsetHeight;

            if (rowHeight > this.vDomWindowBuffer) {
              this.vDomWindowBuffer = rowHeight * 2;
            }
          }

          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          this.vDomBottom++;
          index++;
          i++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }

    for (let row of addedRows) {
      row.clearCellHeight();
    }

    this._quickNormalizeRowHeight(addedRows);

    if (paddingAdjust) {
      this.vDomBottomPad -= paddingAdjust;

      if (this.vDomBottomPad < 0 || index == rows.length - 1) {
        this.vDomBottomPad = 0;
      }

      table.style.paddingBottom = this.vDomBottomPad + "px";
      this.vDomScrollPosBottom += paddingAdjust;
    }
  }

  _removeBottomRow(rows, fillableSpace) {
    var removableRows = [],
        paddingAdjust = 0,
        i = 0,
        working = true;

    while (working) {
      let row = rows[this.vDomBottom],
          rowHeight;

      if (row && i < this.vDomMaxRenderChain) {
        rowHeight = row.getHeight() || this.vDomRowHeight;

        if (fillableSpace >= rowHeight) {
          this.vDomBottom--;
          fillableSpace -= rowHeight;
          paddingAdjust += rowHeight;
          removableRows.push(row);
          i++;
        } else {
          working = false;
        }
      } else {
        working = false;
      }
    }

    for (let row of removableRows) {
      let rowEl = row.getElement();

      if (rowEl.parentNode) {
        rowEl.parentNode.removeChild(rowEl);
      }
    }

    if (paddingAdjust) {
      this.vDomBottomPad += paddingAdjust;

      if (this.vDomBottomPad < 0) {
        this.vDomBottomPad = 0;
      }

      this.tableElement.style.paddingBottom = this.vDomBottomPad + "px";
      this.vDomScrollPosBottom -= paddingAdjust;
    }
  }

  _quickNormalizeRowHeight(rows) {
    for (let row of rows) {
      row.calcHeight();
    }

    for (let row of rows) {
      row.setCellHeight();
    }
  }

}

class RowManager extends CoreFeature {
  constructor(table) {
    super(table);
    this.element = this.createHolderElement(); //containing element

    this.tableElement = this.createTableElement(); //table element

    this.heightFixer = this.createTableElement(); //table element

    this.placeholder = null; //placeholder element

    this.placeholderContents = null; //placeholder element

    this.firstRender = false; //handle first render

    this.renderMode = "virtual"; //current rendering mode

    this.fixedHeight = false; //current rendering mode

    this.rows = []; //hold row data objects

    this.activeRowsPipeline = []; //hold calculation of active rows

    this.activeRows = []; //rows currently available to on display in the table

    this.activeRowsCount = 0; //count of active rows

    this.displayRows = []; //rows currently on display in the table

    this.displayRowsCount = 0; //count of display rows

    this.scrollTop = 0;
    this.scrollLeft = 0;
    this.redrawBlock = false; //prevent redraws to allow multiple data manipulations before continuing

    this.redrawBlockRestoreConfig = false; //store latest redraw function calls for when redraw is needed

    this.redrawBlockRenderInPosition = false; //store latest redraw function calls for when redraw is needed

    this.dataPipeline = []; //hold data pipeline tasks

    this.displayPipeline = []; //hold data display pipeline tasks

    this.renderer = null;
  } //////////////// Setup Functions /////////////////


  createHolderElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-tableholder");
    el.setAttribute("tabindex", 0); // el.setAttribute("role", "rowgroup");

    return el;
  }

  createTableElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-table");
    el.setAttribute("role", "rowgroup");
    return el;
  }

  initializePlaceholder() {
    //configure placeholder element
    if (typeof this.table.options.placeholder == "string") {
      let el = document.createElement("div");
      el.classList.add("tabulator-placeholder");
      let contents = document.createElement("div");
      contents.classList.add("tabulator-placeholder-contents");
      contents.innerHTML = this.table.options.placeholder;
      el.appendChild(contents);
      this.placeholderContents = contents;
      this.placeholder = el;
    }
  } //return containing element


  getElement() {
    return this.element;
  } //return table element


  getTableElement() {
    return this.tableElement;
  }

  initialize() {
    this.initializePlaceholder();
    this.initializeRenderer(); //initialize manager

    this.element.appendChild(this.tableElement);
    this.firstRender = true; //scroll header along with table body

    this.element.addEventListener("scroll", () => {
      var left = this.element.scrollLeft,
          leftDir = this.scrollLeft > left,
          top = this.element.scrollTop,
          topDir = this.scrollTop > top; //handle horizontal scrolling

      if (this.scrollLeft != left) {
        this.scrollLeft = left;
        this.dispatch("scroll-horizontal", left, leftDir);
        this.dispatchExternal("scrollHorizontal", left, leftDir);

        this._positionPlaceholder();
      } //handle vertical scrolling


      if (this.scrollTop != top) {
        this.scrollTop = top;
        this.renderer.scrollRows(top, topDir);
        this.dispatch("scroll-vertical", top, topDir);
        this.dispatchExternal("scrollVertical", top, topDir);
      }
    });
  } ////////////////// Row Manipulation //////////////////


  findRow(subject) {
    if (typeof subject == "object") {
      if (subject instanceof Row) {
        //subject is row element
        return subject;
      } else if (subject instanceof RowComponent) {
        //subject is public row component
        return subject._getSelf() || false;
      } else if (typeof HTMLElement !== "undefined" && subject instanceof HTMLElement) {
        //subject is a HTML element of the row
        let match = this.rows.find(row => {
          return row.getElement() === subject;
        });
        return match || false;
      } else if (subject === null) {
        return false;
      }
    } else if (typeof subject == "undefined") {
      return false;
    } else {
      //subject should be treated as the index of the row
      let match = this.rows.find(row => {
        return row.data[this.table.options.index] == subject;
      });
      return match || false;
    } //catch all for any other type of input


    return false;
  }

  getRowFromDataObject(data) {
    var match = this.rows.find(row => {
      return row.data === data;
    });
    return match || false;
  }

  getRowFromPosition(position) {
    return this.getDisplayRows().find(row => {
      return row.getPosition() === position && row.isDisplayed();
    });
  }

  scrollToRow(row, position, ifVisible) {
    return this.renderer.scrollToRowPosition(row, position, ifVisible);
  } ////////////////// Data Handling //////////////////


  setData(data, renderInPosition, columnsChanged) {
    return new Promise((resolve, reject) => {
      if (renderInPosition && this.getDisplayRows().length) {
        if (this.table.options.pagination) {
          this._setDataActual(data, true);
        } else {
          this.reRenderInPosition(() => {
            this._setDataActual(data);
          });
        }
      } else {
        if (this.table.options.autoColumns && columnsChanged && this.table.initialized) {
          this.table.columnManager.generateColumnsFromRowData(data);
        }

        this.resetScroll();

        this._setDataActual(data);
      }

      resolve();
    });
  }

  _setDataActual(data, renderInPosition) {
    this.dispatchExternal("dataProcessing", data);

    this._wipeElements();

    if (Array.isArray(data)) {
      this.dispatch("data-processing", data);
      data.forEach((def, i) => {
        if (def && typeof def === "object") {
          var row = new Row(def, this);
          this.rows.push(row);
        } else {
          console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", def);
        }
      });
      this.refreshActiveData(false, false, renderInPosition);
      this.dispatch("data-processed", data);
      this.dispatchExternal("dataProcessed", data);
    } else {
      console.error("Data Loading Error - Unable to process data due to invalid data type \nExpecting: array \nReceived: ", typeof data, "\nData:     ", data);
    }
  }

  _wipeElements() {
    this.dispatch("rows-wipe");
    this.rows.forEach(row => {
      row.wipe();
    });
    this.rows = [];
    this.activeRows = [];
    this.activeRowsPipeline = [];
    this.activeRowsCount = 0;
    this.displayRows = [];
    this.displayRowsCount = 0;
    this.adjustTableSize();
  }

  deleteRow(row, blockRedraw) {
    var allIndex = this.rows.indexOf(row),
        activeIndex = this.activeRows.indexOf(row);

    if (activeIndex > -1) {
      this.activeRows.splice(activeIndex, 1);
    }

    if (allIndex > -1) {
      this.rows.splice(allIndex, 1);
    }

    this.setActiveRows(this.activeRows);
    this.displayRowIterator(rows => {
      var displayIndex = rows.indexOf(row);

      if (displayIndex > -1) {
        rows.splice(displayIndex, 1);
      }
    });

    if (!blockRedraw) {
      this.reRenderInPosition();
    }

    this.regenerateRowPositions();
    this.dispatchExternal("rowDeleted", row.getComponent());

    if (!this.displayRowsCount) {
      this._showPlaceholder();
    }

    if (this.subscribedExternal("dataChanged")) {
      this.dispatchExternal("dataChanged", this.getData());
    }
  }

  addRow(data, pos, index, blockRedraw) {
    var row = this.addRowActual(data, pos, index, blockRedraw);
    return row;
  } //add multiple rows


  addRows(data, pos, index) {
    var rows = [];
    return new Promise((resolve, reject) => {
      pos = this.findAddRowPos(pos);

      if (!Array.isArray(data)) {
        data = [data];
      }

      if (typeof index == "undefined" && pos || typeof index !== "undefined" && !pos) {
        data.reverse();
      }

      data.forEach((item, i) => {
        var row = this.addRow(item, pos, index, true);
        rows.push(row);
        this.dispatch("row-added", row, data, pos, index);
      });
      this.refreshActiveData(false, false, true);
      this.regenerateRowPositions();

      if (rows.length) {
        this._clearPlaceholder();
      }

      resolve(rows);
    });
  }

  findAddRowPos(pos) {
    if (typeof pos === "undefined") {
      pos = this.table.options.addRowPos;
    }

    if (pos === "pos") {
      pos = true;
    }

    if (pos === "bottom") {
      pos = false;
    }

    return pos;
  }

  addRowActual(data, pos, index, blockRedraw) {
    var row = data instanceof Row ? data : new Row(data || {}, this),
        top = this.findAddRowPos(pos),
        allIndex = -1,
        activeIndex,
        chainResult;

    if (!index) {
      chainResult = this.chain("row-adding-position", [row, top], null, {
        index,
        top
      });
      index = chainResult.index;
      top = chainResult.top;
    }

    if (typeof index !== "undefined") {
      index = this.findRow(index);
    }

    index = this.chain("row-adding-index", [row, index, top], null, index);

    if (index) {
      allIndex = this.rows.indexOf(index);
    }

    if (index && allIndex > -1) {
      activeIndex = this.activeRows.indexOf(index);
      this.displayRowIterator(function (rows) {
        var displayIndex = rows.indexOf(index);

        if (displayIndex > -1) {
          rows.splice(top ? displayIndex : displayIndex + 1, 0, row);
        }
      });

      if (activeIndex > -1) {
        this.activeRows.splice(top ? activeIndex : activeIndex + 1, 0, row);
      }

      this.rows.splice(top ? allIndex : allIndex + 1, 0, row);
    } else {
      if (top) {
        this.displayRowIterator(function (rows) {
          rows.unshift(row);
        });
        this.activeRows.unshift(row);
        this.rows.unshift(row);
      } else {
        this.displayRowIterator(function (rows) {
          rows.push(row);
        });
        this.activeRows.push(row);
        this.rows.push(row);
      }
    }

    this.setActiveRows(this.activeRows);
    this.dispatchExternal("rowAdded", row.getComponent());

    if (this.subscribedExternal("dataChanged")) {
      this.dispatchExternal("dataChanged", this.table.rowManager.getData());
    }

    if (!blockRedraw) {
      this.reRenderInPosition();
    }

    return row;
  }

  moveRow(from, to, after) {
    this.dispatch("row-move", from, to, after);
    this.moveRowActual(from, to, after);
    this.regenerateRowPositions();
    this.dispatch("row-moved", from, to, after);
    this.dispatchExternal("rowMoved", from.getComponent());
  }

  moveRowActual(from, to, after) {
    this.moveRowInArray(this.rows, from, to, after);
    this.moveRowInArray(this.activeRows, from, to, after);
    this.displayRowIterator(rows => {
      this.moveRowInArray(rows, from, to, after);
    });
    this.dispatch("row-moving", from, to, after);
  }

  moveRowInArray(rows, from, to, after) {
    var fromIndex, toIndex, start, end;

    if (from !== to) {
      fromIndex = rows.indexOf(from);

      if (fromIndex > -1) {
        rows.splice(fromIndex, 1);
        toIndex = rows.indexOf(to);

        if (toIndex > -1) {
          if (after) {
            rows.splice(toIndex + 1, 0, from);
          } else {
            rows.splice(toIndex, 0, from);
          }
        } else {
          rows.splice(fromIndex, 0, from);
        }
      } //restyle rows


      if (rows === this.getDisplayRows()) {
        start = fromIndex < toIndex ? fromIndex : toIndex;
        end = toIndex > fromIndex ? toIndex : fromIndex + 1;

        for (let i = start; i <= end; i++) {
          if (rows[i]) {
            this.styleRow(rows[i], i);
          }
        }
      }
    }
  }

  clearData() {
    this.setData([]);
  }

  getRowIndex(row) {
    return this.findRowIndex(row, this.rows);
  }

  getDisplayRowIndex(row) {
    var index = this.getDisplayRows().indexOf(row);
    return index > -1 ? index : false;
  }

  nextDisplayRow(row, rowOnly) {
    var index = this.getDisplayRowIndex(row),
        nextRow = false;

    if (index !== false && index < this.displayRowsCount - 1) {
      nextRow = this.getDisplayRows()[index + 1];
    }

    if (nextRow && (!(nextRow instanceof Row) || nextRow.type != "row")) {
      return this.nextDisplayRow(nextRow, rowOnly);
    }

    return nextRow;
  }

  prevDisplayRow(row, rowOnly) {
    var index = this.getDisplayRowIndex(row),
        prevRow = false;

    if (index) {
      prevRow = this.getDisplayRows()[index - 1];
    }

    if (rowOnly && prevRow && (!(prevRow instanceof Row) || prevRow.type != "row")) {
      return this.prevDisplayRow(prevRow, rowOnly);
    }

    return prevRow;
  }

  findRowIndex(row, list) {
    var rowIndex;
    row = this.findRow(row);

    if (row) {
      rowIndex = list.indexOf(row);

      if (rowIndex > -1) {
        return rowIndex;
      }
    }

    return false;
  }

  getData(active, transform) {
    var output = [],
        rows = this.getRows(active);
    rows.forEach(function (row) {
      if (row.type == "row") {
        output.push(row.getData(transform || "data"));
      }
    });
    return output;
  }

  getComponents(active) {
    var output = [],
        rows = this.getRows(active);
    rows.forEach(function (row) {
      output.push(row.getComponent());
    });
    return output;
  }

  getDataCount(active) {
    var rows = this.getRows(active);
    return rows.length;
  }

  scrollHorizontal(left) {
    this.scrollLeft = left;
    this.element.scrollLeft = left;
    this.dispatch("scroll-horizontal", left);
  }

  registerDataPipelineHandler(handler, priority) {
    if (typeof priority !== "undefined") {
      this.dataPipeline.push({
        handler,
        priority
      });
      this.dataPipeline.sort((a, b) => {
        return a.priority - b.priority;
      });
    } else {
      console.error("Data pipeline handlers must have a priority in order to be registered");
    }
  }

  registerDisplayPipelineHandler(handler, priority) {
    if (typeof priority !== "undefined") {
      this.displayPipeline.push({
        handler,
        priority
      });
      this.displayPipeline.sort((a, b) => {
        return a.priority - b.priority;
      });
    } else {
      console.error("Display pipeline handlers must have a priority in order to be registered");
    }
  } //set active data set


  refreshActiveData(handler, skipStage, renderInPosition) {
    var table = this.table,
        stage = "",
        index = 0,
        cascadeOrder = ["all", "dataPipeline", "display", "displayPipeline", "end"];

    if (typeof handler === "function") {
      index = this.dataPipeline.findIndex(item => {
        return item.handler === handler;
      });

      if (index > -1) {
        stage = "dataPipeline";

        if (skipStage) {
          if (index == this.dataPipeline.length - 1) {
            stage = "display";
          } else {
            index++;
          }
        }
      } else {
        index = this.displayPipeline.findIndex(item => {
          return item.handler === handler;
        });

        if (index > -1) {
          stage = "displayPipeline";

          if (skipStage) {
            if (index == this.displayPipeline.length - 1) {
              stage = "end";
            } else {
              index++;
            }
          }
        } else {
          console.error("Unable to refresh data, invalid handler provided", handler);
          return;
        }
      }
    } else {
      stage = handler || "all";
      index = 0;
    }

    if (this.redrawBlock) {
      if (!this.redrawBlockRestoreConfig || this.redrawBlockRestoreConfig && (this.redrawBlockRestoreConfig.stage === stage && index < this.redrawBlockRestoreConfig.index || cascadeOrder.indexOf(stage) < cascadeOrder.indexOf(this.redrawBlockRestoreConfig.stage))) {
        this.redrawBlockRestoreConfig = {
          handler: handler,
          skipStage: skipStage,
          renderInPosition: renderInPosition,
          stage: stage,
          index: index
        };
      }

      return;
    } else {
      if (Helpers.elVisible(this.element)) {
        if (renderInPosition) {
          this.reRenderInPosition(this.refreshPipelines.bind(this, handler, stage, index, renderInPosition));
        } else {
          this.refreshPipelines(handler, stage, index, renderInPosition);

          if (!handler) {
            this.table.columnManager.renderer.renderColumns();
          }

          this.renderTable();

          if (table.options.layoutColumnsOnNewData) {
            this.table.columnManager.redraw(true);
          }
        }
      } else {
        this.refreshPipelines(handler, stage, index, renderInPosition);
      }

      this.dispatch("data-refreshed");
    }
  }

  refreshPipelines(handler, stage, index, renderInPosition) {
    this.dispatch("data-refreshing");

    if (!handler) {
      this.activeRowsPipeline[0] = this.rows.slice(0);
    } //cascade through data refresh stages


    switch (stage) {
      case "all": //handle case where all data needs refreshing

      case "dataPipeline":
        for (let i = index; i < this.dataPipeline.length; i++) {
          let result = this.dataPipeline[i].handler(this.activeRowsPipeline[i].slice(0));
          this.activeRowsPipeline[i + 1] = result || this.activeRowsPipeline[i].slice(0);
        }

        this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);

      case "display":
        index = 0;
        this.resetDisplayRows();

      case "displayPipeline":
        for (let i = index; i < this.displayPipeline.length; i++) {
          let result = this.displayPipeline[i].handler((i ? this.getDisplayRows(i - 1) : this.activeRows).slice(0), renderInPosition);
          this.setDisplayRows(result || this.getDisplayRows(i - 1).slice(0), i);
        }

      case "end":
        //case to handle scenario when trying to skip past end stage
        this.regenerateRowPositions();
    }
  } //regenerate row positions


  regenerateRowPositions() {
    var rows = this.getDisplayRows();
    var index = 1;
    rows.forEach(row => {
      if (row.type === "row") {
        row.setPosition(index);
        index++;
      }
    });
  }

  setActiveRows(activeRows) {
    this.activeRows = activeRows;
    this.activeRowsCount = this.activeRows.length;
  } //reset display rows array


  resetDisplayRows() {
    this.displayRows = [];
    this.displayRows.push(this.activeRows.slice(0));
    this.displayRowsCount = this.displayRows[0].length;
  }

  getNextDisplayIndex() {
    return this.displayRows.length;
  } //set display row pipeline data


  setDisplayRows(displayRows, index) {
    var output = true;

    if (index && typeof this.displayRows[index] != "undefined") {
      this.displayRows[index] = displayRows;
      output = true;
    } else {
      this.displayRows.push(displayRows);
      output = index = this.displayRows.length - 1;
    }

    if (index == this.displayRows.length - 1) {
      this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
    }

    return output;
  }

  getDisplayRows(index) {
    if (typeof index == "undefined") {
      return this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [];
    } else {
      return this.displayRows[index] || [];
    }
  }

  getVisibleRows(chain, viewable) {
    var rows = Object.assign([], this.renderer.visibleRows(!viewable));

    if (chain) {
      rows = this.chain("rows-visible", [viewable], rows, rows);
    }

    return rows;
  } //repeat action across display rows


  displayRowIterator(callback) {
    this.activeRowsPipeline.forEach(callback);
    this.displayRows.forEach(callback);
    this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
  } //return only actual rows (not group headers etc)


  getRows(type) {
    var rows;

    switch (type) {
      case "active":
        rows = this.activeRows;
        break;

      case "display":
        rows = this.table.rowManager.getDisplayRows();
        break;

      case "visible":
        rows = this.getVisibleRows(false, true);
        break;

      default:
        rows = this.chain("rows-retrieve", type, null, this.rows) || this.rows;
    }

    return rows;
  } ///////////////// Table Rendering /////////////////
  //trigger rerender of table in current position


  reRenderInPosition(callback) {
    if (this.redrawBlock) {
      if (callback) {
        callback();
      } else {
        this.redrawBlockRenderInPosition = true;
      }
    } else {
      this.dispatchExternal("renderStarted");
      this.renderer.rerenderRows(callback);

      if (!this.fixedHeight) {
        this.adjustTableSize();
      }

      this.dispatchExternal("renderComplete");
    }
  }

  initializeRenderer() {
    var renderClass;
    var renderers = {
      "virtual": VirtualDomVertical,
      "basic": BasicVertical
    };

    if (typeof this.table.options.renderVertical === "string") {
      renderClass = renderers[this.table.options.renderVertical];
    } else {
      renderClass = this.table.options.renderVertical;
    }

    if (renderClass) {
      this.renderMode = this.table.options.renderVertical;
      this.renderer = new renderClass(this.table, this.element, this.tableElement);
      this.renderer.initialize();

      if (this.table.element.clientHeight || this.table.options.height) {
        this.fixedHeight = true;
      } else {
        this.fixedHeight = false;
      }
    } else {
      console.error("Unable to find matching renderer:", this.table.options.renderVertical);
    }
  }

  getRenderMode() {
    return this.renderMode;
  }

  renderTable() {
    this.dispatchExternal("renderStarted");
    this.element.scrollTop = 0;

    this._clearTable();

    if (this.displayRowsCount) {
      this.renderer.renderRows();

      if (this.firstRender) {
        this.firstRender = false;
        this.layoutRefresh(true);
      }
    } else {
      this.renderEmptyScroll();
    }

    if (!this.fixedHeight) {
      this.adjustTableSize();
    }

    this.dispatch("table-layout");

    if (!this.displayRowsCount) {
      this._showPlaceholder();
    }

    this.dispatchExternal("renderComplete");
  } //show scrollbars on empty table div


  renderEmptyScroll() {
    if (this.placeholder) {
      this.tableElement.style.display = "none";
    } else {
      this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px"; // this.tableElement.style.minHeight = "1px";
      // this.tableElement.style.visibility = "hidden";
    }
  }

  _clearTable() {
    this._clearPlaceholder();

    this.scrollTop = 0;
    this.scrollLeft = 0; // clear empty table placeholder min

    this.tableElement.style.minWidth = "";
    this.renderer.clearRows();
  }

  _showPlaceholder() {
    if (this.placeholder) {
      this.placeholder.setAttribute("tabulator-render-mode", this.renderMode);
      this.getElement().appendChild(this.placeholder);

      this._positionPlaceholder();
    }
  }

  _clearPlaceholder() {
    if (this.placeholder && this.placeholder.parentNode) {
      this.placeholder.parentNode.removeChild(this.placeholder);
    }
  }

  _positionPlaceholder() {
    if (this.placeholder && this.placeholder.parentNode) {
      this.placeholder.style.width = this.table.columnManager.getWidth() + "px";
      this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px";
      this.placeholderContents.style.marginLeft = this.scrollLeft + "px";
    }
  }

  styleRow(row, index) {
    var rowEl = row.getElement();

    if (index % 2) {
      rowEl.classList.add("tabulator-row-even");
      rowEl.classList.remove("tabulator-row-odd");
    } else {
      rowEl.classList.add("tabulator-row-odd");
      rowEl.classList.remove("tabulator-row-even");
    }
  } //normalize height of active rows


  normalizeHeight() {
    this.activeRows.forEach(function (row) {
      row.normalizeHeight();
    });
  } //adjust the height of the table holder to fit in the Tabulator element


  adjustTableSize() {
    var initialHeight = this.element.clientHeight,
        minHeight;

    if (this.renderer.verticalFillMode === "fill") {
      let otherHeight = Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));

      if (this.fixedHeight) {
        minHeight = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
        this.element.style.minHeight = minHeight || "calc(100% - " + otherHeight + "px)";
        this.element.style.height = "calc(100% - " + otherHeight + "px)";
        this.element.style.maxHeight = "calc(100% - " + otherHeight + "px)";
      } else {
        this.element.style.height = "";
        this.element.style.height = this.table.element.clientHeight - otherHeight + "px";
        this.element.scrollTop = this.scrollTop;
      }

      this.renderer.resize(); //check if the table has changed size when dealing with variable height tables

      if (!this.fixedHeight && initialHeight != this.element.clientHeight) {
        if (this.subscribed("table-resize")) {
          this.dispatch("table-resize");
        } else {
          this.redraw();
        }
      }
    }

    this._positionPlaceholder();
  } //reinitialize all rows


  reinitialize() {
    this.rows.forEach(function (row) {
      row.reinitialize(true);
    });
  } //prevent table from being redrawn


  blockRedraw() {
    this.redrawBlock = true;
    this.redrawBlockRestoreConfig = false;
  } //restore table redrawing


  restoreRedraw() {
    this.redrawBlock = false;

    if (this.redrawBlockRestoreConfig) {
      this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition);
      this.redrawBlockRestoreConfig = false;
    } else {
      if (this.redrawBlockRenderInPosition) {
        this.reRenderInPosition();
      }
    }

    this.redrawBlockRenderInPosition = false;
  } //redraw table


  redraw(force) {
    var left = this.scrollLeft;
    this.adjustTableSize();
    this.table.tableWidth = this.table.element.clientWidth;

    if (!force) {
      this.reRenderInPosition();
      this.scrollHorizontal(left);
    } else {
      this.renderTable();
    }
  }

  resetScroll() {
    this.element.scrollLeft = 0;
    this.element.scrollTop = 0;

    if (this.table.browser === "ie") {
      var event = document.createEvent("Event");
      event.initEvent("scroll", false, true);
      this.element.dispatchEvent(event);
    } else {
      this.element.dispatchEvent(new Event('scroll'));
    }
  }

}

class FooterManager extends CoreFeature {
  constructor(table) {
    super(table);
    this.active = false;
    this.element = this.createElement(); //containing element

    this.containerElement = this.createContainerElement(); //containing element

    this.external = false;
  }

  initialize() {
    this.initializeElement();
  }

  createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-footer");
    return el;
  }

  createContainerElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-footer-contents");
    this.element.appendChild(el);
    return el;
  }

  initializeElement() {
    if (this.table.options.footerElement) {
      switch (typeof this.table.options.footerElement) {
        case "string":
          if (this.table.options.footerElement[0] === "<") {
            this.containerElement.innerHTML = this.table.options.footerElement;
          } else {
            this.external = true;
            this.containerElement = document.querySelector(this.table.options.footerElement);
          }

          break;

        default:
          this.element = this.table.options.footerElement;
          break;
      }
    }
  }

  getElement() {
    return this.element;
  }

  append(element) {
    this.activate();
    this.containerElement.appendChild(element);
    this.table.rowManager.adjustTableSize();
  }

  prepend(element) {
    this.activate();
    this.element.insertBefore(element, this.element.firstChild);
    this.table.rowManager.adjustTableSize();
  }

  remove(element) {
    element.parentNode.removeChild(element);
    this.deactivate();
  }

  deactivate(force) {
    if (!this.element.firstChild || force) {
      if (!this.external) {
        this.element.parentNode.removeChild(this.element);
      }

      this.active = false;
    }
  }

  activate() {
    if (!this.active) {
      this.active = true;

      if (!this.external) {
        this.table.element.appendChild(this.getElement());
        this.table.element.style.display = '';
      }
    }
  }

  redraw() {
    this.dispatch("footer-redraw");
  }

}

class InteractionManager extends CoreFeature {
  constructor(table) {
    super(table);
    this.el = null;
    this.abortClasses = ["tabulator-headers", "tabulator-table"];
    this.previousTargets = {};
    this.listeners = ["click", "dblclick", "contextmenu", "mouseenter", "mouseleave", "mouseover", "mouseout", "mousemove", "touchstart", "touchend"];
    this.componentMap = {
      "tabulator-cell": "cell",
      "tabulator-row": "row",
      "tabulator-group": "group",
      "tabulator-col": "column"
    };
    this.pseudoTrackers = {
      "row": {
        subscriber: null,
        target: null
      },
      "cell": {
        subscriber: null,
        target: null
      },
      "group": {
        subscriber: null,
        target: null
      },
      "column": {
        subscriber: null,
        target: null
      }
    };
    this.pseudoTracking = false;
  }

  initialize() {
    this.el = this.table.element;
    this.buildListenerMap();
    this.bindSubscriptionWatchers();
  }

  buildListenerMap() {
    var listenerMap = {};
    this.listeners.forEach(listener => {
      listenerMap[listener] = {
        handler: null,
        components: []
      };
    });
    this.listeners = listenerMap;
  }

  bindPseudoEvents() {
    Object.keys(this.pseudoTrackers).forEach(key => {
      this.pseudoTrackers[key].subscriber = this.pseudoMouseEnter.bind(this, key);
      this.subscribe(key + "-mouseover", this.pseudoTrackers[key].subscriber);
    });
    this.pseudoTracking = true;
  }

  pseudoMouseEnter(key, e, target) {
    if (this.pseudoTrackers[key].target !== target) {
      if (this.pseudoTrackers[key].target) {
        this.dispatch(key + "-mouseleave", e, this.pseudoTrackers[key].target);
      }

      this.pseudoMouseLeave(key, e);
      this.pseudoTrackers[key].target = target;
      this.dispatch(key + "-mouseenter", e, target);
    }
  }

  pseudoMouseLeave(key, e) {
    var leaveList = Object.keys(this.pseudoTrackers),
        linkedKeys = {
      "row": ["cell"],
      "cell": ["row"]
    };
    leaveList = leaveList.filter(item => {
      var links = linkedKeys[key];
      return item !== key && (!links || links && !links.includes(item));
    });
    leaveList.forEach(key => {
      var target = this.pseudoTrackers[key].target;

      if (this.pseudoTrackers[key].target) {
        this.dispatch(key + "-mouseleave", e, target);
        this.pseudoTrackers[key].target = null;
      }
    });
  }

  bindSubscriptionWatchers() {
    var listeners = Object.keys(this.listeners),
        components = Object.values(this.componentMap);

    for (let comp of components) {
      for (let listener of listeners) {
        let key = comp + "-" + listener;
        this.subscriptionChange(key, this.subscriptionChanged.bind(this, comp, listener));
      }
    }

    this.subscribe("table-destroy", this.clearWatchers.bind(this));
  }

  subscriptionChanged(component, key, added) {
    var listener = this.listeners[key].components,
        index = listener.indexOf(component),
        changed = false;

    if (added) {
      if (index === -1) {
        listener.push(component);
        changed = true;
      }
    } else {
      if (!this.subscribed(component + "-" + key)) {
        if (index > -1) {
          listener.splice(index, 1);
          changed = true;
        }
      }
    }

    if ((key === "mouseenter" || key === "mouseleave") && !this.pseudoTracking) {
      this.bindPseudoEvents();
    }

    if (changed) {
      this.updateEventListeners();
    }
  }

  updateEventListeners() {
    for (let key in this.listeners) {
      let listener = this.listeners[key];

      if (listener.components.length) {
        if (!listener.handler) {
          listener.handler = this.track.bind(this, key);
          this.el.addEventListener(key, listener.handler); // this.el.addEventListener(key, listener.handler, {passive: true})
        }
      } else {
        if (listener.handler) {
          this.el.removeEventListener(key, listener.handler);
          listener.handler = null;
        }
      }
    }
  }

  track(type, e) {
    var path = e.composedPath && e.composedPath() || e.path;
    var targets = this.findTargets(path);
    targets = this.bindComponents(type, targets);
    this.triggerEvents(type, e, targets);

    if (this.pseudoTracking && (type == "mouseover" || type == "mouseleave") && !Object.keys(targets).length) {
      this.pseudoMouseLeave("none", e);
    }
  }

  findTargets(path) {
    var targets = {};
    let componentMap = Object.keys(this.componentMap);

    for (let el of path) {
      let classList = el.classList ? [...el.classList] : [];
      let abort = classList.filter(item => {
        return this.abortClasses.includes(item);
      });

      if (abort.length) {
        break;
      }

      let elTargets = classList.filter(item => {
        return componentMap.includes(item);
      });

      for (let target of elTargets) {
        if (!targets[this.componentMap[target]]) {
          targets[this.componentMap[target]] = el;
        }
      }
    }

    if (targets.group && targets.group === targets.row) {
      delete targets.row;
    }

    return targets;
  }

  bindComponents(type, targets) {
    //ensure row component is looked up before cell
    var keys = Object.keys(targets).reverse(),
        listener = this.listeners[type],
        targetMatches = {};

    for (let key of keys) {
      let component;
      let target = targets[key];
      let previousTarget = this.previousTargets[key];

      if (previousTarget && previousTarget.target === target) {
        component = previousTarget.component;
      } else {
        switch (key) {
          case "row":
          case "group":
            if (listener.components.includes("row") || listener.components.includes("cell") || listener.components.includes("group")) {
              let rows = this.table.rowManager.getVisibleRows(true);
              component = rows.find(row => {
                return row.getElement() === target;
              });

              if (targets["row"] && targets["row"].parentNode && targets["row"].parentNode.closest(".tabulator-row")) {
                targets[key] = false;
              }
            }

            break;

          case "column":
            if (listener.components.includes("column")) {
              component = this.table.columnManager.findColumn(target);
            }

            break;

          case "cell":
            if (listener.components.includes("cell")) {
              if (targets["row"] instanceof Row) {
                component = targets["row"].findCell(target);
              } else {
                if (targets["row"]) {
                  console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?");
                }
              }
            }

            break;
        }
      }

      if (component) {
        targets[key] = component;
        targetMatches[key] = {
          target: target,
          component: component
        };
      }
    }

    this.previousTargets = targetMatches;
    return targets;
  }

  triggerEvents(type, e, targets) {
    var listener = this.listeners[type];

    for (let key in targets) {
      if (targets[key] && listener.components.includes(key)) {
        this.dispatch(key + "-" + type, e, targets[key]);
      }
    }
  }

  clearWatchers() {
    for (let key in this.listeners) {
      let listener = this.listeners[key];

      if (listener.handler) {
        this.el.removeEventListener(key, listener.handler);
        listener.handler = null;
      }
    }
  }

}

class ComponentFunctionBinder {
  constructor(table) {
    this.table = table;
    this.bindings = {};
  }

  bind(type, funcName, handler) {
    if (!this.bindings[type]) {
      this.bindings[type] = {};
    }

    if (this.bindings[type][funcName]) {
      console.warn("Unable to bind component handler, a matching function name is already bound", type, funcName, handler);
    } else {
      this.bindings[type][funcName] = handler;
    }
  }

  handle(type, component, name) {
    if (this.bindings[type] && this.bindings[type][name] && typeof this.bindings[type][name].bind === 'function') {
      return this.bindings[type][name].bind(null, component);
    } else {
      if (name !== "then" && typeof name === "string" && !name.startsWith("_")) {
        if (this.table.options.debugInvalidComponentFuncs) {
          console.error("The " + type + " component does not have a " + name + " function, have you checked that you have the correct Tabulator module installed?");
        }
      }
    }
  }

}

class DataLoader extends CoreFeature {
  constructor(table) {
    super(table);
    this.requestOrder = 0; //prevent requests coming out of sequence if overridden by another load request

    this.loading = false;
  }

  initialize() {}

  load(data, params, config, replace, silent, columnsChanged) {
    var requestNo = ++this.requestOrder;
    this.dispatchExternal("dataLoading", data); //parse json data to array

    if (data && (data.indexOf("{") == 0 || data.indexOf("[") == 0)) {
      data = JSON.parse(data);
    }

    if (this.confirm("data-loading", [data, params, config, silent])) {
      this.loading = true;

      if (!silent) {
        this.alertLoader();
      } //get params for request


      params = this.chain("data-params", [data, config, silent], params || {}, params || {});
      params = this.mapParams(params, this.table.options.dataSendParams);
      var result = this.chain("data-load", [data, params, config, silent], false, Promise.resolve([]));
      return result.then(response => {
        if (!Array.isArray(response) && typeof response == "object") {
          response = this.mapParams(response, this.objectInvert(this.table.options.dataReceiveParams));
        }

        var rowData = this.chain("data-loaded", response, null, response);

        if (requestNo == this.requestOrder) {
          this.clearAlert();

          if (rowData !== false) {
            this.dispatchExternal("dataLoaded", rowData);
            this.table.rowManager.setData(rowData, replace, typeof columnsChanged === "undefined" ? !replace : columnsChanged);
          }
        } else {
          console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
        }
      }).catch(error => {
        console.error("Data Load Error: ", error);
        this.dispatchExternal("dataLoadError", error);

        if (!silent) {
          this.alertError();
        }

        setTimeout(() => {
          this.clearAlert();
        }, this.table.options.dataLoaderErrorTimeout);
      }).finally(() => {
        this.loading = false;
      });
    } else {
      this.dispatchExternal("dataLoaded", data);

      if (!data) {
        data = [];
      }

      this.table.rowManager.setData(data, replace, typeof columnsChanged === "undefined" ? !replace : columnsChanged);
      return Promise.resolve();
    }
  }

  mapParams(params, map) {
    var output = {};

    for (let key in params) {
      output[map.hasOwnProperty(key) ? map[key] : key] = params[key];
    }

    return output;
  }

  objectInvert(obj) {
    var output = {};

    for (let key in obj) {
      output[obj[key]] = key;
    }

    return output;
  }

  blockActiveLoad() {
    this.requestOrder++;
  }

  alertLoader() {
    var shouldLoad = typeof this.table.options.dataLoader === "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;

    if (shouldLoad) {
      this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
    }
  }

  alertError() {
    this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
  }

  clearAlert() {
    this.table.alertManager.clear();
  }

}

class ExternalEventBus {
  constructor(table, optionsList, debug) {
    this.table = table;
    this.events = {};
    this.optionsList = optionsList || {};
    this.subscriptionNotifiers = {};
    this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
    this.debug = debug;
  }

  subscriptionChange(key, callback) {
    if (!this.subscriptionNotifiers[key]) {
      this.subscriptionNotifiers[key] = [];
    }

    this.subscriptionNotifiers[key].push(callback);

    if (this.subscribed(key)) {
      this._notifySubscriptionChange(key, true);
    }
  }

  subscribe(key, callback) {
    if (!this.events[key]) {
      this.events[key] = [];
    }

    this.events[key].push(callback);

    this._notifySubscriptionChange(key, true);
  }

  unsubscribe(key, callback) {
    var index;

    if (this.events[key]) {
      if (callback) {
        index = this.events[key].findIndex(item => {
          return item === callback;
        });

        if (index > -1) {
          this.events[key].splice(index, 1);
        } else {
          console.warn("Cannot remove event, no matching event found:", key, callback);
          return;
        }
      } else {
        delete this.events[key];
      }
    } else {
      console.warn("Cannot remove event, no events set on:", key);
      return;
    }

    this._notifySubscriptionChange(key, false);
  }

  subscribed(key) {
    return this.events[key] && this.events[key].length;
  }

  _notifySubscriptionChange(key, subscribed) {
    var notifiers = this.subscriptionNotifiers[key];

    if (notifiers) {
      notifiers.forEach(callback => {
        callback(subscribed);
      });
    }
  }

  _dispatch() {
    var args = Array.from(arguments),
        key = args.shift(),
        result;

    if (this.events[key]) {
      this.events[key].forEach((callback, i) => {
        let callResult = callback.apply(this.table, args);

        if (!i) {
          result = callResult;
        }
      });
    }

    return result;
  }

  _debugDispatch() {
    var args = Array.from(arguments),
        key = args[0];
    args[0] = "ExternalEvent:" + args[0];

    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }

    return this._dispatch(...arguments);
  }

}

class InternalEventBus {
  constructor(debug) {
    this.events = {};
    this.subscriptionNotifiers = {};
    this.dispatch = debug ? this._debugDispatch.bind(this) : this._dispatch.bind(this);
    this.chain = debug ? this._debugChain.bind(this) : this._chain.bind(this);
    this.confirm = debug ? this._debugConfirm.bind(this) : this._confirm.bind(this);
    this.debug = debug;
  }

  subscriptionChange(key, callback) {
    if (!this.subscriptionNotifiers[key]) {
      this.subscriptionNotifiers[key] = [];
    }

    this.subscriptionNotifiers[key].push(callback);

    if (this.subscribed(key)) {
      this._notifySubscriptionChange(key, true);
    }
  }

  subscribe(key, callback, priority = 10000) {
    if (!this.events[key]) {
      this.events[key] = [];
    }

    this.events[key].push({
      callback,
      priority
    });
    this.events[key].sort((a, b) => {
      return a.priority - b.priority;
    });

    this._notifySubscriptionChange(key, true);
  }

  unsubscribe(key, callback) {
    var index;

    if (this.events[key]) {
      if (callback) {
        index = this.events[key].findIndex(item => {
          return item.callback === callback;
        });

        if (index > -1) {
          this.events[key].splice(index, 1);
        } else {
          console.warn("Cannot remove event, no matching event found:", key, callback);
          return;
        }
      }
    } else {
      console.warn("Cannot remove event, no events set on:", key);
      return;
    }

    this._notifySubscriptionChange(key, false);
  }

  subscribed(key) {
    return this.events[key] && this.events[key].length;
  }

  _chain(key, args, initialValue, fallback) {
    var value = initialValue;

    if (!Array.isArray(args)) {
      args = [args];
    }

    if (this.subscribed(key)) {
      this.events[key].forEach((subscriber, i) => {
        value = subscriber.callback.apply(this, args.concat([value]));
      });
      return value;
    } else {
      return typeof fallback === "function" ? fallback() : fallback;
    }
  }

  _confirm(key, args) {
    var confirmed = false;

    if (!Array.isArray(args)) {
      args = [args];
    }

    if (this.subscribed(key)) {
      this.events[key].forEach((subscriber, i) => {
        if (subscriber.callback.apply(this, args)) {
          confirmed = true;
        }
      });
    }

    return confirmed;
  }

  _notifySubscriptionChange(key, subscribed) {
    var notifiers = this.subscriptionNotifiers[key];

    if (notifiers) {
      notifiers.forEach(callback => {
        callback(subscribed);
      });
    }
  }

  _dispatch() {
    var args = Array.from(arguments),
        key = args.shift();

    if (this.events[key]) {
      this.events[key].forEach(subscriber => {
        subscriber.callback.apply(this, args);
      });
    }
  }

  _debugDispatch() {
    var args = Array.from(arguments),
        key = args[0];
    args[0] = "InternalEvent:" + key;

    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }

    return this._dispatch(...arguments);
  }

  _debugChain() {
    var args = Array.from(arguments),
        key = args[0];
    args[0] = "InternalEvent:" + key;

    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }

    return this._chain(...arguments);
  }

  _debugConfirm() {
    var args = Array.from(arguments),
        key = args[0];
    args[0] = "InternalEvent:" + key;

    if (this.debug === true || this.debug.includes(key)) {
      console.log(...args);
    }

    return this._confirm(...arguments);
  }

}

class DeprecationAdvisor extends CoreFeature {
  constructor(table) {
    super(table);
  }

  _warnUser() {
    if (this.options("debugDeprecation")) {
      console.warn(...arguments);
    }
  }

  check(oldOption, newOption) {
    var msg = "";

    if (typeof this.options(oldOption) !== "undefined") {
      msg = "Deprecated Setup Option - Use of the %c" + oldOption + "%c option is now deprecated";

      if (newOption) {
        msg = msg + ", Please use the %c" + newOption + "%c option instead";

        this._warnUser(msg, 'font-weight: bold;', 'font-weight: normal;', 'font-weight: bold;', 'font-weight: normal;');
      } else {
        this._warnUser(msg, 'font-weight: bold;', 'font-weight: normal;');
      }

      return false;
    } else {
      return true;
    }
  }

  checkMsg(oldOption, msg) {
    if (typeof this.options(oldOption) !== "undefined") {
      this._warnUser("%cDeprecated Setup Option - Use of the %c" + oldOption + " %c option is now deprecated, " + msg, 'font-weight: normal;', 'font-weight: bold;', 'font-weight: normal;');

      return false;
    } else {
      return true;
    }
  }

  msg(msg) {
    this._warnUser(msg);
  }

}

class TableRegistry {
  static register(table) {
    TableRegistry.tables.push(table);
  }

  static deregister(table) {
    var index = TableRegistry.tables.indexOf(table);

    if (index > -1) {
      TableRegistry.tables.splice(index, 1);
    }
  }

  static lookupTable(query, silent) {
    var results = [],
        matches,
        match;

    if (typeof query === "string") {
      matches = document.querySelectorAll(query);

      if (matches.length) {
        for (var i = 0; i < matches.length; i++) {
          match = TableRegistry.matchElement(matches[i]);

          if (match) {
            results.push(match);
          }
        }
      }
    } else if (typeof HTMLElement !== "undefined" && query instanceof HTMLElement || query instanceof Tabulator) {
      match = TableRegistry.matchElement(query);

      if (match) {
        results.push(match);
      }
    } else if (Array.isArray(query)) {
      query.forEach(function (item) {
        results = results.concat(TableRegistry.lookupTable(item));
      });
    } else {
      if (!silent) {
        console.warn("Table Connection Error - Invalid Selector", query);
      }
    }

    return results;
  }

  static matchElement(element) {
    return TableRegistry.tables.find(function (table) {
      return element instanceof Tabulator ? table === element : table.element === element;
    });
  }

}

TableRegistry.tables = []; //resize columns to fit data they contain

function fitData(columns, forced) {
  if (forced) {
    this.table.columnManager.renderer.reinitializeColumnWidths(columns);
  }

  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  }
} //resize columns to fit data they contain and stretch row to fill table, also used for fitDataTable


function fitDataGeneral(columns, forced) {
  columns.forEach(function (column) {
    column.reinitializeWidth();
  });

  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  }
} //resize columns to fit data the contain and stretch last column to fill table


function fitDataStretch(columns, forced) {
  var colsWidth = 0,
      tableWidth = this.table.rowManager.element.clientWidth,
      gap = 0,
      lastCol = false;
  columns.forEach((column, i) => {
    if (!column.widthFixed) {
      column.reinitializeWidth();
    }

    if (this.table.options.responsiveLayout ? column.modules.responsive.visible : column.visible) {
      lastCol = column;
    }

    if (column.visible) {
      colsWidth += column.getWidth();
    }
  });

  if (lastCol) {
    gap = tableWidth - colsWidth + lastCol.getWidth();

    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      lastCol.setWidth(0);
      this.table.modules.responsiveLayout.update();
    }

    if (gap > 0) {
      lastCol.setWidth(gap);
    } else {
      lastCol.reinitializeWidth();
    }
  } else {
    if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
      this.table.modules.responsiveLayout.update();
    }
  }
} //resize columns to fit


function fitColumns(columns, forced) {
  var totalWidth = this.table.rowManager.element.getBoundingClientRect().width; //table element width

  var fixedWidth = 0; //total width of columns with a defined width

  var flexWidth = 0; //total width available to flexible columns

  var flexGrowUnits = 0; //total number of widthGrow blocks across all columns

  var flexColWidth = 0; //desired width of flexible columns

  var flexColumns = []; //array of flexible width columns

  var fixedShrinkColumns = []; //array of fixed width columns that can shrink

  var flexShrinkUnits = 0; //total number of widthShrink blocks across all columns

  var overflowWidth = 0; //horizontal overflow width

  var gapFill = 0; //number of pixels to be added to final column to close and half pixel gaps

  function calcWidth(width) {
    var colWidth;

    if (typeof width == "string") {
      if (width.indexOf("%") > -1) {
        colWidth = totalWidth / 100 * parseInt(width);
      } else {
        colWidth = parseInt(width);
      }
    } else {
      colWidth = width;
    }

    return colWidth;
  } //ensure columns resize to take up the correct amount of space


  function scaleColumns(columns, freeSpace, colWidth, shrinkCols) {
    var oversizeCols = [],
        oversizeSpace = 0,
        remainingSpace = 0,
        nextColWidth = 0,
        remainingFlexGrowUnits = flexGrowUnits,
        gap = 0,
        changeUnits = 0,
        undersizeCols = [];

    function calcGrow(col) {
      return colWidth * (col.column.definition.widthGrow || 1);
    }

    function calcShrink(col) {
      return calcWidth(col.width) - colWidth * (col.column.definition.widthShrink || 0);
    }

    columns.forEach(function (col, i) {
      var width = shrinkCols ? calcShrink(col) : calcGrow(col);

      if (col.column.minWidth >= width) {
        oversizeCols.push(col);
      } else {
        if (col.column.maxWidth && col.column.maxWidth < width) {
          col.width = col.column.maxWidth;
          freeSpace -= col.column.maxWidth;
          remainingFlexGrowUnits -= shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;

          if (remainingFlexGrowUnits) {
            colWidth = Math.floor(freeSpace / remainingFlexGrowUnits);
          }
        } else {
          undersizeCols.push(col);
          changeUnits += shrinkCols ? col.column.definition.widthShrink || 1 : col.column.definition.widthGrow || 1;
        }
      }
    });

    if (oversizeCols.length) {
      oversizeCols.forEach(function (col) {
        oversizeSpace += shrinkCols ? col.width - col.column.minWidth : col.column.minWidth;
        col.width = col.column.minWidth;
      });
      remainingSpace = freeSpace - oversizeSpace;
      nextColWidth = changeUnits ? Math.floor(remainingSpace / changeUnits) : remainingSpace;
      gap = scaleColumns(undersizeCols, remainingSpace, nextColWidth, shrinkCols);
    } else {
      gap = changeUnits ? freeSpace - Math.floor(freeSpace / changeUnits) * changeUnits : freeSpace;
      undersizeCols.forEach(function (column) {
        column.width = shrinkCols ? calcShrink(column) : calcGrow(column);
      });
    }

    return gap;
  }

  if (this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", true)) {
    this.table.modules.responsiveLayout.update();
  } //adjust for vertical scrollbar if present


  if (this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight) {
    totalWidth -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth;
  }

  columns.forEach(function (column) {
    var width, minWidth, colWidth;

    if (column.visible) {
      width = column.definition.width;
      minWidth = parseInt(column.minWidth);

      if (width) {
        colWidth = calcWidth(width);
        fixedWidth += colWidth > minWidth ? colWidth : minWidth;

        if (column.definition.widthShrink) {
          fixedShrinkColumns.push({
            column: column,
            width: colWidth > minWidth ? colWidth : minWidth
          });
          flexShrinkUnits += column.definition.widthShrink;
        }
      } else {
        flexColumns.push({
          column: column,
          width: 0
        });
        flexGrowUnits += column.definition.widthGrow || 1;
      }
    }
  }); //calculate available space

  flexWidth = totalWidth - fixedWidth; //calculate correct column size

  flexColWidth = Math.floor(flexWidth / flexGrowUnits); //generate column widths

  gapFill = scaleColumns(flexColumns, flexWidth, flexColWidth, false); //increase width of last column to account for rounding errors

  if (flexColumns.length && gapFill > 0) {
    flexColumns[flexColumns.length - 1].width += gapFill;
  } //calculate space for columns to be shrunk into


  flexColumns.forEach(function (col) {
    flexWidth -= col.width;
  });
  overflowWidth = Math.abs(gapFill) + flexWidth; //shrink oversize columns if there is no available space

  if (overflowWidth > 0 && flexShrinkUnits) {
    gapFill = scaleColumns(fixedShrinkColumns, overflowWidth, Math.floor(overflowWidth / flexShrinkUnits), true);
  } //decrease width of last column to account for rounding errors


  if (gapFill && fixedShrinkColumns.length) {
    fixedShrinkColumns[fixedShrinkColumns.length - 1].width -= gapFill;
  }

  flexColumns.forEach(function (col) {
    col.column.setWidth(col.width);
  });
  fixedShrinkColumns.forEach(function (col) {
    col.column.setWidth(col.width);
  });
}

var defaultModes = {
  fitData: fitData,
  fitDataFill: fitDataGeneral,
  fitDataTable: fitDataGeneral,
  fitDataStretch: fitDataStretch,
  fitColumns: fitColumns
};

class Layout extends Module {
  constructor(table) {
    super(table, "layout");
    this.mode = null;
    this.registerTableOption("layout", "fitData"); //layout type

    this.registerTableOption("layoutColumnsOnNewData", false); //update column widths on setData

    this.registerColumnOption("widthGrow");
    this.registerColumnOption("widthShrink");
  } //initialize layout system


  initialize() {
    var layout = this.table.options.layout;

    if (Layout.modes[layout]) {
      this.mode = layout;
    } else {
      console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + layout);
      this.mode = 'fitData';
    }

    this.table.element.setAttribute("tabulator-layout", this.mode);
  }

  getMode() {
    return this.mode;
  } //trigger table layout


  layout(dataChanged) {
    this.dispatch("layout-refreshing");
    Layout.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, dataChanged);
    this.dispatch("layout-refreshed");
  }

}

Layout.moduleName = "layout"; //load defaults

Layout.modes = defaultModes;
var defaultLangs = {
  "default": {
    //hold default locale text
    "groups": {
      "item": "item",
      "items": "items"
    },
    "columns": {},
    "data": {
      "loading": "Loading",
      "error": "Error"
    },
    "pagination": {
      "page_size": "Page Size",
      "page_title": "Show Page",
      "first": "First",
      "first_title": "First Page",
      "last": "Last",
      "last_title": "Last Page",
      "prev": "Prev",
      "prev_title": "Prev Page",
      "next": "Next",
      "next_title": "Next Page",
      "all": "All",
      "counter": {
        "showing": "Showing",
        "of": "of",
        "rows": "rows",
        "pages": "pages"
      }
    },
    "headerFilters": {
      "default": "filter column...",
      "columns": {}
    }
  }
};

class Localize extends Module {
  constructor(table) {
    super(table);
    this.locale = "default"; //current locale

    this.lang = false; //current language

    this.bindings = {}; //update events to call when locale is changed

    this.langList = {};
    this.registerTableOption("locale", false); //current system language

    this.registerTableOption("langs", {});
  }

  initialize() {
    this.langList = Helpers.deepClone(Localize.langs);

    if (this.table.options.columnDefaults.headerFilterPlaceholder !== false) {
      this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
    }

    for (let locale in this.table.options.langs) {
      this.installLang(locale, this.table.options.langs[locale]);
    }

    this.setLocale(this.table.options.locale);
    this.registerTableFunction("setLocale", this.setLocale.bind(this));
    this.registerTableFunction("getLocale", this.getLocale.bind(this));
    this.registerTableFunction("getLang", this.getLang.bind(this));
  } //set header placeholder


  setHeaderFilterPlaceholder(placeholder) {
    this.langList.default.headerFilters.default = placeholder;
  } //set header filter placeholder by column


  setHeaderFilterColumnPlaceholder(column, placeholder) {
    this.langList.default.headerFilters.columns[column] = placeholder;

    if (this.lang && !this.lang.headerFilters.columns[column]) {
      this.lang.headerFilters.columns[column] = placeholder;
    }
  } //setup a lang description object


  installLang(locale, lang) {
    if (this.langList[locale]) {
      this._setLangProp(this.langList[locale], lang);
    } else {
      this.langList[locale] = lang;
    }
  }

  _setLangProp(lang, values) {
    for (let key in values) {
      if (lang[key] && typeof lang[key] == "object") {
        this._setLangProp(lang[key], values[key]);
      } else {
        lang[key] = values[key];
      }
    }
  } //set current locale


  setLocale(desiredLocale) {
    desiredLocale = desiredLocale || "default"; //fill in any matching language values

    function traverseLang(trans, path) {
      for (var prop in trans) {
        if (typeof trans[prop] == "object") {
          if (!path[prop]) {
            path[prop] = {};
          }

          traverseLang(trans[prop], path[prop]);
        } else {
          path[prop] = trans[prop];
        }
      }
    } //determining correct locale to load


    if (desiredLocale === true && navigator.language) {
      //get local from system
      desiredLocale = navigator.language.toLowerCase();
    }

    if (desiredLocale) {
      //if locale is not set, check for matching top level locale else use default
      if (!this.langList[desiredLocale]) {
        let prefix = desiredLocale.split("-")[0];

        if (this.langList[prefix]) {
          console.warn("Localization Error - Exact matching locale not found, using closest match: ", desiredLocale, prefix);
          desiredLocale = prefix;
        } else {
          console.warn("Localization Error - Matching locale not found, using default: ", desiredLocale);
          desiredLocale = "default";
        }
      }
    }

    this.locale = desiredLocale; //load default lang template

    this.lang = Helpers.deepClone(this.langList.default || {});

    if (desiredLocale != "default") {
      traverseLang(this.langList[desiredLocale], this.lang);
    }

    this.dispatchExternal("localized", this.locale, this.lang);

    this._executeBindings();
  } //get current locale


  getLocale(locale) {
    return this.locale;
  } //get lang object for given local or current if none provided


  getLang(locale) {
    return locale ? this.langList[locale] : this.lang;
  } //get text for current locale


  getText(path, value) {
    var fillPath = value ? path + "|" + value : path,
        pathArray = fillPath.split("|"),
        text = this._getLangElement(pathArray, this.locale); // if(text === false){
    // 	console.warn("Localization Error - Matching localized text not found for given path: ", path);
    // }


    return text || "";
  } //traverse langs object and find localized copy


  _getLangElement(path, locale) {
    var root = this.lang;
    path.forEach(function (level) {
      var rootPath;

      if (root) {
        rootPath = root[level];

        if (typeof rootPath != "undefined") {
          root = rootPath;
        } else {
          root = false;
        }
      }
    });
    return root;
  } //set update binding


  bind(path, callback) {
    if (!this.bindings[path]) {
      this.bindings[path] = [];
    }

    this.bindings[path].push(callback);
    callback(this.getText(path), this.lang);
  } //iterate through bindings and trigger updates


  _executeBindings() {
    for (let path in this.bindings) {
      this.bindings[path].forEach(binding => {
        binding(this.getText(path), this.lang);
      });
    }
  }

}

Localize.moduleName = "localize"; //load defaults

Localize.langs = defaultLangs;

class Comms extends Module {
  constructor(table) {
    super(table);
  }

  initialize() {
    this.registerTableFunction("tableComms", this.receive.bind(this));
  }

  getConnections(selectors) {
    var connections = [],
        connection;
    connection = TableRegistry.lookupTable(selectors);
    connection.forEach(con => {
      if (this.table !== con) {
        connections.push(con);
      }
    });
    return connections;
  }

  send(selectors, module, action, data) {
    var connections = this.getConnections(selectors);
    connections.forEach(connection => {
      connection.tableComms(this.table.element, module, action, data);
    });

    if (!connections.length && selectors) {
      console.warn("Table Connection Error - No tables matching selector found", selectors);
    }
  }

  receive(table, module, action, data) {
    if (this.table.modExists(module)) {
      return this.table.modules[module].commsReceived(table, action, data);
    } else {
      console.warn("Inter-table Comms Error - no such module:", module);
    }
  }

}

Comms.moduleName = "comms";
var coreModules = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LayoutModule: Layout,
  LocalizeModule: Localize,
  CommsModule: Comms
});

class ModuleBinder {
  constructor(tabulator, modules) {
    this.bindStaticFunctionality(tabulator);
    this.bindModules(tabulator, coreModules, true);

    if (modules) {
      this.bindModules(tabulator, modules);
    }
  }

  bindStaticFunctionality(tabulator) {
    tabulator.moduleBindings = {};

    tabulator.extendModule = function (name, property, values) {
      if (tabulator.moduleBindings[name]) {
        var source = tabulator.moduleBindings[name][property];

        if (source) {
          if (typeof values == "object") {
            for (let key in values) {
              source[key] = values[key];
            }
          } else {
            console.warn("Module Error - Invalid value type, it must be an object");
          }
        } else {
          console.warn("Module Error - property does not exist:", property);
        }
      } else {
        console.warn("Module Error - module does not exist:", name);
      }
    };

    tabulator.registerModule = function (modules) {
      if (!Array.isArray(modules)) {
        modules = [modules];
      }

      modules.forEach(mod => {
        tabulator.registerModuleBinding(mod);
      });
    };

    tabulator.registerModuleBinding = function (mod) {
      tabulator.moduleBindings[mod.moduleName] = mod;
    };

    tabulator.findTable = function (query) {
      var results = TableRegistry.lookupTable(query, true);
      return Array.isArray(results) && !results.length ? false : results;
    }; //ensure that module are bound to instantiated function


    tabulator.prototype.bindModules = function () {
      var orderedStartMods = [],
          orderedEndMods = [],
          unOrderedMods = [];
      this.modules = {};

      for (var name in tabulator.moduleBindings) {
        let mod = tabulator.moduleBindings[name];
        let module = new mod(this);
        this.modules[name] = module;

        if (mod.prototype.moduleCore) {
          this.modulesCore.push(module);
        } else {
          if (mod.moduleInitOrder) {
            if (mod.moduleInitOrder < 0) {
              orderedStartMods.push(module);
            } else {
              orderedEndMods.push(module);
            }
          } else {
            unOrderedMods.push(module);
          }
        }
      }

      orderedStartMods.sort((a, b) => a.moduleInitOrder > b.moduleInitOrder ? 1 : -1);
      orderedEndMods.sort((a, b) => a.moduleInitOrder > b.moduleInitOrder ? 1 : -1);
      this.modulesRegular = orderedStartMods.concat(unOrderedMods.concat(orderedEndMods));
    };
  }

  bindModules(tabulator, modules, core) {
    var mods = Object.values(modules);

    if (core) {
      mods.forEach(mod => {
        mod.prototype.moduleCore = true;
      });
    }

    tabulator.registerModule(mods);
  }

}

class Alert extends CoreFeature {
  constructor(table) {
    super(table);
    this.element = this._createAlertElement();
    this.msgElement = this._createMsgElement();
    this.type = null;
    this.element.appendChild(this.msgElement);
  }

  _createAlertElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-alert");
    return el;
  }

  _createMsgElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-alert-msg");
    el.setAttribute("role", "alert");
    return el;
  }

  _typeClass() {
    return "tabulator-alert-state-" + this.type;
  }

  alert(content, type = "msg") {
    if (content) {
      this.clear();
      this.type = type;

      while (this.msgElement.firstChild) this.msgElement.removeChild(this.msgElement.firstChild);

      this.msgElement.classList.add(this._typeClass());

      if (typeof content === "function") {
        content = content();
      }

      if (content instanceof HTMLElement) {
        this.msgElement.appendChild(content);
      } else {
        this.msgElement.innerHTML = content;
      }

      this.table.element.appendChild(this.element);
    }
  }

  clear() {
    if (this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }

    this.msgElement.classList.remove(this._typeClass());
  }

}

class Tabulator {
  constructor(element, options) {
    this.options = {};
    this.columnManager = null; // hold Column Manager

    this.rowManager = null; //hold Row Manager

    this.footerManager = null; //holder Footer Manager

    this.alertManager = null; //hold Alert Manager

    this.vdomHoz = null; //holder horizontal virtual dom

    this.externalEvents = null; //handle external event messaging

    this.eventBus = null; //handle internal event messaging

    this.interactionMonitor = false; //track user interaction

    this.browser = ""; //hold current browser type

    this.browserSlow = false; //handle reduced functionality for slower browsers

    this.browserMobile = false; //check if running on mobile, prevent resize cancelling edit on keyboard appearance

    this.rtl = false; //check if the table is in RTL mode

    this.originalElement = null; //hold original table element if it has been replaced

    this.componentFunctionBinder = new ComponentFunctionBinder(this); //bind component functions

    this.dataLoader = false; //bind component functions

    this.modules = {}; //hold all modules bound to this table

    this.modulesCore = []; //hold core modules bound to this table (for initialization purposes)

    this.modulesRegular = []; //hold regular modules bound to this table (for initialization purposes)

    this.deprecationAdvisor = new DeprecationAdvisor(this);
    this.optionsList = new OptionsList(this, "table constructor");
    this.initialized = false;
    this.destroyed = false;

    if (this.initializeElement(element)) {
      this.initializeCoreSystems(options); //delay table creation to allow event bindings immediately after the constructor

      setTimeout(() => {
        this._create();
      });
    }

    TableRegistry.register(this); //register table for inter-device communication
  }

  initializeElement(element) {
    if (typeof HTMLElement !== "undefined" && element instanceof HTMLElement) {
      this.element = element;
      return true;
    } else if (typeof element === "string") {
      this.element = document.querySelector(element);

      if (this.element) {
        return true;
      } else {
        console.error("Tabulator Creation Error - no element found matching selector: ", element);
        return false;
      }
    } else {
      console.error("Tabulator Creation Error - Invalid element provided:", element);
      return false;
    }
  }

  initializeCoreSystems(options) {
    this.columnManager = new ColumnManager(this);
    this.rowManager = new RowManager(this);
    this.footerManager = new FooterManager(this);
    this.dataLoader = new DataLoader(this);
    this.alertManager = new Alert(this);
    this.bindModules();
    this.options = this.optionsList.generate(Tabulator.defaultOptions, options);

    this._clearObjectPointers();

    this._mapDeprecatedFunctionality();

    this.externalEvents = new ExternalEventBus(this, this.options, this.options.debugEventsExternal);
    this.eventBus = new InternalEventBus(this.options.debugEventsInternal);
    this.interactionMonitor = new InteractionManager(this);
    this.dataLoader.initialize(); // this.columnManager.initialize();
    // this.rowManager.initialize();

    this.footerManager.initialize();
  } //convert deprecated functionality to new functions


  _mapDeprecatedFunctionality() {//all previously deprecated functionality removed in the 5.0 release
  }

  _clearSelection() {
    this.element.classList.add("tabulator-block-select");

    if (window.getSelection) {
      if (window.getSelection().empty) {
        // Chrome
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges) {
        // Firefox
        window.getSelection().removeAllRanges();
      }
    } else if (document.selection) {
      // IE?
      document.selection.empty();
    }

    this.element.classList.remove("tabulator-block-select");
  } //create table


  _create() {
    this.externalEvents.dispatch("tableBuilding");
    this.eventBus.dispatch("table-building");

    this._rtlCheck();

    this._buildElement();

    this._initializeTable();

    this._loadInitialData();

    this.initialized = true;
    this.externalEvents.dispatch("tableBuilt");
  }

  _rtlCheck() {
    var style = window.getComputedStyle(this.element);

    switch (this.options.textDirection) {
      case "auto":
        if (style.direction !== "rtl") {
          break;
        }

      case "rtl":
        this.element.classList.add("tabulator-rtl");
        this.rtl = true;
        break;

      case "ltr":
        this.element.classList.add("tabulator-ltr");

      default:
        this.rtl = false;
    }
  } //clear pointers to objects in default config object


  _clearObjectPointers() {
    this.options.columns = this.options.columns.slice(0);

    if (Array.isArray(this.options.data) && !this.options.reactiveData) {
      this.options.data = this.options.data.slice(0);
    }
  } //build tabulator element


  _buildElement() {
    var element = this.element,
        options = this.options,
        newElement;

    if (element.tagName === "TABLE") {
      this.originalElement = this.element;
      newElement = document.createElement("div"); //transfer attributes to new element

      var attributes = element.attributes; // loop through attributes and apply them on div

      for (var i in attributes) {
        if (typeof attributes[i] == "object") {
          newElement.setAttribute(attributes[i].name, attributes[i].value);
        }
      } // replace table with div element


      element.parentNode.replaceChild(newElement, element);
      this.element = element = newElement;
    }

    element.classList.add("tabulator");
    element.setAttribute("role", "grid"); //empty element

    while (element.firstChild) element.removeChild(element.firstChild); //set table height


    if (options.height) {
      options.height = isNaN(options.height) ? options.height : options.height + "px";
      element.style.height = options.height;
    } //set table min height


    if (options.minHeight !== false) {
      options.minHeight = isNaN(options.minHeight) ? options.minHeight : options.minHeight + "px";
      element.style.minHeight = options.minHeight;
    } //set table maxHeight


    if (options.maxHeight !== false) {
      options.maxHeight = isNaN(options.maxHeight) ? options.maxHeight : options.maxHeight + "px";
      element.style.maxHeight = options.maxHeight;
    }
  } //initialize core systems and modules


  _initializeTable() {
    var element = this.element,
        options = this.options;
    this.interactionMonitor.initialize();
    this.columnManager.initialize();
    this.rowManager.initialize();

    this._detectBrowser(); //initialize core modules


    this.modulesCore.forEach(mod => {
      mod.initialize();
    }); //build table elements

    element.appendChild(this.columnManager.getElement());
    element.appendChild(this.rowManager.getElement());

    if (options.footerElement) {
      this.footerManager.activate();
    }

    if (options.autoColumns && options.data) {
      this.columnManager.generateColumnsFromRowData(this.options.data);
    } //initialize regular modules


    this.modulesRegular.forEach(mod => {
      mod.initialize();
    });
    this.columnManager.setColumns(options.columns);
    this.eventBus.dispatch("table-built");
  }

  _loadInitialData() {
    this.dataLoader.load(this.options.data);
  } //deconstructor


  destroy() {
    var element = this.element;
    this.destroyed = true;
    TableRegistry.deregister(this); //deregister table from inter-device communication

    this.eventBus.dispatch("table-destroy"); //clear row data

    this.rowManager.rows.forEach(function (row) {
      row.wipe();
    });
    this.rowManager.rows = [];
    this.rowManager.activeRows = [];
    this.rowManager.displayRows = []; //clear DOM

    while (element.firstChild) element.removeChild(element.firstChild);

    element.classList.remove("tabulator");
    this.externalEvents.dispatch("tableDestroyed");
  }

  _detectBrowser() {
    var ua = navigator.userAgent || navigator.vendor || window.opera;

    if (ua.indexOf("Trident") > -1) {
      this.browser = "ie";
      this.browserSlow = true;
    } else if (ua.indexOf("Edge") > -1) {
      this.browser = "edge";
      this.browserSlow = true;
    } else if (ua.indexOf("Firefox") > -1) {
      this.browser = "firefox";
      this.browserSlow = false;
    } else {
      this.browser = "other";
      this.browserSlow = false;
    }

    this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(ua) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(ua.slice(0, 4));
  }

  initGuard(func, msg) {
    var stack, line;

    if (this.options.debugInitialization && !this.initialized) {
      if (!func) {
        stack = new Error().stack.split("\n");
        line = stack[0] == "Error" ? stack[2] : stack[1];

        if (line[0] == " ") {
          func = line.trim().split(" ")[1].split(".")[1];
        } else {
          func = line.trim().split("@")[0];
        }
      }

      console.warn("Table Not Initialized - Calling the " + func + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (msg ? " " + msg : ""));
    }

    return this.initialized;
  } ////////////////// Data Handling //////////////////
  //block table redrawing


  blockRedraw() {
    this.initGuard();
    this.eventBus.dispatch("redraw-blocking");
    this.rowManager.blockRedraw();
    this.columnManager.blockRedraw();
    this.eventBus.dispatch("redraw-blocked");
  } //restore table redrawing


  restoreRedraw() {
    this.initGuard();
    this.eventBus.dispatch("redraw-restoring");
    this.rowManager.restoreRedraw();
    this.columnManager.restoreRedraw();
    this.eventBus.dispatch("redraw-restored");
  } //load data


  setData(data, params, config) {
    this.initGuard(false, "To set initial data please use the 'data' property in the table constructor.");
    return this.dataLoader.load(data, params, config, false);
  } //clear data


  clearData() {
    this.initGuard();
    this.dataLoader.blockActiveLoad();
    this.rowManager.clearData();
  } //get table data array


  getData(active) {
    return this.rowManager.getData(active);
  } //get table data array count


  getDataCount(active) {
    return this.rowManager.getDataCount(active);
  } //replace data, keeping table in position with same sort


  replaceData(data, params, config) {
    this.initGuard();
    return this.dataLoader.load(data, params, config, true, true);
  } //update table data


  updateData(data) {
    var responses = 0;
    this.initGuard();
    return new Promise((resolve, reject) => {
      this.dataLoader.blockActiveLoad();

      if (typeof data === "string") {
        data = JSON.parse(data);
      }

      if (data) {
        data.forEach(item => {
          var row = this.rowManager.findRow(item[this.options.index]);

          if (row) {
            responses++;
            row.updateData(item).then(() => {
              responses--;

              if (!responses) {
                resolve();
              }
            });
          }
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  }

  addData(data, pos, index) {
    this.initGuard();
    return new Promise((resolve, reject) => {
      this.dataLoader.blockActiveLoad();

      if (typeof data === "string") {
        data = JSON.parse(data);
      }

      if (data) {
        this.rowManager.addRows(data, pos, index).then(rows => {
          var output = [];
          rows.forEach(function (row) {
            output.push(row.getComponent());
          });
          resolve(output);
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  } //update table data


  updateOrAddData(data) {
    var rows = [],
        responses = 0;
    this.initGuard();
    return new Promise((resolve, reject) => {
      this.dataLoader.blockActiveLoad();

      if (typeof data === "string") {
        data = JSON.parse(data);
      }

      if (data) {
        data.forEach(item => {
          var row = this.rowManager.findRow(item[this.options.index]);
          responses++;

          if (row) {
            row.updateData(item).then(() => {
              responses--;
              rows.push(row.getComponent());

              if (!responses) {
                resolve(rows);
              }
            });
          } else {
            this.rowManager.addRows(item).then(newRows => {
              responses--;
              rows.push(newRows[0].getComponent());

              if (!responses) {
                resolve(rows);
              }
            });
          }
        });
      } else {
        console.warn("Update Error - No data provided");
        reject("Update Error - No data provided");
      }
    });
  } //get row object


  getRow(index) {
    var row = this.rowManager.findRow(index);

    if (row) {
      return row.getComponent();
    } else {
      console.warn("Find Error - No matching row found:", index);
      return false;
    }
  } //get row object


  getRowFromPosition(position) {
    var row = this.rowManager.getRowFromPosition(position);

    if (row) {
      return row.getComponent();
    } else {
      console.warn("Find Error - No matching row found:", position);
      return false;
    }
  } //delete row from table


  deleteRow(index) {
    var foundRows = [];
    this.initGuard();

    if (!Array.isArray(index)) {
      index = [index];
    } //find matching rows


    for (let item of index) {
      let row = this.rowManager.findRow(item, true);

      if (row) {
        foundRows.push(row);
      } else {
        console.error("Delete Error - No matching row found:", item);
        return Promise.reject("Delete Error - No matching row found");
      }
    } //sort rows into correct order to ensure smooth delete from table


    foundRows.sort((a, b) => {
      return this.rowManager.rows.indexOf(a) > this.rowManager.rows.indexOf(b) ? 1 : -1;
    }); //delete rows

    foundRows.forEach(row => {
      row.delete();
    });
    this.rowManager.reRenderInPosition();
    return Promise.resolve();
  } //add row to table


  addRow(data, pos, index) {
    this.initGuard();

    if (typeof data === "string") {
      data = JSON.parse(data);
    }

    return this.rowManager.addRows(data, pos, index).then(rows => {
      return rows[0].getComponent();
    });
  } //update a row if it exists otherwise create it


  updateOrAddRow(index, data) {
    var row = this.rowManager.findRow(index);
    this.initGuard();

    if (typeof data === "string") {
      data = JSON.parse(data);
    }

    if (row) {
      return row.updateData(data).then(() => {
        return row.getComponent();
      });
    } else {
      return this.rowManager.addRows(data).then(rows => {
        return rows[0].getComponent();
      });
    }
  } //update row data


  updateRow(index, data) {
    var row = this.rowManager.findRow(index);
    this.initGuard();

    if (typeof data === "string") {
      data = JSON.parse(data);
    }

    if (row) {
      return row.updateData(data).then(() => {
        return Promise.resolve(row.getComponent());
      });
    } else {
      console.warn("Update Error - No matching row found:", index);
      return Promise.reject("Update Error - No matching row found");
    }
  } //scroll to row in DOM


  scrollToRow(index, position, ifVisible) {
    var row = this.rowManager.findRow(index);

    if (row) {
      return this.rowManager.scrollToRow(row, position, ifVisible);
    } else {
      console.warn("Scroll Error - No matching row found:", index);
      return Promise.reject("Scroll Error - No matching row found");
    }
  }

  moveRow(from, to, after) {
    var fromRow = this.rowManager.findRow(from);
    this.initGuard();

    if (fromRow) {
      fromRow.moveToRow(to, after);
    } else {
      console.warn("Move Error - No matching row found:", from);
    }
  }

  getRows(active) {
    return this.rowManager.getComponents(active);
  } //get position of row in table


  getRowPosition(index) {
    var row = this.rowManager.findRow(index);

    if (row) {
      return row.getPosition();
    } else {
      console.warn("Position Error - No matching row found:", index);
      return false;
    }
  } /////////////// Column Functions  ///////////////


  setColumns(definition) {
    this.initGuard(false, "To set initial columns please use the 'columns' property in the table constructor");
    this.columnManager.setColumns(definition);
  }

  getColumns(structured) {
    return this.columnManager.getComponents(structured);
  }

  getColumn(field) {
    var column = this.columnManager.findColumn(field);

    if (column) {
      return column.getComponent();
    } else {
      console.warn("Find Error - No matching column found:", field);
      return false;
    }
  }

  getColumnDefinitions() {
    return this.columnManager.getDefinitionTree();
  }

  showColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();

    if (column) {
      column.show();
    } else {
      console.warn("Column Show Error - No matching column found:", field);
      return false;
    }
  }

  hideColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();

    if (column) {
      column.hide();
    } else {
      console.warn("Column Hide Error - No matching column found:", field);
      return false;
    }
  }

  toggleColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();

    if (column) {
      if (column.visible) {
        column.hide();
      } else {
        column.show();
      }
    } else {
      console.warn("Column Visibility Toggle Error - No matching column found:", field);
      return false;
    }
  }

  addColumn(definition, before, field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();
    return this.columnManager.addColumn(definition, before, column).then(column => {
      return column.getComponent();
    });
  }

  deleteColumn(field) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();

    if (column) {
      return column.delete();
    } else {
      console.warn("Column Delete Error - No matching column found:", field);
      return Promise.reject();
    }
  }

  updateColumnDefinition(field, definition) {
    var column = this.columnManager.findColumn(field);
    this.initGuard();

    if (column) {
      return column.updateDefinition(definition);
    } else {
      console.warn("Column Update Error - No matching column found:", field);
      return Promise.reject();
    }
  }

  moveColumn(from, to, after) {
    var fromColumn = this.columnManager.findColumn(from),
        toColumn = this.columnManager.findColumn(to);
    this.initGuard();

    if (fromColumn) {
      if (toColumn) {
        this.columnManager.moveColumn(fromColumn, toColumn, after);
      } else {
        console.warn("Move Error - No matching column found:", toColumn);
      }
    } else {
      console.warn("Move Error - No matching column found:", from);
    }
  } //scroll to column in DOM


  scrollToColumn(field, position, ifVisible) {
    return new Promise((resolve, reject) => {
      var column = this.columnManager.findColumn(field);

      if (column) {
        return this.columnManager.scrollToColumn(column, position, ifVisible);
      } else {
        console.warn("Scroll Error - No matching column found:", field);
        return Promise.reject("Scroll Error - No matching column found");
      }
    });
  } //////////// General Public Functions ////////////
  //redraw list without updating data


  redraw(force) {
    this.initGuard();
    this.columnManager.redraw(force);
    this.rowManager.redraw(force);
  }

  setHeight(height) {
    this.options.height = isNaN(height) ? height : height + "px";
    this.element.style.height = this.options.height;
    this.rowManager.initializeRenderer();
    this.rowManager.redraw();
  } //////////////////// Event Bus ///////////////////


  on(key, callback) {
    this.externalEvents.subscribe(key, callback);
  }

  off(key, callback) {
    this.externalEvents.unsubscribe(key, callback);
  }

  dispatchEvent() {
    var args = Array.from(arguments);
    args.shift();
    this.externalEvents.dispatch(...arguments);
  } //////////////////// Alerts ///////////////////


  alert(contents, type) {
    this.initGuard();
    this.alertManager.alert(contents, type);
  }

  clearAlert() {
    this.initGuard();
    this.alertManager.clear();
  } ////////////// Extension Management //////////////


  modExists(plugin, required) {
    if (this.modules[plugin]) {
      return true;
    } else {
      if (required) {
        console.error("Tabulator Module Not Installed: " + plugin);
      }

      return false;
    }
  }

  module(key) {
    var mod = this.modules[key];

    if (!mod) {
      console.error("Tabulator module not installed: " + key);
    }

    return mod;
  }

} //default setup options


exports.Tabulator = Tabulator;
Tabulator.defaultOptions = defaultOptions; //bind modules and static functionality

new ModuleBinder(Tabulator); //tabulator with all modules installed

class TabulatorFull extends Tabulator {} //bind modules and static functionality


exports.TabulatorFull = TabulatorFull;
new ModuleBinder(TabulatorFull, modules);

class PseudoRow {
  constructor(type) {
    this.type = type;
    this.element = this._createElement();
  }

  _createElement() {
    var el = document.createElement("div");
    el.classList.add("tabulator-row");
    return el;
  }

  getElement() {
    return this.element;
  }

  getComponent() {
    return false;
  }

  getData() {
    return {};
  }

  getHeight() {
    return this.element.outerHeight;
  }

  initialize() {}

  reinitialize() {}

  normalizeHeight() {}

  generateCells() {}

  reinitializeHeight() {}

  calcHeight() {}

  setCellHeight() {}

  clearCellHeight() {}

}

exports.PseudoRow = PseudoRow;
},{}],"Focm":[function(require,module,exports) {
"use strict";

var bootstrap = _interopRequireWildcard(require("bootstrap"));

var _fs = require("fs");

var _http = require("http");

var _path = require("path");

var _tabulatorTables = require("tabulator-tables");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

//initial page set up
$("#newForm").hide();
$("#newForm2").hide();
$("#searchForm2").hide(); //events to happen when user clicks on new customer

$("#link1").on("click", function () {
  $("#picture-container").hide();
  $("#searchForm").hide();
  $("#searchForm2").hide();
  $("#newForm").show();
  $("#newForm2").hide();
  $(".resultCard").hide();
  $(".resultCard2").hide();
  $("#formTitle").text("New Customer Information");
}); //events to happen when user clicks on existing customer

$("#link2").on("click", function () {
  $("#picture-container").show();
  $("#searchForm").show();
  $("#newForm").hide();
  $("#newForm2").hide();
  $("#searchForm2").hide();
  $(".resultCard").hide();
  $(".resultCard2").hide();
});
$("#link3").on("click", function () {
  $("#picture-container").hide();
  $("#searchForm").hide();
  $("#newForm").hide();
  $("#newForm2").show();
  $(".resultCard").hide();
  $(".resultCard2").hide();
  $("#searchForm2").hide();
  $("#formTitle2").text("New Appointment Information");
  $('#chooseCustomer').empty();
  $.get("api/lash/", function (data) {
    data.forEach(function (el) {
      var identifier = el.customer_id;
      var name = el.first_name + " " + el.last_name;
      name = capitalizer(name);
      $('<option></option>').text(name).attr('id', identifier).appendTo($('#chooseCustomer'));
    });
  });
});
$("#link4").on("click", function () {
  $("#picture-container").hide();
  $("#searchForm").hide();
  $("#newForm").hide();
  $("#newForm2").hide();
  $(".resultCard").hide();
  $(".resultCard2").hide();
  $("#searchForm2").show();
}); //lots of code just to automatically choose brand based on tweezers

$("#newTweezers").on("change", function () {
  var selectedTweezers = $('select[id="newTweezers"]').val();

  if (selectedTweezers == "Curved Isolation" || selectedTweezers == "M.I.L.F") {
    $("#newBrand").val("Mish Esthetics");
  } else if (selectedTweezers == "P6 Ultimate Volume" || selectedTweezers == "P0 90 Degree Volume") {
    $("#newBrand").val("Paris Lash Academy");
  } else if (selectedTweezers == "Blue Magic Mike" || selectedTweezers == "Straight Up" || selectedTweezers == "Just The Tip" || selectedTweezers == "Pink Isolating") {
    $("#newBrand").val("Liv Bay Lash");
  } else {
    $("#newBrand").val("Invalid");
  }
}); //prepares object with data to be sent in post/patch req

var prepareObj = function prepareObj() {
  var obj = {};
  obj.first_name = $('input[id="newFirstName"]').val().toLowerCase();
  obj.last_name = $('input[id="newLastName"]').val().toLowerCase();
  obj.phone_number = $('input[id="newPhoneNumber"]').val();
  obj.eye_shape = $('select[id="newEyeShape"]').val().toLowerCase();
  obj.lash_type = $('select[id="newLashType"]').val().toLowerCase();
  obj.tweezers = $('select[id="newTweezers"]').val(); //.toLowerCase();

  obj.brand = $('input[id="newBrand"]').val().toLowerCase();
  return obj;
}; //creates req id as global variable because it needs to be accessed in multiple functions


var reqId = ""; //reassigns req id based on selected row

var getReqId = function getReqId(row) {
  if (row) {
    reqId = row.getData().ID;
  } else {
    return reqId;
  }
}; //User form sends either post or patch req based on how the form was accessed


var $userForm = $("#newForm");
$userForm.submit(function (event) {
  event.preventDefault();
  var obj = prepareObj();

  if ($("#formTitle").text() == "New Customer Information") {
    $.ajax({
      type: "post",
      url: "/api/lash",
      data: JSON.stringify(obj),
      contentType: "application/json",
      statusCode: {
        400: function _() {
          alert("Customer already exists");
        },
        201: function _() {
          alert("Successfully created customer");
        }
      }
    });
  } else if ($("#formTitle").text() === "Update Customer Information") {
    var _reqId = getReqId();

    $.ajax({
      type: "patch",
      url: "/api/lash/".concat(_reqId),
      data: JSON.stringify(obj),
      contentType: "application/json",
      statusCode: {
        400: function _() {
          alert("Update failed, please check input.");
        },
        200: function _() {
          alert("Successfully updated customer");
        }
      }
    });
  } else {}
}); //capitalizes first letter for display

var capitalizer = function capitalizer(str) {
  if (str.includes(" ")) {
    var str2 = str.split(/\b\s+/);
    var result = "";

    for (var i = 0; i < str2.length; i++) {
      result += str2[i].charAt(0).toUpperCase() + str2[i].slice(1) + " ";
    }

    result = result.trim();
    return result;
  }

  return str.charAt(0).toUpperCase() + str.slice(1);
}; //delete req based on selected customer


var deleteCustomer = function deleteCustomer(row) {
  var obj = {};
  obj.id = row.getData().ID;
  $.ajax({
    type: "delete",
    url: "/api/lash",
    data: JSON.stringify(obj),
    contentType: "application/json"
  });
  row.delete();
};

var deleteApp = function deleteApp(row) {
  var obj = {};
  obj.id = row.getData().ID;
  $.ajax({
    type: "delete",
    url: "/api/app",
    data: JSON.stringify(obj),
    contentType: "application/json"
  });
  row.delete();
}; //prepares  form for customer update


var updateCustomer = function updateCustomer(row) {
  $("#picture-container").hide();
  $("#searchForm").hide();
  $("#newForm").show();
  $(".resultCard").hide();
  $(".resultCard2").hide();
  $("#formTitle").text("Update Customer Information");
  getReqId(row);
  $('input[id="newFirstName"]').val(row.getData()["First Name"]);
  $('input[id="newLastName"]').val(row.getData()["Last Name"]);
  $('input[id="newPhoneNumber"]').val(row.getData()["Phone Number"]);
  $('select[id="newEyeShape"]').val(row.getData()["Eye Shape"]);
  $('select[id="newLashType"]').val(row.getData()["Lash Type"]);
  $('select[id="newTweezers"]').val(row.getData()["Tweezers"]);
  $('input[id="newBrand"]').val(row.getData()["Brand"]);
};

var updateApp = function updateApp(row) {
  $("#picture-container").hide();
  $("#searchForm2").hide();
  $("#newForm2").show();
  $(".resultCard2").hide();
  $("#searchForm").hide();
  $(".resultCard").hide();
  $("#formTitle2").text("Update Appointment Information");
  $('#chooseCustomer').empty();
  getReqId(row);
  $.get("api/lash/", function (data) {
    data.forEach(function (el) {
      var identifier = el.customer_id;
      var name = el.first_name + " " + el.last_name;
      name = capitalizer(name);
      $('<option></option>').text(name).attr('id', identifier).appendTo($('#chooseCustomer'));
    });
  });
  $('select[id="chooseCustomer"]').val(row.getData()["First Name"] + ' ' + row.getData()["Last Name"]);
  $('input[id="newDate"').val(row.getData()["Date"]);
  $('select[id="newLashStyle"]').val(row.getData()["Lash Style"]);
  $('select[id="newLength"]').val(row.getData()["Length"]);
  $('select[id="newThickness"]').val(row.getData()["Thickness"]);
  $('select[id="newCurl"]').val(row.getData()["Curl"]);
  $('select[id="newGlue"]').val(row.getData()["Glue"]);

  if (row.getData()["Primer"] === 'Yes') {
    $('#extraProduct1').prop('checked', true);
  } else if (row.getData()["Primer"] === 'No') {
    $('#extraProduct1').prop('checked', false);
  }

  if (row.getData()["Bonder"] === 'Yes') {
    $('#extraProduct2').prop('checked', true);
  } else if (row.getData()["Bonder"] === 'No') {
    $('#extraProduct2').prop('checked', false);
  }

  if (row.getData()["Cleanser"] === 'Yes') {
    $('#extraProduct3').prop('checked', true);
  } else if (row.getData()["Cleanser"] === 'No') {
    $('#extraProduct3').prop('checked', false);
  }
}; //table creation function


var tableCreation = function tableCreation(data) {
  //define data
  var tabledata = [];

  if (data.tableChooser === 'customerTable') {
    data.forEach(function (el) {
      var obj = {};
      obj["ID"] = el.customer_id;
      obj["First Name"] = capitalizer(el.first_name);
      obj["Last Name"] = capitalizer(el.last_name);
      obj["Phone Number"] = el.phone_number;
      obj["Eye Shape"] = capitalizer(el.eye_shape);
      obj["Lash Type"] = capitalizer(el.lash_type);
      obj["Tweezers"] = el.tweezers;
      obj["Brand"] = capitalizer(el.brand);
      tabledata.push(obj);
    });
    $("<div></div>").addClass("resultCard").appendTo($("body"));
    $(".resultCard").show(); //define table

    var table = new _tabulatorTables.TabulatorFull(".resultCard", {
      data: tabledata,
      columns: [{
        title: "ID",
        field: "ID",
        visible: false
      }, {
        title: "First Name",
        field: "First Name"
      }, {
        title: "Last Name",
        field: "Last Name"
      }, {
        title: "Phone Number",
        field: "Phone Number"
      }, {
        title: "Eye Shape",
        field: "Eye Shape"
      }, {
        title: "Lash Type",
        field: "Lash Type"
      }, {
        title: "Tweezers",
        field: "Tweezers"
      }, {
        title: "Brand",
        field: "Brand"
      }],
      layout: "fitDataStretch",
      pagination: true,
      selectable: 1,
      paginationSize: 5,
      paginationInitialPage: 1,
      rowFormatter: function rowFormatter(row) {
        row.getElement().style.textColor = "#1e3b20";
      },
      rowContextMenu: [{
        label: "Update",
        action: function action(e, row) {
          if (confirm("Are you sure you want to update?")) {
            updateCustomer(row);
          }
        }
      }, {
        separator: true
      }, {
        label: "Delete",
        action: function action(e, row) {
          if (confirm("Are you sure you want to delete?")) {
            deleteCustomer(row);
          }
        }
      }]
    });
  } else if (data.tableChooser === 'appTable') {
    data.forEach(function (el) {
      var obj = {};
      obj["ID"] = el.appointment_id;
      obj["Date"] = el.date;
      obj["First Name"] = capitalizer(el.first_name);
      obj["Last Name"] = capitalizer(el.last_name);
      obj["Lash Style"] = capitalizer(el.lash_style);
      obj["Curl"] = capitalizer(el.curl);
      obj["Length"] = el.length;
      obj["Thickness"] = el.thickness;
      obj["Glue"] = capitalizer(el.glue);
      obj["Bonder"] = el.bonder === true ? 'Yes' : 'No';
      obj["Primer"] = el.primer === true ? 'Yes' : 'No';
      obj["Cleanser"] = el.cleanser === true ? 'Yes' : 'No';
      tabledata.push(obj);
    });
    $("<div></div>").addClass("resultCard2").appendTo($("body"));
    $(".resultCard2").show(); //define table

    var table2 = new _tabulatorTables.TabulatorFull(".resultCard2", {
      data: tabledata,
      columns: [{
        title: "ID",
        field: "ID",
        visible: false
      }, {
        title: "First Name",
        field: "First Name"
      }, {
        title: "Last Name",
        field: "Last Name"
      }, {
        title: "Date",
        field: "Date"
      }, {
        title: "Lash Style",
        field: "Lash Style"
      }, {
        title: "Curl",
        field: "Curl"
      }, {
        title: "Length",
        field: "Length"
      }, {
        title: "Thickness",
        field: "Thickness"
      }, {
        title: "Glue",
        field: "Glue"
      }, {
        title: "Primer",
        field: "Primer"
      }, {
        title: "Bonder",
        field: "Bonder"
      }, {
        title: "Cleanser",
        field: "Cleanser"
      }],
      layout: "fitDataStretch",
      pagination: true,
      paginationSize: 5,
      paginationInitialPage: 1,
      rowFormatter: function rowFormatter(row) {
        row.getElement().style.textColor = "#1e3b20";
      },
      rowContextMenu: [{
        label: "Update",
        action: function action(e, row) {
          if (confirm("Are you sure you want to update?")) {
            updateApp(row);
          }
        }
      }, {
        separator: true
      }, {
        label: "Delete",
        action: function action(e, row) {
          if (confirm("Are you sure you want to delete?")) {
            deleteApp(row);
          }
        }
      }]
    });
  }

  var compare = {};
  table.on("rowClick", function (e, row) {
    if (row.getData() != compare) {
      var customId = row.getData().ID;
      $.get("/api/sp/".concat(customId), function (data) {
        data.tableChooser = 'appTable';
        tableCreation(data);
      }).fail(function () {
        alert("No appointments found for selected customer.");
        $(".resultCard2").hide();
      });
      compare = row.getData();
    } else {
      $(".resultCard2").hide();
      compare = {};
    }
  });
}; //get request from search bar then creates table


var $searchForm = $("#searchForm");
$searchForm.submit(function (event) {
  event.preventDefault();
  searchText = $('input[id="searchText"]').val();
  $("#picture-container").hide();
  $.get("/api/lash/".concat(searchText), function (data) {
    data.tableChooser = 'customerTable';
    tableCreation(data);
  }).fail(function () {
    alert("No customer found.");
  });
});
var $searchForm2 = $("#searchForm2");
$searchForm2.submit(function (event) {
  event.preventDefault();
  searchText = $('input[id="searchDate"]').val();
  $.get("/api/app/".concat(searchText), function (data) {
    data.tableChooser = 'appTable';
    tableCreation(data);
  }).fail(function () {
    alert("No appointment found.");
    $('.resultCard2').hide();
  });
}); //User form sends either post or patch req based on how the form was accessed

var $userForm2 = $("#newForm2");
$userForm2.submit(function (event) {
  event.preventDefault();
  var obj = {};
  obj.name = $('select[id="chooseCustomer"]').val().toLowerCase();
  obj.date = $('input[id="newDate"').val();
  obj.lash_style = $('select[id="newLashStyle"]').val().toLowerCase();
  obj.length = $('select[id="newLength"]').val().toLowerCase();
  obj.thickness = $('select[id="newThickness"]').val().toLowerCase();
  obj.curl = $('select[id="newCurl"]').val().toLowerCase();
  obj.glue = $('select[id="newGlue"]').val().toLowerCase();

  if ($('#extraProduct1').is(':checked')) {
    obj.primer = true;
  } else {
    obj.primer = false;
  }

  if ($('#extraProduct2').is(':checked')) {
    obj.bonder = true;
  } else {
    obj.bonder = false;
  }

  if ($('#extraProduct3').is(':checked')) {
    obj.cleanser = true;
  } else {
    obj.cleanser = false;
  }

  if (obj.date === '') {
    alert('Please enter a date.');
  } else {
    if ($('#formTitle2').text() === 'New Appointment Information') {
      $.ajax({
        type: "post",
        url: "/api/app",
        data: JSON.stringify(obj),
        contentType: "application/json",
        statusCode: {
          400: function _() {
            alert("Appointment creation, please check input.");
          },
          201: function _() {
            alert("Successfully created appointment.");
          }
        }
      });
    } else if ($('#formTitle2').text() === 'Update Appointment Information') {
      var _reqId2 = getReqId();

      $.ajax({
        type: "patch",
        url: "/api/app/".concat(_reqId2),
        data: JSON.stringify(obj),
        contentType: "application/json",
        statusCode: {
          400: function _() {
            alert("Update failed, please check input.");
          },
          200: function _() {
            alert("Successfully updated appointment.");
          }
        }
      });
    }
  }
});
},{"bootstrap":"xqrD","fs":"VUDL","http":"fwyw","path":"d0NU","tabulator-tables":"liHC"}]},{},["Focm"], null)
//# sourceMappingURL=src.9d19433c.js.map